### 1. OS 与并发

=== "code"

    ```C
    for (int i = 0; i < 1e7; ++i) {
        counter = counter + 1;
    }
    ```

=== "asm"

    ```asm
    mov  0x8049a1c, %eax
    add  0x1, %eax
    mov  %eax, 0x8049a1c
    ```

假设有两个线程运行该代码，线程 1 在 `add` 处遇到时钟中断，调度线程 2 运行，就会导致 bug

-   竞态条件 (race condition): 多个进/线程竞争资源而出现问题 (例如上例)
-   临界区 (critical section): 导致静态条件的代码区，该区不能由多个线程同时执行
-   互斥 (mutual exclusion): 同一时刻只有一个线程执行临界区

应用程序需要以同步和受控的方式访问临界区，为此需要 OS 和硬件的支持

-   如果临界区很短，假如可以将其压缩为一条指令 (如上例可创造一个 `memory-add`)，不会被中断，保证了原子性，此即同步原语
-   但并非所有临界区都可压缩，因此 OS 需要提供锁机制，锁本身需要同步原语实现
-   OS 本身也是一个并发程序 (例如两个进程同时写入一个文件)
