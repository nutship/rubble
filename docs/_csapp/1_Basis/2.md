$\global\def\imm{\mathit{Imm}}$
$\global\def\r{\mathrm{r}}$
$\global\def\M{\mathrm{M}}$
$\global\def\R{\mathrm{R}}$
$\global\def\rsp{\mathtt{\%rsp}}$

### 1. 数据类型

#### (1). 数据格式

由于 Intel 是从 16 位机器做起，用 字 (word) 表示 16 bit 数据类型，称 32 位数为 双字，称 64 位数为四字 (quad words)。

<font class="t_a%0&0_b%20_h%0&0">

|  C 声明  |  Intel 数据类型  | 汇编后缀 | 字节 |
| :------: | :--------------: | :------: | :--: |
|  `char`  |       byte       |    b     |  1   |
| `short`  |       word       |    w     |  2   |
|  `int`   |   double words   |    l     |  4   |
|  `long`  |    quad words    |    q     |  8   |
| `char*`  |    quad words    |    q     |  8   |
| `float`  | single precision |    s     |  4   |
| `double` | double precision |    l     |  8   |

</font>

后缀 `l` 表示双字是因为 32 位数被看成长字 (long word)。由于浮点数使用完全不同的指令和寄存器，因此不会有歧义。

#### (2). 寄存器

x86-64 的 cpu 包含一组 16 个存储 64 位值的通用寄存器。向后兼容的部分是由于从 8086 到 IA32 再到 x86-64 的演化，`%r8 - %r15` 是 x86-64 后新增的寄存器。

<!-- prettier-ignore-start -->
??? hint "x86-64 registers"
    <img src="../img/registers.png" width="560">
<!-- prettier-ignore-end -->

如果指令在寄存器中生成小于 8 byte 的结果:

-   1 字节或 2 字节: 保持剩下的位不变
-   4 字节: 把高位 4 字节置 0，这是由 IA32 到 x86-64 扩展时采用的

### 2. 基本指令

#### (1). 操作数指示符

<font class="t_a%0&0_b%20_h%3&0">

| Form                             | Operand Value (s=1/2/4/8)        | Name                |
| :------------------------------- | :------------------------------- | :------------------ |
| $\text{\textdollar}\mathit{Imm}$ | $\imm$                           | immediate           |
| $\r_a$                           | $R[\r_a ]$                       | register            |
| $\imm$                           | $\mathrm{M}[\imm ]$              | absolute            |
| $(\r_a)$                         | $\mathrm{M[R[\r_a ]]}$           | indirect            |
| $\imm(\r_b)$                     | $\M[\imm +\R[\r_b ]]$            | Base + displacement |
| $(\r_b, \r_i)$                   | $\M[\R[\r_b ] +\R[\r_i ]]$       | indexed             |
| $\imm (\r_b, \r_i)$              | $\M[\imm+ \R[\r_b ] +\R[\r_i ]]$ | indexed             |
| $(,\r_i, s)$                     | $ \M[\R[\r_i ]\cdot s]$          | scaled indexed      |
| ...                              | ...                              | ...                 |

操作数格式有三种:

-   立即数 (immediate):&ensp; 表示常数，在 ATT 格式用 $ \text{\textdollar}$ 作为前缀，后接一个标准 C 表示法的整数
-   寄存器 (register):&ensp; 表示寄存器中的内容，用 $\R[\r ]$ 引用其中的值
-   内存引用:&ensp; 根据计算出来的地址访问某个内存位置，有多种寻址方式，基本形式为 $\imm(\r_b, \r_i, s)$，分别表示立即数偏移、基址寄存器、变址寄存器和比例因子，计算为 $\imm + \R[\r_b ] + \R[\r_i ] \cdot s$

</font>

#### (2). 数据传送指令

最基本的传送指令是 MOV 类: `mov S, D`，把源数据复制到目的位置。

-   `movb`, `movw`, `movl`, `movq`，注意 `movl` 会把寄存器高位置 0
-   `movabsq I, R` 以任意四字的立即数作为源，且只能复制到寄存器

MOVZ 和 MOVS 类把较小的源复制到较大的目的处并做扩展，且目的只能是寄存器，例如:

-   `movzbq`: 将做了零扩展的字节传送到四字
-   `movswq`: 将做了符号扩展的字传送到四字
-   `cltq`: 把 `%eax` 符号扩展到 `%rax`

#### (3). 栈操作

x86-64 中，栈放在内存的某个区域，栈顶在低地址方向

| instructions | effect                                                                  | equiv instr                          |
| :----------- | :---------------------------------------------------------------------- | :----------------------------------- |
| `pushq S`    | $\R[\rsp ] \leftarrow\R[\rsp ] - 8$<br> $\M[\R[ \rsp]] \leftarrow S$    | `subq $8, %rsp`<br> `movq S, (%rsp)` |
| `popq D`     | $D \leftarrow \M[ \R[ \rsp]]$ <br> $\R[\rsp ] \leftarrow \R[\rsp ] + 8$ | `movq (%rsp), D`<br> `addq $8, %rsp` |
