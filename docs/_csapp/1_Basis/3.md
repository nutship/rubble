### 1. 过程

过程是重要的机器级抽象，要提供对它的机器级支持，至少需要以下机制 (以 P 调用 Q，Q 返回 P 为例):

-   转移控制:&ensp;P 进入 Q 和 Q 返回 P 时，正确设置 PC 的值
-   传递数据:&ensp;P 向 Q 传递多个参数，Q 向 P 返回一个值
-   分配和释放内存:&ensp;Q 可能需要局部空间，并在返回 P 前释放

#### (1). 转移控制

假设紧跟 `call` 指令之后的地址是 `A`，`Label` 的起始地址是 `B`

| instruction     | effect                               |
| :-------------- | :----------------------------------- |
| `call Label`    | `pushq A`, &ensp;`mov B, %rip`       |
| `call *Operand` | `pushq A`, &ensp;`mov Operand, %rip` |
| `ret`           | `popq %rip`                          |

#### (2). 传递数据

P 调用 Q 时，先要把参数复制到适当的寄存器中，然后再转移控制:

-   x86-64 中，可以通过寄存器最多传递 6 个整型参数，超过 6 个的部分通过栈传递，且参数 7 位于栈顶方向、所有参数向 8 字节对齐
-   访问的寄存器名取决于数据大小，例如，如果参数 1 是 32 位的，可通过 `%edi` 访问

??? adcodes "example"

    === "&emsp;C&emsp;"

        ```C
        void proc(long  a1, long*  a1p, int  a2, int*  a2p,
                  short a3, short* a3p, char a4, char* a4p) {
            *a1p += a1;
            *a2p += a2;
            *a3p += a3;
            *a4p += a4;
        }
        ```

    === "&emsp;assembly&emsp;"

        ```asm
        ;Arguments passed as follows:
        ; a1   in %rdi (64),   a1p  in %rsi (64)
        ; a2   in %edx (32),   a2p  in %rcx (64)
        ; a3   in %r8w (16),   a3p  in %r9  (64)
        ; a4   at %rsp+8 (8),  a4p  at %rsp+16 (64)
        proc:
            movq	16(%rsp), %rax
            addq	%rdi, (%rsi)
            addl	%edx, (%rcx)
            addw	%r8w, (%r9)
            movl	8(%rsp), %edx
            addb	%dl, (%rax)
            ret
        ```

#### (3). 栈上的局部存储

为提高效率，x86-64 会尽可能少地使用栈帧，
