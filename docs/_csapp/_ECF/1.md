### 1. 异常

异常是 ECF 的一种，作用是响应处理器的状态变化 (event)，由硬件和 OS 协作完成:

-   每种异常都有唯一的异常号，一部分由 cpu 设计者分配，另一部分由 OS kernel 设计者分配
-   系统启动时，OS 初始化异常表，表目 $k$ 指向相应的异常处理程序
-   系统执行某程序时，cpu 检测到 event、确定异常号 $k$ 并调用异常处理程序

<font class="i_l_b%30" id="cpu generates addr of handler">
<img src="../img/gen_addr_of_handler.png">
</font>

<font class="t_a%0&0_b%10_h%3&0">

| Class     | Cause                         | Async/Sync | Return Behavior      |
| :-------- | :---------------------------- | :--------- | :------------------- |
| Interrupt | Signal from I/O device        | 异步       | 总是返回到下一条指令 |
| Trap      | Intentional                   | 同步       | 总是返回到下一条指令 |
| Fault     | Potentially recoverable error | 同步       | 可能返回到当前指令   |
| Abort     | Nonrecoverable error          | 同步       | 不会返回             |

</font>

#### (1). 中断

中断由外部 I/O 设备的信号导致，与指令无关，因此是异步的。执行逻辑为:

-   I/O 设备 (e.g. 网络适配器, 磁盘控制器, 定时器芯片) 向 cpu 一个引脚发信号，并将异常号放到系统总线上 (该异常号标识引起中断的设备)
-   当前指令执行完成后，cpu 注意到引脚电压变高，从总线读取异常号并调用 handler
-   控制返回给下一条指令，仿佛什么也没发生

剩下的异常类型均与执行的指令相关

#### (2). 陷阱和系统调用

陷阱是有意的异常，用途是提供用户程序到 OS kernel 的接口 —— 系统调用。<br>
Linux 提供几百种系统调用 (32 ~ 255)，OS kernel 为系统调用额外维护一张跳转表。

-   C 程序可以通过 `syscall` 函数直接进行系统调用，但标准 C 库有大多数系统调用的 wrapper
-   x86-64 通过 `syscall` 指令进行系统调用，所有参数只通过寄存器传递，传递规则和函数相同

#### (3). 故障和终止

<font class="u_1">

-   故障由错误情况引起，如果 handler 可以修正，控制返回到引起故障的指令 $I_{\it curr}$，否则就调用内核的 abort routine，它会终止引起错误的应用程序
-   终止通常是致命的硬件错误，例如 DRAM / SRAM 位损坏造成的奇偶错误，handler 不会尝试返回，直接将控制交给 abort routine

</font>

Linux/x86-64 常见的 故障/终止 举例:

<font class="t_a%0&0_b%10_h%3&0">

| Exception Number | Description              | Exception Class |
| :--------------: | :----------------------- | :-------------- |
|        0         | Divide error             | Fault           |
|        13        | General protection fault | Fault           |
|        14        | Page fault               | Fault           |
|        18        | Machine check            | Abort           |

</font>

<font class="u_1">

-   除法错误: 除以 0 或 除法指令的结果对于目标操作数太大。Unix 不会尝试恢复
-   一般保护故障: 引用未定义虚存区域或尝试写入只读区，Linux 不会尝试恢复，一般报告为段错误
-   机器检查: 致命的硬件错误

</font>

### 2. 进程

进程是计算机科学中最深刻、最成功的概念之一。不关注 OS 实现进程的细节，只关心进程的重要抽象:

-   独立的逻辑控制流: &ensp; 仿佛程序独占处理器
-   独立的地址空间: &ensp; 方法程序独立地使用内存系统

#### (1). 控制流

<font class="i_l_b%30">
<img src="../img/processabc.png">
</font>

每个进程执行它的逻辑流的一部分，然后被抢占 (preempted)，轮到其他程序，仿佛在独占 cpu

-   并发流 (concurrent): &ensp; 逻辑流的时间区间与另一个流重叠，例如 Process AB、AC，此概念与处理器核数和计算机数无关
-   多进程轮流执行的概念称为多任务，一个进程控制流的某个时间段称为时间片 (time slice)
-   并行流 (parallel): &ensp; 两个流在不同的处理器上并发，并发流的真子集

#### (2). 用户模式和内核模式

OS kernel 要想实现无懈可击的进程抽象，cpu 必须提供一种机制，可以限制程序访问的地址范围 & 执行的指令种类。cpu 通常用控制寄存器的某个模式位实现此功能，当模式位为 1，进程就运行在 kernel mode 中: &ensp; 可以访问内存的任何位置，可以执行任意指令。

-   程序初始处于 user mode:&ensp; 不允许执行 privileged instruction，例如改变模式位、发起 I/O 操作，也不允许访问内核区的代码和数据，只能由系统调用接口间接访问，任何越权操作都会导致故障
-   从 user mode 进入 kernel mode 唯一方法是通过异常，异常发生时，控制传递给 handler，cpu 同时进入 kernel mode；控制返回到应用程序时，cpu 也返回到 user mode

#### (3). 上下文切换

上下文切换 (context switch) 是一种高层的 ECF，建立在异常机制之上，OS 通过此方式实现多任务。内核为每个进程维持上下文:

-   通用寄存器、浮点寄存器、程序计数器、状态寄存器、用户栈、内核栈等
-   内核数据结构，如: 页表、进程表、文件表

内核中的调度器 (scheduler) 代码决定抢占进程的策略，当前进程被抢占后，就会发生上下文切换:

-   保存当前进程的上下文，恢复先前某个被抢占进程的上下文
-   将控制传递给新恢复的进程

中断和系统调用都可以导致上下文切换，例如:

??? hint "example"

    <img src="../img/contextswitcheg.png" width=590>

    -   进程 A 由系统调用 `read` 陷入到内核 mode，内核的 handler 请求磁盘控制器的 DMA 传输
    -   磁盘取数据需要较长时间，内核很可能执行从 A 到 B 的上下文切换，而不是什么也不做:
        -   切换前，内核代表进程 A 在 kernel mode 下执行指令
        -   切换后，内核代表进程 B 在 user mode 下执行指令
    -   进程 B 在 user mode 下运行了一会后，直到磁盘发出了一个中断信号，表示数据已经从磁盘传到了内存，此时内核可能认为 B 已经执行了足够长的时间，上下文切换到 A
