### 1. 动态链接

静态链接在一定程度上提高了模块化的效率，但:

-   浪费内存: &ensp; 每个 C 程序的代码段都有标准 I/O 函数
-   不易更新: &ensp; 如果某个模块 `xx.o` 更新，可能需要整个项目重新编译

共享库是致力于解决静态库缺陷的现代产物。"共享" 体现在于:

-   同一个项目下只需要 `xx.so` 的一个副本
-   不同进程在内存中共享 `xx.so` 的 `.text` 节

=== "addvec.c"

    ```C
    int addcnt = 0;

    void addvec(int *x, int *y, int *z, int n) {
        int i;
        addcnt++;
        for (i = 0; i < n; ++i)
            z[i] = x[i] + y[i];
    }
    ```

=== "multvec.c"

    ```C
    int multcnt = 0;

    void multvec(int *x, int *y, int *z, int n) {
        int i;
        multcnt++;
        for (i = 0; i < n; ++i)
            z[i] = x[i] * y[i];
    }
    ```

=== "main.c"

    ```C
    #include <stdio.h>
    #include "vector.h"

    int x[2] = {1, 2};
    int y[2] = {3, 4};
    int z[2];

    int main() {
        addvec(x, y, z, 2);
        printf("z = [%d %d]\n", z[0], z[1]);
        return 0;
    }
    ```

仍以这部分程序为例，先通过链接创建共享库，在将它链接到可执行程序中:

```console
$ gcc -shared -fpic -o libvector.so addvec.c multvec.c
$ gcc -no-pie -o progd main.c ./libvector.so
```

动态链接的程序的执行逻辑为:

-   先执行部分链接，复制一些符号表和重定位信息，方便运行时解析对 `libvector.so` 的引用
-   运行 `prog` 后，对很多符号的引用还处于无效状态，loader 先把控制传递给动态链接器，执行动态链接:
    -   重定位 `libc.so` 和 `libvector.so` 的代码和数据到不同的内存段
    -   重定位 `prog` 中对上述二者的所有符号的引用
-   将控制传递给 `prog`

<!-- 1% ~ 5% -->
<!-- GOT PLT 重定位时候才填的 -->

### 2. 位置无关代码

#### (1). Global Offset Table

共享库的重要特性在于:

-   位置无关的，i.e. 编译时不确定内存地址，可以被加载到内存的任何位置不影响使用
-   不同进程共享 shared lib 的代码段 `.text`，且进程代码区只读

同静态链接一样，加载到内存后，不同模块之间需要重定位，由于代码段共享且只读，只能把代码段重定位时需要修改的地方分离到数据段。ELF 的做法是在数据段建立一个指针数组 —— 全局偏移表 (GOT)，由于代码段和数据段距离固定，代码段中的指令很容易得到 GOT 表的内容。

#### (2). Lazy Binding & Procedure Linkage Table

可能有很多函数根本执行不到 (例如一些错误处理函数)，重定位时把所有函数全部链接好是没有必要的，由此 GNU 采用延迟绑定 (lazy binding) 对动态链接进行优化。基本思路为:

-   第一次调用某函数时，调用 dl，并把 reloc entry 传给它，进行重定位

代码区额外定义了一个过程链接表 (PLT)，通过 GOT 和 PLT 的协作实现对函数的延迟绑定。具体实现上， ELF 将 `.got` 拆分成两个部分:

-   `.got.plt`: 保存函数的地址
    -   `.got.plt[0]`: &ensp; 保存 `.dynamic` 段的地址
    -   `.got.plt[1]`: &ensp;
    -   `.got.plt[2]`: &ensp; 动态链接器 `ld-linux.so` 的入口点
-   `.got`: 保存全局变量的地址

??? hint "example: &ensp;`progd`"

    用 `readelf` 查看 `progd` 的 GOT 和 PLT 表 (运行前，关闭栈随机化):

    === "disas of .plt"

        ```objdump
        Disassembly of section .plt:

        0000000000401020 <.plt>:
            401020:	ff 35 e2 2f 00 00    	pushq  0x2fe2(%rip)  # 404008 <_GLOBAL_OFFSET_TABLE_+0x8>
            401026:	ff 25 e4 2f 00 00    	jmpq   *0x2fe4(%rip) # 404010 <_GLOBAL_OFFSET_TABLE_+0x10>
            40102c:	0f 1f 40 00          	nopl   0x0(%rax)

        0000000000401030 <printf@plt>:
            401030:	ff 25 e2 2f 00 00    	jmpq   *0x2fe2(%rip) # 404018 <printf@GLIBC_2.2.5>
            401036:	68 00 00 00 00       	pushq  $0x0
            40103b:	e9 e0 ff ff ff       	jmpq   401020 <.plt>

        0000000000401040 <addvec@plt>:
            401040:	ff 25 da 2f 00 00    	jmpq   *0x2fda(%rip) # 404020 <addvec>
            401046:	68 01 00 00 00       	pushq  $0x1
            40104b:	e9 d0 ff ff ff       	jmpq   401020 <.plt>
        ```

    === "view &ensp;.got.plt"

        ```console
        $ readelf -x .got.plt progd

        NOTE: This section has relocations against it, but these have NOT been applied to this dump.
            0x00404000: 003e4000 00000000 00000000 00000000 .>@.............
            0x00404010: 00000000 00000000 36104000 00000000 ........6.@.....
            0x00404020: 46104000 00000000                   F.@.....
        ```

    === "view &ensp;.dynamic"

        ```console
        $ readelf -x .dynamic progd
        0x00403e00 01000000 00000000 66000000 00000000 ........f.......
        0x00403e10 01000000 00000000 75000000 00000000 ........u.......
        ... ...
        ```

    从中提取信息，总结为下图

    <font class="i_n">
    <img src="../img/soeg.png" width=550>
    </font>

当 `addvec` 第一次被调用时:

<font class="u_nn">

-   ①. 不直接调用 `addvec`，先进入它的 PLT 条目 `.plt[2]`
-   ②. 跳转到 `.got.plt[4]`，而它指向 `.plt[2]` 的第二条指令，等价于执行下一条语句
-   ③. 把 `addvec` 的 ID `0x1` 压入栈中，跳转到 `.plt[0]`，把 dl 需要的参数压入栈中
-   ④. 间接跳转到 dl 中，此时栈中有 `0x1` 和 `.got.plt[1]` 两个参数，dl 根据参数确定 `addvec` 的运行时地址，重写 `.got.plt[4]`，然后把控制交还给 `addvec`

</font>

??? hint "通过 `gdb` 查看延迟绑定的过程:"

    === "gdb commands"

        ```console
        $ gdb progd
        ...
        $ (gdb) b* 0x401154
        Breakpoint 1 at 0x401154
        $ (gdb) b* 0x401159
        Breakpoint 2 at 0x401159
        $ (gdb) run
        Breakpoint 1, 0x0000000000401154 in main ()
        $ (gdb) maint info sections
        ... ...
        [19]     0x00403e00->0x00403fe0 at 0x00002e00: .dynamic ALLOC LOAD DATA HAS_CONTENTS
        [20]     0x00403fe0->0x00404000 at 0x00002fe0: .got ALLOC LOAD DATA HAS_CONTENTS
        [21]     0x00404000->0x00404028 at 0x00003000: .got.plt ALLOC LOAD DATA HAS_CONTENTS
        [22]     0x00404028->0x00404048 at 0x00003028: .data ALLOC LOAD DATA HAS_CONTENTS
        [23]     0x00404048->0x00404058 at 0x00003048: .bss ALLOC
        ... ...
        $ (gdb) x/5xg 0x404000
        0x404000:       0x0000000000403e00      0x00007ffff7ffe1a0
        0x404010:       0x00007ffff7fe7d30      0x0000000000401036
        0x404020 <addvec@got.plt>:      0x0000000000401046
        $ (gdb) continue
        Continuing.
        Breakpoint 2, 0x0000000000401159 in main ()
        $ (gdb) x/5xg 0x404000
        0x404000:       0x0000000000403e00      0x00007ffff7ffe1a0
        0x404010:       0x00007ffff7fe7d30      0x0000000000401036
        0x404020 <addvec@got.plt>:      0x00007ffff7fc40e9
        ```

    === "disas of main"

        ```objdump
        0000000000401136 <main>:
            401136:	55                   	push   %rbp
            401137:	48 89 e5             	mov    %rsp,%rbp
            40113a:	b9 02 00 00 00       	mov    $0x2,%ecx
            40113f:	48 8d 15 0a 2f 00 00 	lea    0x2f0a(%rip),%rdx        # 404050 <z>
            401146:	48 8d 35 f3 2e 00 00 	lea    0x2ef3(%rip),%rsi        # 404040 <y>
            40114d:	48 8d 3d e4 2e 00 00 	lea    0x2ee4(%rip),%rdi        # 404038 <x>
            401154:	e8 e7 fe ff ff       	callq  401040 <addvec@plt>
            401159:	8b 15 f5 2e 00 00    	mov    0x2ef5(%rip),%edx        # 404054 <z+0x4>
            40115f:	8b 05 eb 2e 00 00    	mov    0x2eeb(%rip),%eax        # 404050 <z>
            401165:	89 c6                	mov    %eax,%esi
            401167:	48 8d 3d 96 0e 00 00 	lea    0xe96(%rip),%rdi        # 402004 <_IO_stdin_used+0x4>
            40116e:	b8 00 00 00 00       	mov    $0x0,%eax
            401173:	e8 b8 fe ff ff       	callq  401030 <printf@plt>
            401178:	b8 00 00 00 00       	mov    $0x0,%eax
            40117d:	5d                   	pop    %rbp
            40117e:	c3                   	retq
            40117f:	90                   	nop
        ```

### 3. 相关数据结构

#### (1). `.interp`

动态链接器的路径由 ELF 文件决定，以字符串的形式保存在 `.interp` 中。

```console
$ readelf -l progd | grep interpreter
    [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
```

#### (2). `.dynamic`

`.dynamic` 对动态链接来说是最重要的结构，保存了以下基本信息:

-   可执行程序依赖于哪些共享对象
-   动态链接符号表的位置, 动态链接重定位表的位置
-   共享对象初始化代码的地址 等

```C
typedef struct {
    Elf64_Sxword	d_tag;	    /* Dynamic entry type */
    union {
        Elf64_Xword d_val;		/* Integer value */
        Elf64_Addr  d_ptr;	    /* Address value */
    } d_un;
} Elf64_Dyn;
```

`.dynamic` 也是一个结构数组，由类型值 `d_tag` 和附加的数据组成。一些常见的类型有:

<font class="t_a%0&0_b%7_h%3&0">

| value of `d_tag`   | meaning of `d_un`                                     |
| :----------------- | :---------------------------------------------------- |
| `DT_SYMTAB`        | 动态链接符号表的地址，`d_ptr` 表示 `.dynsym` 的地址   |
| `DT_STRTAB`        | 动态链接字符串表的地址，`d_ptr` 表示 `.dynstr` 的地址 |
| `DT_STRSZ`         | 动态链接字符串大小，`d_val` 表示大小                  |
| `DT_HASH`          | 动态链接 hash 表地址，`d_ptr` 表示 `.hash` 的地址     |
| `DT_INIT`          | 初始化代码地址                                        |
| `DT_NEED`          | 依赖的共享库文件，`d_ptr` 表示文件名                  |
| `DT_REL / DT_RELA` | 动态链接重定位表地址                                  |

</font>

<!-- 怎么重定位的 -->
